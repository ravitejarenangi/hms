
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Nurse
 * 
 */
export type Nurse = $Result.DefaultSelection<Prisma.$NursePayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionMedicine
 * 
 */
export type PrescriptionMedicine = $Result.DefaultSelection<Prisma.$PrescriptionMedicinePayload>
/**
 * Model Medicine
 * 
 */
export type Medicine = $Result.DefaultSelection<Prisma.$MedicinePayload>
/**
 * Model InventoryLog
 * 
 */
export type InventoryLog = $Result.DefaultSelection<Prisma.$InventoryLogPayload>
/**
 * Model LabReport
 * 
 */
export type LabReport = $Result.DefaultSelection<Prisma.$LabReportPayload>
/**
 * Model RadiologyReport
 * 
 */
export type RadiologyReport = $Result.DefaultSelection<Prisma.$RadiologyReportPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Bed
 * 
 */
export type Bed = $Result.DefaultSelection<Prisma.$BedPayload>
/**
 * Model Ward
 * 
 */
export type Ward = $Result.DefaultSelection<Prisma.$WardPayload>
/**
 * Model BedAllocation
 * 
 */
export type BedAllocation = $Result.DefaultSelection<Prisma.$BedAllocationPayload>
/**
 * Model VitalSign
 * 
 */
export type VitalSign = $Result.DefaultSelection<Prisma.$VitalSignPayload>
/**
 * Model OperationTheater
 * 
 */
export type OperationTheater = $Result.DefaultSelection<Prisma.$OperationTheaterPayload>
/**
 * Model Surgery
 * 
 */
export type Surgery = $Result.DefaultSelection<Prisma.$SurgeryPayload>
/**
 * Model OperationTheaterEquipment
 * 
 */
export type OperationTheaterEquipment = $Result.DefaultSelection<Prisma.$OperationTheaterEquipmentPayload>
/**
 * Model MedicalGasCylinder
 * 
 */
export type MedicalGasCylinder = $Result.DefaultSelection<Prisma.$MedicalGasCylinderPayload>
/**
 * Model EquipmentMaintenance
 * 
 */
export type EquipmentMaintenance = $Result.DefaultSelection<Prisma.$EquipmentMaintenancePayload>
/**
 * Model Ambulance
 * 
 */
export type Ambulance = $Result.DefaultSelection<Prisma.$AmbulancePayload>
/**
 * Model AmbulanceService
 * 
 */
export type AmbulanceService = $Result.DefaultSelection<Prisma.$AmbulanceServicePayload>
/**
 * Model BiometricData
 * 
 */
export type BiometricData = $Result.DefaultSelection<Prisma.$BiometricDataPayload>
/**
 * Model AttendanceLog
 * 
 */
export type AttendanceLog = $Result.DefaultSelection<Prisma.$AttendanceLogPayload>
/**
 * Model DutyRoster
 * 
 */
export type DutyRoster = $Result.DefaultSelection<Prisma.$DutyRosterPayload>
/**
 * Model TPA
 * 
 */
export type TPA = $Result.DefaultSelection<Prisma.$TPAPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model SalaryPayment
 * 
 */
export type SalaryPayment = $Result.DefaultSelection<Prisma.$SalaryPaymentPayload>
/**
 * Model EmployeeDocument
 * 
 */
export type EmployeeDocument = $Result.DefaultSelection<Prisma.$EmployeeDocumentPayload>
/**
 * Model PerformanceReview
 * 
 */
export type PerformanceReview = $Result.DefaultSelection<Prisma.$PerformanceReviewPayload>
/**
 * Model SubsidyScheme
 * 
 */
export type SubsidyScheme = $Result.DefaultSelection<Prisma.$SubsidySchemePayload>
/**
 * Model PatientSubsidy
 * 
 */
export type PatientSubsidy = $Result.DefaultSelection<Prisma.$PatientSubsidyPayload>
/**
 * Model SubsidyClaim
 * 
 */
export type SubsidyClaim = $Result.DefaultSelection<Prisma.$SubsidyClaimPayload>
/**
 * Model HousekeepingArea
 * 
 */
export type HousekeepingArea = $Result.DefaultSelection<Prisma.$HousekeepingAreaPayload>
/**
 * Model HousekeepingStaff
 * 
 */
export type HousekeepingStaff = $Result.DefaultSelection<Prisma.$HousekeepingStaffPayload>
/**
 * Model CleaningTask
 * 
 */
export type CleaningTask = $Result.DefaultSelection<Prisma.$CleaningTaskPayload>
/**
 * Model CleaningVerification
 * 
 */
export type CleaningVerification = $Result.DefaultSelection<Prisma.$CleaningVerificationPayload>
/**
 * Model CleaningSupply
 * 
 */
export type CleaningSupply = $Result.DefaultSelection<Prisma.$CleaningSupplyPayload>
/**
 * Model CleaningSupplyRequest
 * 
 */
export type CleaningSupplyRequest = $Result.DefaultSelection<Prisma.$CleaningSupplyRequestPayload>
/**
 * Model CleaningSupplyRequestItem
 * 
 */
export type CleaningSupplyRequestItem = $Result.DefaultSelection<Prisma.$CleaningSupplyRequestItemPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Permissions
 * const permissions = await prisma.permission.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permission.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nurse`: Exposes CRUD operations for the **Nurse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nurses
    * const nurses = await prisma.nurse.findMany()
    * ```
    */
  get nurse(): Prisma.NurseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionMedicine`: Exposes CRUD operations for the **PrescriptionMedicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionMedicines
    * const prescriptionMedicines = await prisma.prescriptionMedicine.findMany()
    * ```
    */
  get prescriptionMedicine(): Prisma.PrescriptionMedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicine`: Exposes CRUD operations for the **Medicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicines
    * const medicines = await prisma.medicine.findMany()
    * ```
    */
  get medicine(): Prisma.MedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryLog`: Exposes CRUD operations for the **InventoryLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryLogs
    * const inventoryLogs = await prisma.inventoryLog.findMany()
    * ```
    */
  get inventoryLog(): Prisma.InventoryLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labReport`: Exposes CRUD operations for the **LabReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabReports
    * const labReports = await prisma.labReport.findMany()
    * ```
    */
  get labReport(): Prisma.LabReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.radiologyReport`: Exposes CRUD operations for the **RadiologyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RadiologyReports
    * const radiologyReports = await prisma.radiologyReport.findMany()
    * ```
    */
  get radiologyReport(): Prisma.RadiologyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bed`: Exposes CRUD operations for the **Bed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beds
    * const beds = await prisma.bed.findMany()
    * ```
    */
  get bed(): Prisma.BedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ward`: Exposes CRUD operations for the **Ward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wards
    * const wards = await prisma.ward.findMany()
    * ```
    */
  get ward(): Prisma.WardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bedAllocation`: Exposes CRUD operations for the **BedAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BedAllocations
    * const bedAllocations = await prisma.bedAllocation.findMany()
    * ```
    */
  get bedAllocation(): Prisma.BedAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitalSign`: Exposes CRUD operations for the **VitalSign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitalSigns
    * const vitalSigns = await prisma.vitalSign.findMany()
    * ```
    */
  get vitalSign(): Prisma.VitalSignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operationTheater`: Exposes CRUD operations for the **OperationTheater** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationTheaters
    * const operationTheaters = await prisma.operationTheater.findMany()
    * ```
    */
  get operationTheater(): Prisma.OperationTheaterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surgery`: Exposes CRUD operations for the **Surgery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surgeries
    * const surgeries = await prisma.surgery.findMany()
    * ```
    */
  get surgery(): Prisma.SurgeryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operationTheaterEquipment`: Exposes CRUD operations for the **OperationTheaterEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationTheaterEquipments
    * const operationTheaterEquipments = await prisma.operationTheaterEquipment.findMany()
    * ```
    */
  get operationTheaterEquipment(): Prisma.OperationTheaterEquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalGasCylinder`: Exposes CRUD operations for the **MedicalGasCylinder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalGasCylinders
    * const medicalGasCylinders = await prisma.medicalGasCylinder.findMany()
    * ```
    */
  get medicalGasCylinder(): Prisma.MedicalGasCylinderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentMaintenance`: Exposes CRUD operations for the **EquipmentMaintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentMaintenances
    * const equipmentMaintenances = await prisma.equipmentMaintenance.findMany()
    * ```
    */
  get equipmentMaintenance(): Prisma.EquipmentMaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ambulance`: Exposes CRUD operations for the **Ambulance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ambulances
    * const ambulances = await prisma.ambulance.findMany()
    * ```
    */
  get ambulance(): Prisma.AmbulanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ambulanceService`: Exposes CRUD operations for the **AmbulanceService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmbulanceServices
    * const ambulanceServices = await prisma.ambulanceService.findMany()
    * ```
    */
  get ambulanceService(): Prisma.AmbulanceServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.biometricData`: Exposes CRUD operations for the **BiometricData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiometricData
    * const biometricData = await prisma.biometricData.findMany()
    * ```
    */
  get biometricData(): Prisma.BiometricDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceLog`: Exposes CRUD operations for the **AttendanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceLogs
    * const attendanceLogs = await prisma.attendanceLog.findMany()
    * ```
    */
  get attendanceLog(): Prisma.AttendanceLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dutyRoster`: Exposes CRUD operations for the **DutyRoster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DutyRosters
    * const dutyRosters = await prisma.dutyRoster.findMany()
    * ```
    */
  get dutyRoster(): Prisma.DutyRosterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tPA`: Exposes CRUD operations for the **TPA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TPAS
    * const tPAS = await prisma.tPA.findMany()
    * ```
    */
  get tPA(): Prisma.TPADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryPayment`: Exposes CRUD operations for the **SalaryPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPayments
    * const salaryPayments = await prisma.salaryPayment.findMany()
    * ```
    */
  get salaryPayment(): Prisma.SalaryPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeDocument`: Exposes CRUD operations for the **EmployeeDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeDocuments
    * const employeeDocuments = await prisma.employeeDocument.findMany()
    * ```
    */
  get employeeDocument(): Prisma.EmployeeDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceReview`: Exposes CRUD operations for the **PerformanceReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceReviews
    * const performanceReviews = await prisma.performanceReview.findMany()
    * ```
    */
  get performanceReview(): Prisma.PerformanceReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subsidyScheme`: Exposes CRUD operations for the **SubsidyScheme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubsidySchemes
    * const subsidySchemes = await prisma.subsidyScheme.findMany()
    * ```
    */
  get subsidyScheme(): Prisma.SubsidySchemeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientSubsidy`: Exposes CRUD operations for the **PatientSubsidy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientSubsidies
    * const patientSubsidies = await prisma.patientSubsidy.findMany()
    * ```
    */
  get patientSubsidy(): Prisma.PatientSubsidyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subsidyClaim`: Exposes CRUD operations for the **SubsidyClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubsidyClaims
    * const subsidyClaims = await prisma.subsidyClaim.findMany()
    * ```
    */
  get subsidyClaim(): Prisma.SubsidyClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.housekeepingArea`: Exposes CRUD operations for the **HousekeepingArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HousekeepingAreas
    * const housekeepingAreas = await prisma.housekeepingArea.findMany()
    * ```
    */
  get housekeepingArea(): Prisma.HousekeepingAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.housekeepingStaff`: Exposes CRUD operations for the **HousekeepingStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HousekeepingStaffs
    * const housekeepingStaffs = await prisma.housekeepingStaff.findMany()
    * ```
    */
  get housekeepingStaff(): Prisma.HousekeepingStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningTask`: Exposes CRUD operations for the **CleaningTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningTasks
    * const cleaningTasks = await prisma.cleaningTask.findMany()
    * ```
    */
  get cleaningTask(): Prisma.CleaningTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningVerification`: Exposes CRUD operations for the **CleaningVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningVerifications
    * const cleaningVerifications = await prisma.cleaningVerification.findMany()
    * ```
    */
  get cleaningVerification(): Prisma.CleaningVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningSupply`: Exposes CRUD operations for the **CleaningSupply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningSupplies
    * const cleaningSupplies = await prisma.cleaningSupply.findMany()
    * ```
    */
  get cleaningSupply(): Prisma.CleaningSupplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningSupplyRequest`: Exposes CRUD operations for the **CleaningSupplyRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningSupplyRequests
    * const cleaningSupplyRequests = await prisma.cleaningSupplyRequest.findMany()
    * ```
    */
  get cleaningSupplyRequest(): Prisma.CleaningSupplyRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningSupplyRequestItem`: Exposes CRUD operations for the **CleaningSupplyRequestItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningSupplyRequestItems
    * const cleaningSupplyRequestItems = await prisma.cleaningSupplyRequestItem.findMany()
    * ```
    */
  get cleaningSupplyRequestItem(): Prisma.CleaningSupplyRequestItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Permission: 'Permission',
    Role: 'Role',
    RolePermission: 'RolePermission',
    User: 'User',
    PasswordReset: 'PasswordReset',
    Doctor: 'Doctor',
    Patient: 'Patient',
    Nurse: 'Nurse',
    Appointment: 'Appointment',
    Prescription: 'Prescription',
    PrescriptionMedicine: 'PrescriptionMedicine',
    Medicine: 'Medicine',
    InventoryLog: 'InventoryLog',
    LabReport: 'LabReport',
    RadiologyReport: 'RadiologyReport',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    Bed: 'Bed',
    Ward: 'Ward',
    BedAllocation: 'BedAllocation',
    VitalSign: 'VitalSign',
    OperationTheater: 'OperationTheater',
    Surgery: 'Surgery',
    OperationTheaterEquipment: 'OperationTheaterEquipment',
    MedicalGasCylinder: 'MedicalGasCylinder',
    EquipmentMaintenance: 'EquipmentMaintenance',
    Ambulance: 'Ambulance',
    AmbulanceService: 'AmbulanceService',
    BiometricData: 'BiometricData',
    AttendanceLog: 'AttendanceLog',
    DutyRoster: 'DutyRoster',
    TPA: 'TPA',
    Employee: 'Employee',
    Leave: 'Leave',
    SalaryPayment: 'SalaryPayment',
    EmployeeDocument: 'EmployeeDocument',
    PerformanceReview: 'PerformanceReview',
    SubsidyScheme: 'SubsidyScheme',
    PatientSubsidy: 'PatientSubsidy',
    SubsidyClaim: 'SubsidyClaim',
    HousekeepingArea: 'HousekeepingArea',
    HousekeepingStaff: 'HousekeepingStaff',
    CleaningTask: 'CleaningTask',
    CleaningVerification: 'CleaningVerification',
    CleaningSupply: 'CleaningSupply',
    CleaningSupplyRequest: 'CleaningSupplyRequest',
    CleaningSupplyRequestItem: 'CleaningSupplyRequestItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "permission" | "role" | "rolePermission" | "user" | "passwordReset" | "doctor" | "patient" | "nurse" | "appointment" | "prescription" | "prescriptionMedicine" | "medicine" | "inventoryLog" | "labReport" | "radiologyReport" | "invoice" | "invoiceItem" | "payment" | "bed" | "ward" | "bedAllocation" | "vitalSign" | "operationTheater" | "surgery" | "operationTheaterEquipment" | "medicalGasCylinder" | "equipmentMaintenance" | "ambulance" | "ambulanceService" | "biometricData" | "attendanceLog" | "dutyRoster" | "tPA" | "employee" | "leave" | "salaryPayment" | "employeeDocument" | "performanceReview" | "subsidyScheme" | "patientSubsidy" | "subsidyClaim" | "housekeepingArea" | "housekeepingStaff" | "cleaningTask" | "cleaningVerification" | "cleaningSupply" | "cleaningSupplyRequest" | "cleaningSupplyRequestItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Nurse: {
        payload: Prisma.$NursePayload<ExtArgs>
        fields: Prisma.NurseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NurseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NurseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>
          }
          findFirst: {
            args: Prisma.NurseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NurseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>
          }
          findMany: {
            args: Prisma.NurseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>[]
          }
          create: {
            args: Prisma.NurseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>
          }
          createMany: {
            args: Prisma.NurseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NurseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>[]
          }
          delete: {
            args: Prisma.NurseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>
          }
          update: {
            args: Prisma.NurseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>
          }
          deleteMany: {
            args: Prisma.NurseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NurseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NurseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>[]
          }
          upsert: {
            args: Prisma.NurseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursePayload>
          }
          aggregate: {
            args: Prisma.NurseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurse>
          }
          groupBy: {
            args: Prisma.NurseGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseGroupByOutputType>[]
          }
          count: {
            args: Prisma.NurseCountArgs<ExtArgs>
            result: $Utils.Optional<NurseCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionMedicine: {
        payload: Prisma.$PrescriptionMedicinePayload<ExtArgs>
        fields: Prisma.PrescriptionMedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionMedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionMedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          findFirst: {
            args: Prisma.PrescriptionMedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionMedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          findMany: {
            args: Prisma.PrescriptionMedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>[]
          }
          create: {
            args: Prisma.PrescriptionMedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          createMany: {
            args: Prisma.PrescriptionMedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionMedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>[]
          }
          delete: {
            args: Prisma.PrescriptionMedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          update: {
            args: Prisma.PrescriptionMedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionMedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionMedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionMedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionMedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          aggregate: {
            args: Prisma.PrescriptionMedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionMedicine>
          }
          groupBy: {
            args: Prisma.PrescriptionMedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionMedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionMedicineCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionMedicineCountAggregateOutputType> | number
          }
        }
      }
      Medicine: {
        payload: Prisma.$MedicinePayload<ExtArgs>
        fields: Prisma.MedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findFirst: {
            args: Prisma.MedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findMany: {
            args: Prisma.MedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          create: {
            args: Prisma.MedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          createMany: {
            args: Prisma.MedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          delete: {
            args: Prisma.MedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          update: {
            args: Prisma.MedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          deleteMany: {
            args: Prisma.MedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          upsert: {
            args: Prisma.MedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          aggregate: {
            args: Prisma.MedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicine>
          }
          groupBy: {
            args: Prisma.MedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineCountAggregateOutputType> | number
          }
        }
      }
      InventoryLog: {
        payload: Prisma.$InventoryLogPayload<ExtArgs>
        fields: Prisma.InventoryLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>
          }
          findFirst: {
            args: Prisma.InventoryLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>
          }
          findMany: {
            args: Prisma.InventoryLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>[]
          }
          create: {
            args: Prisma.InventoryLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>
          }
          createMany: {
            args: Prisma.InventoryLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>[]
          }
          delete: {
            args: Prisma.InventoryLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>
          }
          update: {
            args: Prisma.InventoryLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>
          }
          deleteMany: {
            args: Prisma.InventoryLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>[]
          }
          upsert: {
            args: Prisma.InventoryLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLogPayload>
          }
          aggregate: {
            args: Prisma.InventoryLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryLog>
          }
          groupBy: {
            args: Prisma.InventoryLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryLogCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryLogCountAggregateOutputType> | number
          }
        }
      }
      LabReport: {
        payload: Prisma.$LabReportPayload<ExtArgs>
        fields: Prisma.LabReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          findFirst: {
            args: Prisma.LabReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          findMany: {
            args: Prisma.LabReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>[]
          }
          create: {
            args: Prisma.LabReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          createMany: {
            args: Prisma.LabReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>[]
          }
          delete: {
            args: Prisma.LabReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          update: {
            args: Prisma.LabReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          deleteMany: {
            args: Prisma.LabReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>[]
          }
          upsert: {
            args: Prisma.LabReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          aggregate: {
            args: Prisma.LabReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabReport>
          }
          groupBy: {
            args: Prisma.LabReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabReportCountArgs<ExtArgs>
            result: $Utils.Optional<LabReportCountAggregateOutputType> | number
          }
        }
      }
      RadiologyReport: {
        payload: Prisma.$RadiologyReportPayload<ExtArgs>
        fields: Prisma.RadiologyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RadiologyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RadiologyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>
          }
          findFirst: {
            args: Prisma.RadiologyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RadiologyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>
          }
          findMany: {
            args: Prisma.RadiologyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>[]
          }
          create: {
            args: Prisma.RadiologyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>
          }
          createMany: {
            args: Prisma.RadiologyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RadiologyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>[]
          }
          delete: {
            args: Prisma.RadiologyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>
          }
          update: {
            args: Prisma.RadiologyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>
          }
          deleteMany: {
            args: Prisma.RadiologyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RadiologyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RadiologyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>[]
          }
          upsert: {
            args: Prisma.RadiologyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyReportPayload>
          }
          aggregate: {
            args: Prisma.RadiologyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRadiologyReport>
          }
          groupBy: {
            args: Prisma.RadiologyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RadiologyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.RadiologyReportCountArgs<ExtArgs>
            result: $Utils.Optional<RadiologyReportCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Bed: {
        payload: Prisma.$BedPayload<ExtArgs>
        fields: Prisma.BedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findFirst: {
            args: Prisma.BedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findMany: {
            args: Prisma.BedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          create: {
            args: Prisma.BedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          createMany: {
            args: Prisma.BedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          delete: {
            args: Prisma.BedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          update: {
            args: Prisma.BedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          deleteMany: {
            args: Prisma.BedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          upsert: {
            args: Prisma.BedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          aggregate: {
            args: Prisma.BedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBed>
          }
          groupBy: {
            args: Prisma.BedGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedCountArgs<ExtArgs>
            result: $Utils.Optional<BedCountAggregateOutputType> | number
          }
        }
      }
      Ward: {
        payload: Prisma.$WardPayload<ExtArgs>
        fields: Prisma.WardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findFirst: {
            args: Prisma.WardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findMany: {
            args: Prisma.WardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          create: {
            args: Prisma.WardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          createMany: {
            args: Prisma.WardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          delete: {
            args: Prisma.WardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          update: {
            args: Prisma.WardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          deleteMany: {
            args: Prisma.WardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          upsert: {
            args: Prisma.WardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          aggregate: {
            args: Prisma.WardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWard>
          }
          groupBy: {
            args: Prisma.WardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardCountArgs<ExtArgs>
            result: $Utils.Optional<WardCountAggregateOutputType> | number
          }
        }
      }
      BedAllocation: {
        payload: Prisma.$BedAllocationPayload<ExtArgs>
        fields: Prisma.BedAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>
          }
          findFirst: {
            args: Prisma.BedAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>
          }
          findMany: {
            args: Prisma.BedAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>[]
          }
          create: {
            args: Prisma.BedAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>
          }
          createMany: {
            args: Prisma.BedAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>[]
          }
          delete: {
            args: Prisma.BedAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>
          }
          update: {
            args: Prisma.BedAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>
          }
          deleteMany: {
            args: Prisma.BedAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>[]
          }
          upsert: {
            args: Prisma.BedAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedAllocationPayload>
          }
          aggregate: {
            args: Prisma.BedAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBedAllocation>
          }
          groupBy: {
            args: Prisma.BedAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<BedAllocationCountAggregateOutputType> | number
          }
        }
      }
      VitalSign: {
        payload: Prisma.$VitalSignPayload<ExtArgs>
        fields: Prisma.VitalSignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalSignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalSignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          findFirst: {
            args: Prisma.VitalSignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalSignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          findMany: {
            args: Prisma.VitalSignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          create: {
            args: Prisma.VitalSignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          createMany: {
            args: Prisma.VitalSignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VitalSignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          delete: {
            args: Prisma.VitalSignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          update: {
            args: Prisma.VitalSignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          deleteMany: {
            args: Prisma.VitalSignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalSignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VitalSignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          upsert: {
            args: Prisma.VitalSignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          aggregate: {
            args: Prisma.VitalSignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitalSign>
          }
          groupBy: {
            args: Prisma.VitalSignGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalSignGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalSignCountArgs<ExtArgs>
            result: $Utils.Optional<VitalSignCountAggregateOutputType> | number
          }
        }
      }
      OperationTheater: {
        payload: Prisma.$OperationTheaterPayload<ExtArgs>
        fields: Prisma.OperationTheaterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationTheaterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationTheaterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>
          }
          findFirst: {
            args: Prisma.OperationTheaterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationTheaterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>
          }
          findMany: {
            args: Prisma.OperationTheaterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>[]
          }
          create: {
            args: Prisma.OperationTheaterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>
          }
          createMany: {
            args: Prisma.OperationTheaterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationTheaterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>[]
          }
          delete: {
            args: Prisma.OperationTheaterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>
          }
          update: {
            args: Prisma.OperationTheaterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>
          }
          deleteMany: {
            args: Prisma.OperationTheaterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationTheaterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperationTheaterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>[]
          }
          upsert: {
            args: Prisma.OperationTheaterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterPayload>
          }
          aggregate: {
            args: Prisma.OperationTheaterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationTheater>
          }
          groupBy: {
            args: Prisma.OperationTheaterGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationTheaterGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationTheaterCountArgs<ExtArgs>
            result: $Utils.Optional<OperationTheaterCountAggregateOutputType> | number
          }
        }
      }
      Surgery: {
        payload: Prisma.$SurgeryPayload<ExtArgs>
        fields: Prisma.SurgeryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurgeryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurgeryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          findFirst: {
            args: Prisma.SurgeryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurgeryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          findMany: {
            args: Prisma.SurgeryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>[]
          }
          create: {
            args: Prisma.SurgeryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          createMany: {
            args: Prisma.SurgeryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurgeryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>[]
          }
          delete: {
            args: Prisma.SurgeryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          update: {
            args: Prisma.SurgeryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          deleteMany: {
            args: Prisma.SurgeryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurgeryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurgeryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>[]
          }
          upsert: {
            args: Prisma.SurgeryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          aggregate: {
            args: Prisma.SurgeryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurgery>
          }
          groupBy: {
            args: Prisma.SurgeryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurgeryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurgeryCountArgs<ExtArgs>
            result: $Utils.Optional<SurgeryCountAggregateOutputType> | number
          }
        }
      }
      OperationTheaterEquipment: {
        payload: Prisma.$OperationTheaterEquipmentPayload<ExtArgs>
        fields: Prisma.OperationTheaterEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationTheaterEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationTheaterEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>
          }
          findFirst: {
            args: Prisma.OperationTheaterEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationTheaterEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>
          }
          findMany: {
            args: Prisma.OperationTheaterEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>[]
          }
          create: {
            args: Prisma.OperationTheaterEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>
          }
          createMany: {
            args: Prisma.OperationTheaterEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationTheaterEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>[]
          }
          delete: {
            args: Prisma.OperationTheaterEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>
          }
          update: {
            args: Prisma.OperationTheaterEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.OperationTheaterEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationTheaterEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperationTheaterEquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>[]
          }
          upsert: {
            args: Prisma.OperationTheaterEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationTheaterEquipmentPayload>
          }
          aggregate: {
            args: Prisma.OperationTheaterEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationTheaterEquipment>
          }
          groupBy: {
            args: Prisma.OperationTheaterEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationTheaterEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationTheaterEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<OperationTheaterEquipmentCountAggregateOutputType> | number
          }
        }
      }
      MedicalGasCylinder: {
        payload: Prisma.$MedicalGasCylinderPayload<ExtArgs>
        fields: Prisma.MedicalGasCylinderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalGasCylinderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalGasCylinderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>
          }
          findFirst: {
            args: Prisma.MedicalGasCylinderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalGasCylinderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>
          }
          findMany: {
            args: Prisma.MedicalGasCylinderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>[]
          }
          create: {
            args: Prisma.MedicalGasCylinderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>
          }
          createMany: {
            args: Prisma.MedicalGasCylinderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalGasCylinderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>[]
          }
          delete: {
            args: Prisma.MedicalGasCylinderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>
          }
          update: {
            args: Prisma.MedicalGasCylinderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>
          }
          deleteMany: {
            args: Prisma.MedicalGasCylinderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalGasCylinderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalGasCylinderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>[]
          }
          upsert: {
            args: Prisma.MedicalGasCylinderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalGasCylinderPayload>
          }
          aggregate: {
            args: Prisma.MedicalGasCylinderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalGasCylinder>
          }
          groupBy: {
            args: Prisma.MedicalGasCylinderGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalGasCylinderGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalGasCylinderCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalGasCylinderCountAggregateOutputType> | number
          }
        }
      }
      EquipmentMaintenance: {
        payload: Prisma.$EquipmentMaintenancePayload<ExtArgs>
        fields: Prisma.EquipmentMaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentMaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentMaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>
          }
          findFirst: {
            args: Prisma.EquipmentMaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentMaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>
          }
          findMany: {
            args: Prisma.EquipmentMaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>[]
          }
          create: {
            args: Prisma.EquipmentMaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>
          }
          createMany: {
            args: Prisma.EquipmentMaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentMaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>[]
          }
          delete: {
            args: Prisma.EquipmentMaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>
          }
          update: {
            args: Prisma.EquipmentMaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>
          }
          deleteMany: {
            args: Prisma.EquipmentMaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentMaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentMaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>[]
          }
          upsert: {
            args: Prisma.EquipmentMaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentMaintenancePayload>
          }
          aggregate: {
            args: Prisma.EquipmentMaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentMaintenance>
          }
          groupBy: {
            args: Prisma.EquipmentMaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentMaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentMaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentMaintenanceCountAggregateOutputType> | number
          }
        }
      }
      Ambulance: {
        payload: Prisma.$AmbulancePayload<ExtArgs>
        fields: Prisma.AmbulanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmbulanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmbulanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>
          }
          findFirst: {
            args: Prisma.AmbulanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmbulanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>
          }
          findMany: {
            args: Prisma.AmbulanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>[]
          }
          create: {
            args: Prisma.AmbulanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>
          }
          createMany: {
            args: Prisma.AmbulanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmbulanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>[]
          }
          delete: {
            args: Prisma.AmbulanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>
          }
          update: {
            args: Prisma.AmbulanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>
          }
          deleteMany: {
            args: Prisma.AmbulanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmbulanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmbulanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>[]
          }
          upsert: {
            args: Prisma.AmbulanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulancePayload>
          }
          aggregate: {
            args: Prisma.AmbulanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmbulance>
          }
          groupBy: {
            args: Prisma.AmbulanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmbulanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmbulanceCountArgs<ExtArgs>
            result: $Utils.Optional<AmbulanceCountAggregateOutputType> | number
          }
        }
      }
      AmbulanceService: {
        payload: Prisma.$AmbulanceServicePayload<ExtArgs>
        fields: Prisma.AmbulanceServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmbulanceServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmbulanceServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          findFirst: {
            args: Prisma.AmbulanceServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmbulanceServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          findMany: {
            args: Prisma.AmbulanceServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>[]
          }
          create: {
            args: Prisma.AmbulanceServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          createMany: {
            args: Prisma.AmbulanceServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmbulanceServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>[]
          }
          delete: {
            args: Prisma.AmbulanceServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          update: {
            args: Prisma.AmbulanceServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          deleteMany: {
            args: Prisma.AmbulanceServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmbulanceServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmbulanceServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>[]
          }
          upsert: {
            args: Prisma.AmbulanceServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          aggregate: {
            args: Prisma.AmbulanceServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmbulanceService>
          }
          groupBy: {
            args: Prisma.AmbulanceServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmbulanceServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmbulanceServiceCountArgs<ExtArgs>
            result: $Utils.Optional<AmbulanceServiceCountAggregateOutputType> | number
          }
        }
      }
      BiometricData: {
        payload: Prisma.$BiometricDataPayload<ExtArgs>
        fields: Prisma.BiometricDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiometricDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiometricDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          findFirst: {
            args: Prisma.BiometricDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiometricDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          findMany: {
            args: Prisma.BiometricDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          create: {
            args: Prisma.BiometricDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          createMany: {
            args: Prisma.BiometricDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiometricDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          delete: {
            args: Prisma.BiometricDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          update: {
            args: Prisma.BiometricDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          deleteMany: {
            args: Prisma.BiometricDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiometricDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BiometricDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          upsert: {
            args: Prisma.BiometricDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          aggregate: {
            args: Prisma.BiometricDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiometricData>
          }
          groupBy: {
            args: Prisma.BiometricDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiometricDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiometricDataCountArgs<ExtArgs>
            result: $Utils.Optional<BiometricDataCountAggregateOutputType> | number
          }
        }
      }
      AttendanceLog: {
        payload: Prisma.$AttendanceLogPayload<ExtArgs>
        fields: Prisma.AttendanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findFirst: {
            args: Prisma.AttendanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findMany: {
            args: Prisma.AttendanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          create: {
            args: Prisma.AttendanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          createMany: {
            args: Prisma.AttendanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          delete: {
            args: Prisma.AttendanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          update: {
            args: Prisma.AttendanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          aggregate: {
            args: Prisma.AttendanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceLog>
          }
          groupBy: {
            args: Prisma.AttendanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogCountAggregateOutputType> | number
          }
        }
      }
      DutyRoster: {
        payload: Prisma.$DutyRosterPayload<ExtArgs>
        fields: Prisma.DutyRosterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DutyRosterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DutyRosterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>
          }
          findFirst: {
            args: Prisma.DutyRosterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DutyRosterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>
          }
          findMany: {
            args: Prisma.DutyRosterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>[]
          }
          create: {
            args: Prisma.DutyRosterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>
          }
          createMany: {
            args: Prisma.DutyRosterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DutyRosterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>[]
          }
          delete: {
            args: Prisma.DutyRosterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>
          }
          update: {
            args: Prisma.DutyRosterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>
          }
          deleteMany: {
            args: Prisma.DutyRosterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DutyRosterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DutyRosterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>[]
          }
          upsert: {
            args: Prisma.DutyRosterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyRosterPayload>
          }
          aggregate: {
            args: Prisma.DutyRosterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDutyRoster>
          }
          groupBy: {
            args: Prisma.DutyRosterGroupByArgs<ExtArgs>
            result: $Utils.Optional<DutyRosterGroupByOutputType>[]
          }
          count: {
            args: Prisma.DutyRosterCountArgs<ExtArgs>
            result: $Utils.Optional<DutyRosterCountAggregateOutputType> | number
          }
        }
      }
      TPA: {
        payload: Prisma.$TPAPayload<ExtArgs>
        fields: Prisma.TPAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TPAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TPAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>
          }
          findFirst: {
            args: Prisma.TPAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TPAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>
          }
          findMany: {
            args: Prisma.TPAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>[]
          }
          create: {
            args: Prisma.TPACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>
          }
          createMany: {
            args: Prisma.TPACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TPACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>[]
          }
          delete: {
            args: Prisma.TPADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>
          }
          update: {
            args: Prisma.TPAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>
          }
          deleteMany: {
            args: Prisma.TPADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TPAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TPAUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>[]
          }
          upsert: {
            args: Prisma.TPAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TPAPayload>
          }
          aggregate: {
            args: Prisma.TPAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTPA>
          }
          groupBy: {
            args: Prisma.TPAGroupByArgs<ExtArgs>
            result: $Utils.Optional<TPAGroupByOutputType>[]
          }
          count: {
            args: Prisma.TPACountArgs<ExtArgs>
            result: $Utils.Optional<TPACountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      SalaryPayment: {
        payload: Prisma.$SalaryPaymentPayload<ExtArgs>
        fields: Prisma.SalaryPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findFirst: {
            args: Prisma.SalaryPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findMany: {
            args: Prisma.SalaryPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          create: {
            args: Prisma.SalaryPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          createMany: {
            args: Prisma.SalaryPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          delete: {
            args: Prisma.SalaryPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          update: {
            args: Prisma.SalaryPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          upsert: {
            args: Prisma.SalaryPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          aggregate: {
            args: Prisma.SalaryPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPayment>
          }
          groupBy: {
            args: Prisma.SalaryPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentCountAggregateOutputType> | number
          }
        }
      }
      EmployeeDocument: {
        payload: Prisma.$EmployeeDocumentPayload<ExtArgs>
        fields: Prisma.EmployeeDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          findFirst: {
            args: Prisma.EmployeeDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          findMany: {
            args: Prisma.EmployeeDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>[]
          }
          create: {
            args: Prisma.EmployeeDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          createMany: {
            args: Prisma.EmployeeDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>[]
          }
          delete: {
            args: Prisma.EmployeeDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          update: {
            args: Prisma.EmployeeDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeDocument>
          }
          groupBy: {
            args: Prisma.EmployeeDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeDocumentCountAggregateOutputType> | number
          }
        }
      }
      PerformanceReview: {
        payload: Prisma.$PerformanceReviewPayload<ExtArgs>
        fields: Prisma.PerformanceReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findFirst: {
            args: Prisma.PerformanceReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findMany: {
            args: Prisma.PerformanceReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          create: {
            args: Prisma.PerformanceReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          createMany: {
            args: Prisma.PerformanceReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          delete: {
            args: Prisma.PerformanceReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          update: {
            args: Prisma.PerformanceReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          aggregate: {
            args: Prisma.PerformanceReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceReview>
          }
          groupBy: {
            args: Prisma.PerformanceReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceReviewCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewCountAggregateOutputType> | number
          }
        }
      }
      SubsidyScheme: {
        payload: Prisma.$SubsidySchemePayload<ExtArgs>
        fields: Prisma.SubsidySchemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubsidySchemeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubsidySchemeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>
          }
          findFirst: {
            args: Prisma.SubsidySchemeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubsidySchemeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>
          }
          findMany: {
            args: Prisma.SubsidySchemeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>[]
          }
          create: {
            args: Prisma.SubsidySchemeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>
          }
          createMany: {
            args: Prisma.SubsidySchemeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubsidySchemeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>[]
          }
          delete: {
            args: Prisma.SubsidySchemeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>
          }
          update: {
            args: Prisma.SubsidySchemeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>
          }
          deleteMany: {
            args: Prisma.SubsidySchemeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubsidySchemeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubsidySchemeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>[]
          }
          upsert: {
            args: Prisma.SubsidySchemeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidySchemePayload>
          }
          aggregate: {
            args: Prisma.SubsidySchemeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubsidyScheme>
          }
          groupBy: {
            args: Prisma.SubsidySchemeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubsidySchemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubsidySchemeCountArgs<ExtArgs>
            result: $Utils.Optional<SubsidySchemeCountAggregateOutputType> | number
          }
        }
      }
      PatientSubsidy: {
        payload: Prisma.$PatientSubsidyPayload<ExtArgs>
        fields: Prisma.PatientSubsidyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientSubsidyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientSubsidyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>
          }
          findFirst: {
            args: Prisma.PatientSubsidyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientSubsidyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>
          }
          findMany: {
            args: Prisma.PatientSubsidyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>[]
          }
          create: {
            args: Prisma.PatientSubsidyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>
          }
          createMany: {
            args: Prisma.PatientSubsidyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientSubsidyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>[]
          }
          delete: {
            args: Prisma.PatientSubsidyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>
          }
          update: {
            args: Prisma.PatientSubsidyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>
          }
          deleteMany: {
            args: Prisma.PatientSubsidyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientSubsidyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientSubsidyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>[]
          }
          upsert: {
            args: Prisma.PatientSubsidyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSubsidyPayload>
          }
          aggregate: {
            args: Prisma.PatientSubsidyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientSubsidy>
          }
          groupBy: {
            args: Prisma.PatientSubsidyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientSubsidyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientSubsidyCountArgs<ExtArgs>
            result: $Utils.Optional<PatientSubsidyCountAggregateOutputType> | number
          }
        }
      }
      SubsidyClaim: {
        payload: Prisma.$SubsidyClaimPayload<ExtArgs>
        fields: Prisma.SubsidyClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubsidyClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubsidyClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>
          }
          findFirst: {
            args: Prisma.SubsidyClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubsidyClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>
          }
          findMany: {
            args: Prisma.SubsidyClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>[]
          }
          create: {
            args: Prisma.SubsidyClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>
          }
          createMany: {
            args: Prisma.SubsidyClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubsidyClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>[]
          }
          delete: {
            args: Prisma.SubsidyClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>
          }
          update: {
            args: Prisma.SubsidyClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>
          }
          deleteMany: {
            args: Prisma.SubsidyClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubsidyClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubsidyClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>[]
          }
          upsert: {
            args: Prisma.SubsidyClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubsidyClaimPayload>
          }
          aggregate: {
            args: Prisma.SubsidyClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubsidyClaim>
          }
          groupBy: {
            args: Prisma.SubsidyClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubsidyClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubsidyClaimCountArgs<ExtArgs>
            result: $Utils.Optional<SubsidyClaimCountAggregateOutputType> | number
          }
        }
      }
      HousekeepingArea: {
        payload: Prisma.$HousekeepingAreaPayload<ExtArgs>
        fields: Prisma.HousekeepingAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HousekeepingAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HousekeepingAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>
          }
          findFirst: {
            args: Prisma.HousekeepingAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HousekeepingAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>
          }
          findMany: {
            args: Prisma.HousekeepingAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>[]
          }
          create: {
            args: Prisma.HousekeepingAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>
          }
          createMany: {
            args: Prisma.HousekeepingAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HousekeepingAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>[]
          }
          delete: {
            args: Prisma.HousekeepingAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>
          }
          update: {
            args: Prisma.HousekeepingAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>
          }
          deleteMany: {
            args: Prisma.HousekeepingAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HousekeepingAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HousekeepingAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>[]
          }
          upsert: {
            args: Prisma.HousekeepingAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingAreaPayload>
          }
          aggregate: {
            args: Prisma.HousekeepingAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHousekeepingArea>
          }
          groupBy: {
            args: Prisma.HousekeepingAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<HousekeepingAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.HousekeepingAreaCountArgs<ExtArgs>
            result: $Utils.Optional<HousekeepingAreaCountAggregateOutputType> | number
          }
        }
      }
      HousekeepingStaff: {
        payload: Prisma.$HousekeepingStaffPayload<ExtArgs>
        fields: Prisma.HousekeepingStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HousekeepingStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HousekeepingStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>
          }
          findFirst: {
            args: Prisma.HousekeepingStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HousekeepingStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>
          }
          findMany: {
            args: Prisma.HousekeepingStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>[]
          }
          create: {
            args: Prisma.HousekeepingStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>
          }
          createMany: {
            args: Prisma.HousekeepingStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HousekeepingStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>[]
          }
          delete: {
            args: Prisma.HousekeepingStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>
          }
          update: {
            args: Prisma.HousekeepingStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>
          }
          deleteMany: {
            args: Prisma.HousekeepingStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HousekeepingStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HousekeepingStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>[]
          }
          upsert: {
            args: Prisma.HousekeepingStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingStaffPayload>
          }
          aggregate: {
            args: Prisma.HousekeepingStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHousekeepingStaff>
          }
          groupBy: {
            args: Prisma.HousekeepingStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<HousekeepingStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.HousekeepingStaffCountArgs<ExtArgs>
            result: $Utils.Optional<HousekeepingStaffCountAggregateOutputType> | number
          }
        }
      }
      CleaningTask: {
        payload: Prisma.$CleaningTaskPayload<ExtArgs>
        fields: Prisma.CleaningTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>
          }
          findFirst: {
            args: Prisma.CleaningTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>
          }
          findMany: {
            args: Prisma.CleaningTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>[]
          }
          create: {
            args: Prisma.CleaningTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>
          }
          createMany: {
            args: Prisma.CleaningTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>[]
          }
          delete: {
            args: Prisma.CleaningTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>
          }
          update: {
            args: Prisma.CleaningTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>
          }
          deleteMany: {
            args: Prisma.CleaningTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>[]
          }
          upsert: {
            args: Prisma.CleaningTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningTaskPayload>
          }
          aggregate: {
            args: Prisma.CleaningTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningTask>
          }
          groupBy: {
            args: Prisma.CleaningTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningTaskCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningTaskCountAggregateOutputType> | number
          }
        }
      }
      CleaningVerification: {
        payload: Prisma.$CleaningVerificationPayload<ExtArgs>
        fields: Prisma.CleaningVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>
          }
          findFirst: {
            args: Prisma.CleaningVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>
          }
          findMany: {
            args: Prisma.CleaningVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>[]
          }
          create: {
            args: Prisma.CleaningVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>
          }
          createMany: {
            args: Prisma.CleaningVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>[]
          }
          delete: {
            args: Prisma.CleaningVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>
          }
          update: {
            args: Prisma.CleaningVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>
          }
          deleteMany: {
            args: Prisma.CleaningVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>[]
          }
          upsert: {
            args: Prisma.CleaningVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningVerificationPayload>
          }
          aggregate: {
            args: Prisma.CleaningVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningVerification>
          }
          groupBy: {
            args: Prisma.CleaningVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningVerificationCountAggregateOutputType> | number
          }
        }
      }
      CleaningSupply: {
        payload: Prisma.$CleaningSupplyPayload<ExtArgs>
        fields: Prisma.CleaningSupplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningSupplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningSupplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>
          }
          findFirst: {
            args: Prisma.CleaningSupplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningSupplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>
          }
          findMany: {
            args: Prisma.CleaningSupplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>[]
          }
          create: {
            args: Prisma.CleaningSupplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>
          }
          createMany: {
            args: Prisma.CleaningSupplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningSupplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>[]
          }
          delete: {
            args: Prisma.CleaningSupplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>
          }
          update: {
            args: Prisma.CleaningSupplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>
          }
          deleteMany: {
            args: Prisma.CleaningSupplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningSupplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningSupplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>[]
          }
          upsert: {
            args: Prisma.CleaningSupplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyPayload>
          }
          aggregate: {
            args: Prisma.CleaningSupplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningSupply>
          }
          groupBy: {
            args: Prisma.CleaningSupplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningSupplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningSupplyCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningSupplyCountAggregateOutputType> | number
          }
        }
      }
      CleaningSupplyRequest: {
        payload: Prisma.$CleaningSupplyRequestPayload<ExtArgs>
        fields: Prisma.CleaningSupplyRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningSupplyRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningSupplyRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>
          }
          findFirst: {
            args: Prisma.CleaningSupplyRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningSupplyRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>
          }
          findMany: {
            args: Prisma.CleaningSupplyRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>[]
          }
          create: {
            args: Prisma.CleaningSupplyRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>
          }
          createMany: {
            args: Prisma.CleaningSupplyRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningSupplyRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>[]
          }
          delete: {
            args: Prisma.CleaningSupplyRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>
          }
          update: {
            args: Prisma.CleaningSupplyRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>
          }
          deleteMany: {
            args: Prisma.CleaningSupplyRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningSupplyRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningSupplyRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>[]
          }
          upsert: {
            args: Prisma.CleaningSupplyRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestPayload>
          }
          aggregate: {
            args: Prisma.CleaningSupplyRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningSupplyRequest>
          }
          groupBy: {
            args: Prisma.CleaningSupplyRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningSupplyRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningSupplyRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningSupplyRequestCountAggregateOutputType> | number
          }
        }
      }
      CleaningSupplyRequestItem: {
        payload: Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>
        fields: Prisma.CleaningSupplyRequestItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningSupplyRequestItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningSupplyRequestItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>
          }
          findFirst: {
            args: Prisma.CleaningSupplyRequestItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningSupplyRequestItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>
          }
          findMany: {
            args: Prisma.CleaningSupplyRequestItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>[]
          }
          create: {
            args: Prisma.CleaningSupplyRequestItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>
          }
          createMany: {
            args: Prisma.CleaningSupplyRequestItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningSupplyRequestItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>[]
          }
          delete: {
            args: Prisma.CleaningSupplyRequestItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>
          }
          update: {
            args: Prisma.CleaningSupplyRequestItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>
          }
          deleteMany: {
            args: Prisma.CleaningSupplyRequestItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningSupplyRequestItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningSupplyRequestItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>[]
          }
          upsert: {
            args: Prisma.CleaningSupplyRequestItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSupplyRequestItemPayload>
          }
          aggregate: {
            args: Prisma.CleaningSupplyRequestItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningSupplyRequestItem>
          }
          groupBy: {
            args: Prisma.CleaningSupplyRequestItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningSupplyRequestItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningSupplyRequestItemCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningSupplyRequestItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    permission?: PermissionOmit
    role?: RoleOmit
    rolePermission?: RolePermissionOmit
    user?: UserOmit
    passwordReset?: PasswordResetOmit
    doctor?: DoctorOmit
    patient?: PatientOmit
    nurse?: NurseOmit
    appointment?: AppointmentOmit
    prescription?: PrescriptionOmit
    prescriptionMedicine?: PrescriptionMedicineOmit
    medicine?: MedicineOmit
    inventoryLog?: InventoryLogOmit
    labReport?: LabReportOmit
    radiologyReport?: RadiologyReportOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    payment?: PaymentOmit
    bed?: BedOmit
    ward?: WardOmit
    bedAllocation?: BedAllocationOmit
    vitalSign?: VitalSignOmit
    operationTheater?: OperationTheaterOmit
    surgery?: SurgeryOmit
    operationTheaterEquipment?: OperationTheaterEquipmentOmit
    medicalGasCylinder?: MedicalGasCylinderOmit
    equipmentMaintenance?: EquipmentMaintenanceOmit
    ambulance?: AmbulanceOmit
    ambulanceService?: AmbulanceServiceOmit
    biometricData?: BiometricDataOmit
    attendanceLog?: AttendanceLogOmit
    dutyRoster?: DutyRosterOmit
    tPA?: TPAOmit
    employee?: EmployeeOmit
    leave?: LeaveOmit
    salaryPayment?: SalaryPaymentOmit
    employeeDocument?: EmployeeDocumentOmit
    performanceReview?: PerformanceReviewOmit
    subsidyScheme?: SubsidySchemeOmit
    patientSubsidy?: PatientSubsidyOmit
    subsidyClaim?: SubsidyClaimOmit
    housekeepingArea?: HousekeepingAreaOmit
    housekeepingStaff?: HousekeepingStaffOmit
    cleaningTask?: CleaningTaskOmit
    cleaningVerification?: CleaningVerificationOmit
    cleaningSupply?: CleaningSupplyOmit
    cleaningSupplyRequest?: CleaningSupplyRequestOmit
    cleaningSupplyRequestItem?: CleaningSupplyRequestItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    rolePermissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    invoices: number
    payments: number
    attendanceLogs: number
    dutyRosters: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    attendanceLogs?: boolean | UserCountOutputTypeCountAttendanceLogsArgs
    dutyRosters?: boolean | UserCountOutputTypeCountDutyRostersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDutyRostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyRosterWhereInput
  }


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    appointments: number
    prescriptions: number
    labReports: number
    radiologyReports: number
    operationTheaters: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | DoctorCountOutputTypeCountAppointmentsArgs
    prescriptions?: boolean | DoctorCountOutputTypeCountPrescriptionsArgs
    labReports?: boolean | DoctorCountOutputTypeCountLabReportsArgs
    radiologyReports?: boolean | DoctorCountOutputTypeCountRadiologyReportsArgs
    operationTheaters?: boolean | DoctorCountOutputTypeCountOperationTheatersArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountLabReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabReportWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountRadiologyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyReportWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountOperationTheatersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationTheaterWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    prescriptions: number
    labReports: number
    radiologyReports: number
    invoices: number
    bedAllocations: number
    vitalSigns: number
    patientSubsidies: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    labReports?: boolean | PatientCountOutputTypeCountLabReportsArgs
    radiologyReports?: boolean | PatientCountOutputTypeCountRadiologyReportsArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    bedAllocations?: boolean | PatientCountOutputTypeCountBedAllocationsArgs
    vitalSigns?: boolean | PatientCountOutputTypeCountVitalSignsArgs
    patientSubsidies?: boolean | PatientCountOutputTypeCountPatientSubsidiesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLabReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabReportWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRadiologyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyReportWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountBedAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedAllocationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountVitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPatientSubsidiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientSubsidyWhereInput
  }


  /**
   * Count Type NurseCountOutputType
   */

  export type NurseCountOutputType = {
    vitalSigns: number
    bedAllocations: number
  }

  export type NurseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vitalSigns?: boolean | NurseCountOutputTypeCountVitalSignsArgs
    bedAllocations?: boolean | NurseCountOutputTypeCountBedAllocationsArgs
  }

  // Custom InputTypes
  /**
   * NurseCountOutputType without action
   */
  export type NurseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCountOutputType
     */
    select?: NurseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NurseCountOutputType without action
   */
  export type NurseCountOutputTypeCountVitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
  }

  /**
   * NurseCountOutputType without action
   */
  export type NurseCountOutputTypeCountBedAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedAllocationWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    prescriptions: number
    labReports: number
    radiologyReports: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptions?: boolean | AppointmentCountOutputTypeCountPrescriptionsArgs
    labReports?: boolean | AppointmentCountOutputTypeCountLabReportsArgs
    radiologyReports?: boolean | AppointmentCountOutputTypeCountRadiologyReportsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountLabReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabReportWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountRadiologyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyReportWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    medicines: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicines?: boolean | PrescriptionCountOutputTypeCountMedicinesArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionMedicineWhereInput
  }


  /**
   * Count Type MedicineCountOutputType
   */

  export type MedicineCountOutputType = {
    prescriptionMedicines: number
    inventoryLogs: number
  }

  export type MedicineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionMedicines?: boolean | MedicineCountOutputTypeCountPrescriptionMedicinesArgs
    inventoryLogs?: boolean | MedicineCountOutputTypeCountInventoryLogsArgs
  }

  // Custom InputTypes
  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineCountOutputType
     */
    select?: MedicineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountPrescriptionMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionMedicineWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountInventoryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLogWhereInput
  }


  /**
   * Count Type LabReportCountOutputType
   */

  export type LabReportCountOutputType = {
    invoiceItems: number
  }

  export type LabReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | LabReportCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * LabReportCountOutputType without action
   */
  export type LabReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReportCountOutputType
     */
    select?: LabReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabReportCountOutputType without action
   */
  export type LabReportCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type RadiologyReportCountOutputType
   */

  export type RadiologyReportCountOutputType = {
    invoiceItems: number
  }

  export type RadiologyReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | RadiologyReportCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * RadiologyReportCountOutputType without action
   */
  export type RadiologyReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReportCountOutputType
     */
    select?: RadiologyReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RadiologyReportCountOutputType without action
   */
  export type RadiologyReportCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    invoiceItems: number
    payments: number
    subsidyClaims: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | InvoiceCountOutputTypeCountInvoiceItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    subsidyClaims?: boolean | InvoiceCountOutputTypeCountSubsidyClaimsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountSubsidyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubsidyClaimWhereInput
  }


  /**
   * Count Type BedCountOutputType
   */

  export type BedCountOutputType = {
    bedAllocations: number
  }

  export type BedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bedAllocations?: boolean | BedCountOutputTypeCountBedAllocationsArgs
  }

  // Custom InputTypes
  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedCountOutputType
     */
    select?: BedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeCountBedAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedAllocationWhereInput
  }


  /**
   * Count Type WardCountOutputType
   */

  export type WardCountOutputType = {
    beds: number
  }

  export type WardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | WardCountOutputTypeCountBedsArgs
  }

  // Custom InputTypes
  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardCountOutputType
     */
    select?: WardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeCountBedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }


  /**
   * Count Type OperationTheaterCountOutputType
   */

  export type OperationTheaterCountOutputType = {
    surgeries: number
    equipments: number
  }

  export type OperationTheaterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgeries?: boolean | OperationTheaterCountOutputTypeCountSurgeriesArgs
    equipments?: boolean | OperationTheaterCountOutputTypeCountEquipmentsArgs
  }

  // Custom InputTypes
  /**
   * OperationTheaterCountOutputType without action
   */
  export type OperationTheaterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterCountOutputType
     */
    select?: OperationTheaterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperationTheaterCountOutputType without action
   */
  export type OperationTheaterCountOutputTypeCountSurgeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgeryWhereInput
  }

  /**
   * OperationTheaterCountOutputType without action
   */
  export type OperationTheaterCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationTheaterEquipmentWhereInput
  }


  /**
   * Count Type AmbulanceCountOutputType
   */

  export type AmbulanceCountOutputType = {
    ambulanceServices: number
  }

  export type AmbulanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambulanceServices?: boolean | AmbulanceCountOutputTypeCountAmbulanceServicesArgs
  }

  // Custom InputTypes
  /**
   * AmbulanceCountOutputType without action
   */
  export type AmbulanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceCountOutputType
     */
    select?: AmbulanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmbulanceCountOutputType without action
   */
  export type AmbulanceCountOutputTypeCountAmbulanceServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmbulanceServiceWhereInput
  }


  /**
   * Count Type TPACountOutputType
   */

  export type TPACountOutputType = {
    patients: number
  }

  export type TPACountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | TPACountOutputTypeCountPatientsArgs
  }

  // Custom InputTypes
  /**
   * TPACountOutputType without action
   */
  export type TPACountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPACountOutputType
     */
    select?: TPACountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TPACountOutputType without action
   */
  export type TPACountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    leaves: number
    salaryPayments: number
    documents: number
    performanceReviews: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
    salaryPayments?: boolean | EmployeeCountOutputTypeCountSalaryPaymentsArgs
    documents?: boolean | EmployeeCountOutputTypeCountDocumentsArgs
    performanceReviews?: boolean | EmployeeCountOutputTypeCountPerformanceReviewsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalaryPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeDocumentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPerformanceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
  }


  /**
   * Count Type SubsidySchemeCountOutputType
   */

  export type SubsidySchemeCountOutputType = {
    patientSubsidies: number
    subsidyClaims: number
  }

  export type SubsidySchemeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientSubsidies?: boolean | SubsidySchemeCountOutputTypeCountPatientSubsidiesArgs
    subsidyClaims?: boolean | SubsidySchemeCountOutputTypeCountSubsidyClaimsArgs
  }

  // Custom InputTypes
  /**
   * SubsidySchemeCountOutputType without action
   */
  export type SubsidySchemeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidySchemeCountOutputType
     */
    select?: SubsidySchemeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubsidySchemeCountOutputType without action
   */
  export type SubsidySchemeCountOutputTypeCountPatientSubsidiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientSubsidyWhereInput
  }

  /**
   * SubsidySchemeCountOutputType without action
   */
  export type SubsidySchemeCountOutputTypeCountSubsidyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubsidyClaimWhereInput
  }


  /**
   * Count Type PatientSubsidyCountOutputType
   */

  export type PatientSubsidyCountOutputType = {
    subsidyClaims: number
  }

  export type PatientSubsidyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subsidyClaims?: boolean | PatientSubsidyCountOutputTypeCountSubsidyClaimsArgs
  }

  // Custom InputTypes
  /**
   * PatientSubsidyCountOutputType without action
   */
  export type PatientSubsidyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidyCountOutputType
     */
    select?: PatientSubsidyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientSubsidyCountOutputType without action
   */
  export type PatientSubsidyCountOutputTypeCountSubsidyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubsidyClaimWhereInput
  }


  /**
   * Count Type HousekeepingAreaCountOutputType
   */

  export type HousekeepingAreaCountOutputType = {
    cleaningTasks: number
  }

  export type HousekeepingAreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningTasks?: boolean | HousekeepingAreaCountOutputTypeCountCleaningTasksArgs
  }

  // Custom InputTypes
  /**
   * HousekeepingAreaCountOutputType without action
   */
  export type HousekeepingAreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingAreaCountOutputType
     */
    select?: HousekeepingAreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HousekeepingAreaCountOutputType without action
   */
  export type HousekeepingAreaCountOutputTypeCountCleaningTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningTaskWhereInput
  }


  /**
   * Count Type HousekeepingStaffCountOutputType
   */

  export type HousekeepingStaffCountOutputType = {
    cleaningTasks: number
    cleaningVerifications: number
    supplyRequests: number
  }

  export type HousekeepingStaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningTasks?: boolean | HousekeepingStaffCountOutputTypeCountCleaningTasksArgs
    cleaningVerifications?: boolean | HousekeepingStaffCountOutputTypeCountCleaningVerificationsArgs
    supplyRequests?: boolean | HousekeepingStaffCountOutputTypeCountSupplyRequestsArgs
  }

  // Custom InputTypes
  /**
   * HousekeepingStaffCountOutputType without action
   */
  export type HousekeepingStaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaffCountOutputType
     */
    select?: HousekeepingStaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HousekeepingStaffCountOutputType without action
   */
  export type HousekeepingStaffCountOutputTypeCountCleaningTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningTaskWhereInput
  }

  /**
   * HousekeepingStaffCountOutputType without action
   */
  export type HousekeepingStaffCountOutputTypeCountCleaningVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningVerificationWhereInput
  }

  /**
   * HousekeepingStaffCountOutputType without action
   */
  export type HousekeepingStaffCountOutputTypeCountSupplyRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSupplyRequestWhereInput
  }


  /**
   * Count Type CleaningTaskCountOutputType
   */

  export type CleaningTaskCountOutputType = {
    verifications: number
  }

  export type CleaningTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verifications?: boolean | CleaningTaskCountOutputTypeCountVerificationsArgs
  }

  // Custom InputTypes
  /**
   * CleaningTaskCountOutputType without action
   */
  export type CleaningTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTaskCountOutputType
     */
    select?: CleaningTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningTaskCountOutputType without action
   */
  export type CleaningTaskCountOutputTypeCountVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningVerificationWhereInput
  }


  /**
   * Count Type CleaningSupplyCountOutputType
   */

  export type CleaningSupplyCountOutputType = {
    supplyRequests: number
  }

  export type CleaningSupplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplyRequests?: boolean | CleaningSupplyCountOutputTypeCountSupplyRequestsArgs
  }

  // Custom InputTypes
  /**
   * CleaningSupplyCountOutputType without action
   */
  export type CleaningSupplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyCountOutputType
     */
    select?: CleaningSupplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningSupplyCountOutputType without action
   */
  export type CleaningSupplyCountOutputTypeCountSupplyRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSupplyRequestItemWhereInput
  }


  /**
   * Count Type CleaningSupplyRequestCountOutputType
   */

  export type CleaningSupplyRequestCountOutputType = {
    requestItems: number
  }

  export type CleaningSupplyRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestItems?: boolean | CleaningSupplyRequestCountOutputTypeCountRequestItemsArgs
  }

  // Custom InputTypes
  /**
   * CleaningSupplyRequestCountOutputType without action
   */
  export type CleaningSupplyRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestCountOutputType
     */
    select?: CleaningSupplyRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningSupplyRequestCountOutputType without action
   */
  export type CleaningSupplyRequestCountOutputTypeCountRequestItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSupplyRequestItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isSystem" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: Date
    updatedAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt" | "updatedAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      permissionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    roleId: number | null
    status: string | null
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    profileImage: string | null
    dateOfBirth: Date | null
    gender: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    provider: string | null
    providerId: string | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    roleId: number | null
    status: string | null
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    profileImage: string | null
    dateOfBirth: Date | null
    gender: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    provider: string | null
    providerId: string | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    roleId: number
    status: number
    phoneNumber: number
    address: number
    city: number
    state: number
    zipCode: number
    country: number
    profileImage: number
    dateOfBirth: number
    gender: number
    twoFactorEnabled: number
    twoFactorSecret: number
    provider: number
    providerId: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    roleId?: true
    status?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    profileImage?: true
    dateOfBirth?: true
    gender?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    provider?: true
    providerId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    roleId?: true
    status?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    profileImage?: true
    dateOfBirth?: true
    gender?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    provider?: true
    providerId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    roleId?: true
    status?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    profileImage?: true
    dateOfBirth?: true
    gender?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    provider?: true
    providerId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId: number | null
    status: string
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    profileImage: string | null
    dateOfBirth: Date | null
    gender: string | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    provider: string | null
    providerId: string | null
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    roleId?: boolean
    status?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    profileImage?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    provider?: boolean
    providerId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
    passwordReset?: boolean | User$passwordResetArgs<ExtArgs>
    doctor?: boolean | User$doctorArgs<ExtArgs>
    patient?: boolean | User$patientArgs<ExtArgs>
    nurse?: boolean | User$nurseArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    biometricData?: boolean | User$biometricDataArgs<ExtArgs>
    attendanceLogs?: boolean | User$attendanceLogsArgs<ExtArgs>
    dutyRosters?: boolean | User$dutyRostersArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    housekeepingStaff?: boolean | User$housekeepingStaffArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    roleId?: boolean
    status?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    profileImage?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    provider?: boolean
    providerId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    roleId?: boolean
    status?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    profileImage?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    provider?: boolean
    providerId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    roleId?: boolean
    status?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    profileImage?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    provider?: boolean
    providerId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "roleId" | "status" | "phoneNumber" | "address" | "city" | "state" | "zipCode" | "country" | "profileImage" | "dateOfBirth" | "gender" | "twoFactorEnabled" | "twoFactorSecret" | "provider" | "providerId" | "emailVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
    passwordReset?: boolean | User$passwordResetArgs<ExtArgs>
    doctor?: boolean | User$doctorArgs<ExtArgs>
    patient?: boolean | User$patientArgs<ExtArgs>
    nurse?: boolean | User$nurseArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    biometricData?: boolean | User$biometricDataArgs<ExtArgs>
    attendanceLogs?: boolean | User$attendanceLogsArgs<ExtArgs>
    dutyRosters?: boolean | User$dutyRostersArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    housekeepingStaff?: boolean | User$housekeepingStaffArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs> | null
      passwordReset: Prisma.$PasswordResetPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      nurse: Prisma.$NursePayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      biometricData: Prisma.$BiometricDataPayload<ExtArgs> | null
      attendanceLogs: Prisma.$AttendanceLogPayload<ExtArgs>[]
      dutyRosters: Prisma.$DutyRosterPayload<ExtArgs>[]
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      housekeepingStaff: Prisma.$HousekeepingStaffPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      roleId: number | null
      status: string
      phoneNumber: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string | null
      profileImage: string | null
      dateOfBirth: Date | null
      gender: string | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      provider: string | null
      providerId: string | null
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends User$roleArgs<ExtArgs> = {}>(args?: Subset<T, User$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    passwordReset<T extends User$passwordResetArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends User$doctorArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends User$patientArgs<ExtArgs> = {}>(args?: Subset<T, User$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nurse<T extends User$nurseArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    biometricData<T extends User$biometricDataArgs<ExtArgs> = {}>(args?: Subset<T, User$biometricDataArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendanceLogs<T extends User$attendanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dutyRosters<T extends User$dutyRostersArgs<ExtArgs> = {}>(args?: Subset<T, User$dutyRostersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    housekeepingStaff<T extends User$housekeepingStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$housekeepingStaffArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly status: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zipCode: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly provider: FieldRef<"User", 'String'>
    readonly providerId: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.role
   */
  export type User$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * User.passwordReset
   */
  export type User$passwordResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
  }

  /**
   * User.doctor
   */
  export type User$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * User.patient
   */
  export type User$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * User.nurse
   */
  export type User$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    where?: NurseWhereInput
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.biometricData
   */
  export type User$biometricDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    where?: BiometricDataWhereInput
  }

  /**
   * User.attendanceLogs
   */
  export type User$attendanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    cursor?: AttendanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * User.dutyRosters
   */
  export type User$dutyRostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    where?: DutyRosterWhereInput
    orderBy?: DutyRosterOrderByWithRelationInput | DutyRosterOrderByWithRelationInput[]
    cursor?: DutyRosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyRosterScalarFieldEnum | DutyRosterScalarFieldEnum[]
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.housekeepingStaff
   */
  export type User$housekeepingStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    where?: HousekeepingStaffWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordResetAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _avg?: PasswordResetAvgAggregateInputType
    _sum?: PasswordResetSumAggregateInputType
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordReset"]>
  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {PasswordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'Int'>
    readonly userId: FieldRef<"PasswordReset", 'Int'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset updateManyAndReturn
   */
  export type PasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    experience: number | null
    consultationFee: Decimal | null
  }

  export type DoctorSumAggregateOutputType = {
    id: number | null
    userId: number | null
    experience: number | null
    consultationFee: Decimal | null
  }

  export type DoctorMinAggregateOutputType = {
    id: number | null
    userId: number | null
    specialization: string | null
    qualification: string | null
    experience: number | null
    licenseNumber: string | null
    consultationFee: Decimal | null
    availableDays: string | null
    availableTimeStart: string | null
    availableTimeEnd: string | null
    department: string | null
    bio: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    specialization: string | null
    qualification: string | null
    experience: number | null
    licenseNumber: string | null
    consultationFee: Decimal | null
    availableDays: string | null
    availableTimeStart: string | null
    availableTimeEnd: string | null
    department: string | null
    bio: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    userId: number
    specialization: number
    qualification: number
    experience: number
    licenseNumber: number
    consultationFee: number
    availableDays: number
    availableTimeStart: number
    availableTimeEnd: number
    department: number
    bio: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DoctorAvgAggregateInputType = {
    id?: true
    userId?: true
    experience?: true
    consultationFee?: true
  }

  export type DoctorSumAggregateInputType = {
    id?: true
    userId?: true
    experience?: true
    consultationFee?: true
  }

  export type DoctorMinAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    qualification?: true
    experience?: true
    licenseNumber?: true
    consultationFee?: true
    availableDays?: true
    availableTimeStart?: true
    availableTimeEnd?: true
    department?: true
    bio?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    qualification?: true
    experience?: true
    licenseNumber?: true
    consultationFee?: true
    availableDays?: true
    availableTimeStart?: true
    availableTimeEnd?: true
    department?: true
    bio?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    qualification?: true
    experience?: true
    licenseNumber?: true
    consultationFee?: true
    availableDays?: true
    availableTimeStart?: true
    availableTimeEnd?: true
    department?: true
    bio?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _avg?: DoctorAvgAggregateInputType
    _sum?: DoctorSumAggregateInputType
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: number
    userId: number
    specialization: string
    qualification: string
    experience: number
    licenseNumber: string
    consultationFee: Decimal
    availableDays: string | null
    availableTimeStart: string | null
    availableTimeEnd: string | null
    department: string | null
    bio: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    qualification?: boolean
    experience?: boolean
    licenseNumber?: boolean
    consultationFee?: boolean
    availableDays?: boolean
    availableTimeStart?: boolean
    availableTimeEnd?: boolean
    department?: boolean
    bio?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    prescriptions?: boolean | Doctor$prescriptionsArgs<ExtArgs>
    labReports?: boolean | Doctor$labReportsArgs<ExtArgs>
    radiologyReports?: boolean | Doctor$radiologyReportsArgs<ExtArgs>
    operationTheaters?: boolean | Doctor$operationTheatersArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    qualification?: boolean
    experience?: boolean
    licenseNumber?: boolean
    consultationFee?: boolean
    availableDays?: boolean
    availableTimeStart?: boolean
    availableTimeEnd?: boolean
    department?: boolean
    bio?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    qualification?: boolean
    experience?: boolean
    licenseNumber?: boolean
    consultationFee?: boolean
    availableDays?: boolean
    availableTimeStart?: boolean
    availableTimeEnd?: boolean
    department?: boolean
    bio?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    userId?: boolean
    specialization?: boolean
    qualification?: boolean
    experience?: boolean
    licenseNumber?: boolean
    consultationFee?: boolean
    availableDays?: boolean
    availableTimeStart?: boolean
    availableTimeEnd?: boolean
    department?: boolean
    bio?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DoctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "specialization" | "qualification" | "experience" | "licenseNumber" | "consultationFee" | "availableDays" | "availableTimeStart" | "availableTimeEnd" | "department" | "bio" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["doctor"]>
  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    prescriptions?: boolean | Doctor$prescriptionsArgs<ExtArgs>
    labReports?: boolean | Doctor$labReportsArgs<ExtArgs>
    radiologyReports?: boolean | Doctor$radiologyReportsArgs<ExtArgs>
    operationTheaters?: boolean | Doctor$operationTheatersArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      labReports: Prisma.$LabReportPayload<ExtArgs>[]
      radiologyReports: Prisma.$RadiologyReportPayload<ExtArgs>[]
      operationTheaters: Prisma.$OperationTheaterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      specialization: string
      qualification: string
      experience: number
      licenseNumber: string
      consultationFee: Prisma.Decimal
      availableDays: string | null
      availableTimeStart: string | null
      availableTimeEnd: string | null
      department: string | null
      bio: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {DoctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Doctor$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Doctor$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labReports<T extends Doctor$labReportsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$labReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyReports<T extends Doctor$radiologyReportsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$radiologyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operationTheaters<T extends Doctor$operationTheatersArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$operationTheatersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctor model
   */
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'Int'>
    readonly userId: FieldRef<"Doctor", 'Int'>
    readonly specialization: FieldRef<"Doctor", 'String'>
    readonly qualification: FieldRef<"Doctor", 'String'>
    readonly experience: FieldRef<"Doctor", 'Int'>
    readonly licenseNumber: FieldRef<"Doctor", 'String'>
    readonly consultationFee: FieldRef<"Doctor", 'Decimal'>
    readonly availableDays: FieldRef<"Doctor", 'String'>
    readonly availableTimeStart: FieldRef<"Doctor", 'String'>
    readonly availableTimeEnd: FieldRef<"Doctor", 'String'>
    readonly department: FieldRef<"Doctor", 'String'>
    readonly bio: FieldRef<"Doctor", 'String'>
    readonly isVerified: FieldRef<"Doctor", 'Boolean'>
    readonly createdAt: FieldRef<"Doctor", 'DateTime'>
    readonly updatedAt: FieldRef<"Doctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }

  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor createManyAndReturn
   */
  export type DoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor updateManyAndReturn
   */
  export type DoctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }

  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to delete.
     */
    limit?: number
  }

  /**
   * Doctor.appointments
   */
  export type Doctor$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Doctor.prescriptions
   */
  export type Doctor$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Doctor.labReports
   */
  export type Doctor$labReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    where?: LabReportWhereInput
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    cursor?: LabReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * Doctor.radiologyReports
   */
  export type Doctor$radiologyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    where?: RadiologyReportWhereInput
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    cursor?: RadiologyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyReportScalarFieldEnum | RadiologyReportScalarFieldEnum[]
  }

  /**
   * Doctor.operationTheaters
   */
  export type Doctor$operationTheatersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    where?: OperationTheaterWhereInput
    orderBy?: OperationTheaterOrderByWithRelationInput | OperationTheaterOrderByWithRelationInput[]
    cursor?: OperationTheaterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationTheaterScalarFieldEnum | OperationTheaterScalarFieldEnum[]
  }

  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    height: number | null
    weight: number | null
    tpaId: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    userId: number | null
    height: number | null
    weight: number | null
    tpaId: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    userId: number | null
    patientId: string | null
    bloodGroup: string | null
    height: number | null
    weight: number | null
    allergies: string | null
    chronicDiseases: string | null
    emergencyContact: string | null
    emergencyName: string | null
    emergencyRelation: string | null
    insuranceProvider: string | null
    insuranceId: string | null
    tpaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    patientId: string | null
    bloodGroup: string | null
    height: number | null
    weight: number | null
    allergies: string | null
    chronicDiseases: string | null
    emergencyContact: string | null
    emergencyName: string | null
    emergencyRelation: string | null
    insuranceProvider: string | null
    insuranceId: string | null
    tpaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    userId: number
    patientId: number
    bloodGroup: number
    height: number
    weight: number
    allergies: number
    chronicDiseases: number
    emergencyContact: number
    emergencyName: number
    emergencyRelation: number
    insuranceProvider: number
    insuranceId: number
    tpaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    userId?: true
    height?: true
    weight?: true
    tpaId?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    userId?: true
    height?: true
    weight?: true
    tpaId?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    userId?: true
    patientId?: true
    bloodGroup?: true
    height?: true
    weight?: true
    allergies?: true
    chronicDiseases?: true
    emergencyContact?: true
    emergencyName?: true
    emergencyRelation?: true
    insuranceProvider?: true
    insuranceId?: true
    tpaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    userId?: true
    patientId?: true
    bloodGroup?: true
    height?: true
    weight?: true
    allergies?: true
    chronicDiseases?: true
    emergencyContact?: true
    emergencyName?: true
    emergencyRelation?: true
    insuranceProvider?: true
    insuranceId?: true
    tpaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    userId?: true
    patientId?: true
    bloodGroup?: true
    height?: true
    weight?: true
    allergies?: true
    chronicDiseases?: true
    emergencyContact?: true
    emergencyName?: true
    emergencyRelation?: true
    insuranceProvider?: true
    insuranceId?: true
    tpaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    userId: number
    patientId: string
    bloodGroup: string | null
    height: number | null
    weight: number | null
    allergies: string | null
    chronicDiseases: string | null
    emergencyContact: string | null
    emergencyName: string | null
    emergencyRelation: string | null
    insuranceProvider: string | null
    insuranceId: string | null
    tpaId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patientId?: boolean
    bloodGroup?: boolean
    height?: boolean
    weight?: boolean
    allergies?: boolean
    chronicDiseases?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    tpaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tpa?: boolean | Patient$tpaArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    labReports?: boolean | Patient$labReportsArgs<ExtArgs>
    radiologyReports?: boolean | Patient$radiologyReportsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    bedAllocations?: boolean | Patient$bedAllocationsArgs<ExtArgs>
    vitalSigns?: boolean | Patient$vitalSignsArgs<ExtArgs>
    patientSubsidies?: boolean | Patient$patientSubsidiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patientId?: boolean
    bloodGroup?: boolean
    height?: boolean
    weight?: boolean
    allergies?: boolean
    chronicDiseases?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    tpaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tpa?: boolean | Patient$tpaArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patientId?: boolean
    bloodGroup?: boolean
    height?: boolean
    weight?: boolean
    allergies?: boolean
    chronicDiseases?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    tpaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tpa?: boolean | Patient$tpaArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    userId?: boolean
    patientId?: boolean
    bloodGroup?: boolean
    height?: boolean
    weight?: boolean
    allergies?: boolean
    chronicDiseases?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    tpaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "patientId" | "bloodGroup" | "height" | "weight" | "allergies" | "chronicDiseases" | "emergencyContact" | "emergencyName" | "emergencyRelation" | "insuranceProvider" | "insuranceId" | "tpaId" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tpa?: boolean | Patient$tpaArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    labReports?: boolean | Patient$labReportsArgs<ExtArgs>
    radiologyReports?: boolean | Patient$radiologyReportsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    bedAllocations?: boolean | Patient$bedAllocationsArgs<ExtArgs>
    vitalSigns?: boolean | Patient$vitalSignsArgs<ExtArgs>
    patientSubsidies?: boolean | Patient$patientSubsidiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tpa?: boolean | Patient$tpaArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tpa?: boolean | Patient$tpaArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tpa: Prisma.$TPAPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      labReports: Prisma.$LabReportPayload<ExtArgs>[]
      radiologyReports: Prisma.$RadiologyReportPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      bedAllocations: Prisma.$BedAllocationPayload<ExtArgs>[]
      vitalSigns: Prisma.$VitalSignPayload<ExtArgs>[]
      patientSubsidies: Prisma.$PatientSubsidyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      patientId: string
      bloodGroup: string | null
      height: number | null
      weight: number | null
      allergies: string | null
      chronicDiseases: string | null
      emergencyContact: string | null
      emergencyName: string | null
      emergencyRelation: string | null
      insuranceProvider: string | null
      insuranceId: string | null
      tpaId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tpa<T extends Patient$tpaArgs<ExtArgs> = {}>(args?: Subset<T, Patient$tpaArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labReports<T extends Patient$labReportsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$labReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyReports<T extends Patient$radiologyReportsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$radiologyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bedAllocations<T extends Patient$bedAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$bedAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vitalSigns<T extends Patient$vitalSignsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$vitalSignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patientSubsidies<T extends Patient$patientSubsidiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$patientSubsidiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly userId: FieldRef<"Patient", 'Int'>
    readonly patientId: FieldRef<"Patient", 'String'>
    readonly bloodGroup: FieldRef<"Patient", 'String'>
    readonly height: FieldRef<"Patient", 'Float'>
    readonly weight: FieldRef<"Patient", 'Float'>
    readonly allergies: FieldRef<"Patient", 'String'>
    readonly chronicDiseases: FieldRef<"Patient", 'String'>
    readonly emergencyContact: FieldRef<"Patient", 'String'>
    readonly emergencyName: FieldRef<"Patient", 'String'>
    readonly emergencyRelation: FieldRef<"Patient", 'String'>
    readonly insuranceProvider: FieldRef<"Patient", 'String'>
    readonly insuranceId: FieldRef<"Patient", 'String'>
    readonly tpaId: FieldRef<"Patient", 'Int'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.tpa
   */
  export type Patient$tpaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    where?: TPAWhereInput
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.labReports
   */
  export type Patient$labReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    where?: LabReportWhereInput
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    cursor?: LabReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * Patient.radiologyReports
   */
  export type Patient$radiologyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    where?: RadiologyReportWhereInput
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    cursor?: RadiologyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyReportScalarFieldEnum | RadiologyReportScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.bedAllocations
   */
  export type Patient$bedAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    where?: BedAllocationWhereInput
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    cursor?: BedAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedAllocationScalarFieldEnum | BedAllocationScalarFieldEnum[]
  }

  /**
   * Patient.vitalSigns
   */
  export type Patient$vitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    cursor?: VitalSignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * Patient.patientSubsidies
   */
  export type Patient$patientSubsidiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    where?: PatientSubsidyWhereInput
    orderBy?: PatientSubsidyOrderByWithRelationInput | PatientSubsidyOrderByWithRelationInput[]
    cursor?: PatientSubsidyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientSubsidyScalarFieldEnum | PatientSubsidyScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Nurse
   */

  export type AggregateNurse = {
    _count: NurseCountAggregateOutputType | null
    _avg: NurseAvgAggregateOutputType | null
    _sum: NurseSumAggregateOutputType | null
    _min: NurseMinAggregateOutputType | null
    _max: NurseMaxAggregateOutputType | null
  }

  export type NurseAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    experience: number | null
  }

  export type NurseSumAggregateOutputType = {
    id: number | null
    userId: number | null
    experience: number | null
  }

  export type NurseMinAggregateOutputType = {
    id: number | null
    userId: number | null
    licenseNumber: string | null
    qualification: string | null
    experience: number | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NurseMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    licenseNumber: string | null
    qualification: string | null
    experience: number | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NurseCountAggregateOutputType = {
    id: number
    userId: number
    licenseNumber: number
    qualification: number
    experience: number
    department: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NurseAvgAggregateInputType = {
    id?: true
    userId?: true
    experience?: true
  }

  export type NurseSumAggregateInputType = {
    id?: true
    userId?: true
    experience?: true
  }

  export type NurseMinAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    qualification?: true
    experience?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NurseMaxAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    qualification?: true
    experience?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NurseCountAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    qualification?: true
    experience?: true
    department?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NurseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nurse to aggregate.
     */
    where?: NurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nurses to fetch.
     */
    orderBy?: NurseOrderByWithRelationInput | NurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nurses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nurses
    **/
    _count?: true | NurseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NurseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NurseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseMaxAggregateInputType
  }

  export type GetNurseAggregateType<T extends NurseAggregateArgs> = {
        [P in keyof T & keyof AggregateNurse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurse[P]>
      : GetScalarType<T[P], AggregateNurse[P]>
  }




  export type NurseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseWhereInput
    orderBy?: NurseOrderByWithAggregationInput | NurseOrderByWithAggregationInput[]
    by: NurseScalarFieldEnum[] | NurseScalarFieldEnum
    having?: NurseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseCountAggregateInputType | true
    _avg?: NurseAvgAggregateInputType
    _sum?: NurseSumAggregateInputType
    _min?: NurseMinAggregateInputType
    _max?: NurseMaxAggregateInputType
  }

  export type NurseGroupByOutputType = {
    id: number
    userId: number
    licenseNumber: string
    qualification: string
    experience: number
    department: string | null
    createdAt: Date
    updatedAt: Date
    _count: NurseCountAggregateOutputType | null
    _avg: NurseAvgAggregateOutputType | null
    _sum: NurseSumAggregateOutputType | null
    _min: NurseMinAggregateOutputType | null
    _max: NurseMaxAggregateOutputType | null
  }

  type GetNurseGroupByPayload<T extends NurseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseGroupByOutputType[P]>
            : GetScalarType<T[P], NurseGroupByOutputType[P]>
        }
      >
    >


  export type NurseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    qualification?: boolean
    experience?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vitalSigns?: boolean | Nurse$vitalSignsArgs<ExtArgs>
    bedAllocations?: boolean | Nurse$bedAllocationsArgs<ExtArgs>
    _count?: boolean | NurseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurse"]>

  export type NurseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    qualification?: boolean
    experience?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurse"]>

  export type NurseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    qualification?: boolean
    experience?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurse"]>

  export type NurseSelectScalar = {
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    qualification?: boolean
    experience?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NurseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "licenseNumber" | "qualification" | "experience" | "department" | "createdAt" | "updatedAt", ExtArgs["result"]["nurse"]>
  export type NurseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vitalSigns?: boolean | Nurse$vitalSignsArgs<ExtArgs>
    bedAllocations?: boolean | Nurse$bedAllocationsArgs<ExtArgs>
    _count?: boolean | NurseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NurseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NurseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nurse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vitalSigns: Prisma.$VitalSignPayload<ExtArgs>[]
      bedAllocations: Prisma.$BedAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      licenseNumber: string
      qualification: string
      experience: number
      department: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nurse"]>
    composites: {}
  }

  type NurseGetPayload<S extends boolean | null | undefined | NurseDefaultArgs> = $Result.GetResult<Prisma.$NursePayload, S>

  type NurseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NurseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NurseCountAggregateInputType | true
    }

  export interface NurseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nurse'], meta: { name: 'Nurse' } }
    /**
     * Find zero or one Nurse that matches the filter.
     * @param {NurseFindUniqueArgs} args - Arguments to find a Nurse
     * @example
     * // Get one Nurse
     * const nurse = await prisma.nurse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NurseFindUniqueArgs>(args: SelectSubset<T, NurseFindUniqueArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nurse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NurseFindUniqueOrThrowArgs} args - Arguments to find a Nurse
     * @example
     * // Get one Nurse
     * const nurse = await prisma.nurse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NurseFindUniqueOrThrowArgs>(args: SelectSubset<T, NurseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nurse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseFindFirstArgs} args - Arguments to find a Nurse
     * @example
     * // Get one Nurse
     * const nurse = await prisma.nurse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NurseFindFirstArgs>(args?: SelectSubset<T, NurseFindFirstArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nurse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseFindFirstOrThrowArgs} args - Arguments to find a Nurse
     * @example
     * // Get one Nurse
     * const nurse = await prisma.nurse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NurseFindFirstOrThrowArgs>(args?: SelectSubset<T, NurseFindFirstOrThrowArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nurses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nurses
     * const nurses = await prisma.nurse.findMany()
     * 
     * // Get first 10 Nurses
     * const nurses = await prisma.nurse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nurseWithIdOnly = await prisma.nurse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NurseFindManyArgs>(args?: SelectSubset<T, NurseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nurse.
     * @param {NurseCreateArgs} args - Arguments to create a Nurse.
     * @example
     * // Create one Nurse
     * const Nurse = await prisma.nurse.create({
     *   data: {
     *     // ... data to create a Nurse
     *   }
     * })
     * 
     */
    create<T extends NurseCreateArgs>(args: SelectSubset<T, NurseCreateArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nurses.
     * @param {NurseCreateManyArgs} args - Arguments to create many Nurses.
     * @example
     * // Create many Nurses
     * const nurse = await prisma.nurse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NurseCreateManyArgs>(args?: SelectSubset<T, NurseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nurses and returns the data saved in the database.
     * @param {NurseCreateManyAndReturnArgs} args - Arguments to create many Nurses.
     * @example
     * // Create many Nurses
     * const nurse = await prisma.nurse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nurses and only return the `id`
     * const nurseWithIdOnly = await prisma.nurse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NurseCreateManyAndReturnArgs>(args?: SelectSubset<T, NurseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nurse.
     * @param {NurseDeleteArgs} args - Arguments to delete one Nurse.
     * @example
     * // Delete one Nurse
     * const Nurse = await prisma.nurse.delete({
     *   where: {
     *     // ... filter to delete one Nurse
     *   }
     * })
     * 
     */
    delete<T extends NurseDeleteArgs>(args: SelectSubset<T, NurseDeleteArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nurse.
     * @param {NurseUpdateArgs} args - Arguments to update one Nurse.
     * @example
     * // Update one Nurse
     * const nurse = await prisma.nurse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NurseUpdateArgs>(args: SelectSubset<T, NurseUpdateArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nurses.
     * @param {NurseDeleteManyArgs} args - Arguments to filter Nurses to delete.
     * @example
     * // Delete a few Nurses
     * const { count } = await prisma.nurse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NurseDeleteManyArgs>(args?: SelectSubset<T, NurseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nurses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nurses
     * const nurse = await prisma.nurse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NurseUpdateManyArgs>(args: SelectSubset<T, NurseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nurses and returns the data updated in the database.
     * @param {NurseUpdateManyAndReturnArgs} args - Arguments to update many Nurses.
     * @example
     * // Update many Nurses
     * const nurse = await prisma.nurse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nurses and only return the `id`
     * const nurseWithIdOnly = await prisma.nurse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NurseUpdateManyAndReturnArgs>(args: SelectSubset<T, NurseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nurse.
     * @param {NurseUpsertArgs} args - Arguments to update or create a Nurse.
     * @example
     * // Update or create a Nurse
     * const nurse = await prisma.nurse.upsert({
     *   create: {
     *     // ... data to create a Nurse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nurse we want to update
     *   }
     * })
     */
    upsert<T extends NurseUpsertArgs>(args: SelectSubset<T, NurseUpsertArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nurses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCountArgs} args - Arguments to filter Nurses to count.
     * @example
     * // Count the number of Nurses
     * const count = await prisma.nurse.count({
     *   where: {
     *     // ... the filter for the Nurses we want to count
     *   }
     * })
    **/
    count<T extends NurseCountArgs>(
      args?: Subset<T, NurseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nurse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseAggregateArgs>(args: Subset<T, NurseAggregateArgs>): Prisma.PrismaPromise<GetNurseAggregateType<T>>

    /**
     * Group by Nurse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NurseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NurseGroupByArgs['orderBy'] }
        : { orderBy?: NurseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NurseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nurse model
   */
  readonly fields: NurseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nurse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NurseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vitalSigns<T extends Nurse$vitalSignsArgs<ExtArgs> = {}>(args?: Subset<T, Nurse$vitalSignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bedAllocations<T extends Nurse$bedAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Nurse$bedAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nurse model
   */
  interface NurseFieldRefs {
    readonly id: FieldRef<"Nurse", 'Int'>
    readonly userId: FieldRef<"Nurse", 'Int'>
    readonly licenseNumber: FieldRef<"Nurse", 'String'>
    readonly qualification: FieldRef<"Nurse", 'String'>
    readonly experience: FieldRef<"Nurse", 'Int'>
    readonly department: FieldRef<"Nurse", 'String'>
    readonly createdAt: FieldRef<"Nurse", 'DateTime'>
    readonly updatedAt: FieldRef<"Nurse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Nurse findUnique
   */
  export type NurseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * Filter, which Nurse to fetch.
     */
    where: NurseWhereUniqueInput
  }

  /**
   * Nurse findUniqueOrThrow
   */
  export type NurseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * Filter, which Nurse to fetch.
     */
    where: NurseWhereUniqueInput
  }

  /**
   * Nurse findFirst
   */
  export type NurseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * Filter, which Nurse to fetch.
     */
    where?: NurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nurses to fetch.
     */
    orderBy?: NurseOrderByWithRelationInput | NurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nurses.
     */
    cursor?: NurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nurses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nurses.
     */
    distinct?: NurseScalarFieldEnum | NurseScalarFieldEnum[]
  }

  /**
   * Nurse findFirstOrThrow
   */
  export type NurseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * Filter, which Nurse to fetch.
     */
    where?: NurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nurses to fetch.
     */
    orderBy?: NurseOrderByWithRelationInput | NurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nurses.
     */
    cursor?: NurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nurses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nurses.
     */
    distinct?: NurseScalarFieldEnum | NurseScalarFieldEnum[]
  }

  /**
   * Nurse findMany
   */
  export type NurseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * Filter, which Nurses to fetch.
     */
    where?: NurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nurses to fetch.
     */
    orderBy?: NurseOrderByWithRelationInput | NurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nurses.
     */
    cursor?: NurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nurses.
     */
    skip?: number
    distinct?: NurseScalarFieldEnum | NurseScalarFieldEnum[]
  }

  /**
   * Nurse create
   */
  export type NurseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * The data needed to create a Nurse.
     */
    data: XOR<NurseCreateInput, NurseUncheckedCreateInput>
  }

  /**
   * Nurse createMany
   */
  export type NurseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nurses.
     */
    data: NurseCreateManyInput | NurseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nurse createManyAndReturn
   */
  export type NurseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * The data used to create many Nurses.
     */
    data: NurseCreateManyInput | NurseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nurse update
   */
  export type NurseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * The data needed to update a Nurse.
     */
    data: XOR<NurseUpdateInput, NurseUncheckedUpdateInput>
    /**
     * Choose, which Nurse to update.
     */
    where: NurseWhereUniqueInput
  }

  /**
   * Nurse updateMany
   */
  export type NurseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nurses.
     */
    data: XOR<NurseUpdateManyMutationInput, NurseUncheckedUpdateManyInput>
    /**
     * Filter which Nurses to update
     */
    where?: NurseWhereInput
    /**
     * Limit how many Nurses to update.
     */
    limit?: number
  }

  /**
   * Nurse updateManyAndReturn
   */
  export type NurseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * The data used to update Nurses.
     */
    data: XOR<NurseUpdateManyMutationInput, NurseUncheckedUpdateManyInput>
    /**
     * Filter which Nurses to update
     */
    where?: NurseWhereInput
    /**
     * Limit how many Nurses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nurse upsert
   */
  export type NurseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * The filter to search for the Nurse to update in case it exists.
     */
    where: NurseWhereUniqueInput
    /**
     * In case the Nurse found by the `where` argument doesn't exist, create a new Nurse with this data.
     */
    create: XOR<NurseCreateInput, NurseUncheckedCreateInput>
    /**
     * In case the Nurse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NurseUpdateInput, NurseUncheckedUpdateInput>
  }

  /**
   * Nurse delete
   */
  export type NurseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    /**
     * Filter which Nurse to delete.
     */
    where: NurseWhereUniqueInput
  }

  /**
   * Nurse deleteMany
   */
  export type NurseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nurses to delete
     */
    where?: NurseWhereInput
    /**
     * Limit how many Nurses to delete.
     */
    limit?: number
  }

  /**
   * Nurse.vitalSigns
   */
  export type Nurse$vitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    cursor?: VitalSignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * Nurse.bedAllocations
   */
  export type Nurse$bedAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    where?: BedAllocationWhereInput
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    cursor?: BedAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedAllocationScalarFieldEnum | BedAllocationScalarFieldEnum[]
  }

  /**
   * Nurse without action
   */
  export type NurseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentDate: Date | null
    startTime: string | null
    endTime: string | null
    status: string | null
    reason: string | null
    notes: string | null
    followUp: boolean | null
    followUpDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentDate: Date | null
    startTime: string | null
    endTime: string | null
    status: string | null
    reason: string | null
    notes: string | null
    followUp: boolean | null
    followUpDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentDate: number
    startTime: number
    endTime: number
    status: number
    reason: number
    notes: number
    followUp: number
    followUpDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    status?: true
    reason?: true
    notes?: true
    followUp?: true
    followUpDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    status?: true
    reason?: true
    notes?: true
    followUp?: true
    followUpDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    status?: true
    reason?: true
    notes?: true
    followUp?: true
    followUpDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentDate: Date
    startTime: string
    endTime: string
    status: string
    reason: string | null
    notes: string | null
    followUp: boolean
    followUpDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    followUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    prescriptions?: boolean | Appointment$prescriptionsArgs<ExtArgs>
    labReports?: boolean | Appointment$labReportsArgs<ExtArgs>
    radiologyReports?: boolean | Appointment$radiologyReportsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    followUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    followUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    followUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "appointmentDate" | "startTime" | "endTime" | "status" | "reason" | "notes" | "followUp" | "followUpDate" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    prescriptions?: boolean | Appointment$prescriptionsArgs<ExtArgs>
    labReports?: boolean | Appointment$labReportsArgs<ExtArgs>
    radiologyReports?: boolean | Appointment$radiologyReportsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      labReports: Prisma.$LabReportPayload<ExtArgs>[]
      radiologyReports: Prisma.$RadiologyReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      doctorId: number
      appointmentDate: Date
      startTime: string
      endTime: string
      status: string
      reason: string | null
      notes: string | null
      followUp: boolean
      followUpDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescriptions<T extends Appointment$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labReports<T extends Appointment$labReportsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$labReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyReports<T extends Appointment$radiologyReportsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$radiologyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly patientId: FieldRef<"Appointment", 'Int'>
    readonly doctorId: FieldRef<"Appointment", 'Int'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly startTime: FieldRef<"Appointment", 'String'>
    readonly endTime: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly followUp: FieldRef<"Appointment", 'Boolean'>
    readonly followUpDate: FieldRef<"Appointment", 'DateTime'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.prescriptions
   */
  export type Appointment$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Appointment.labReports
   */
  export type Appointment$labReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    where?: LabReportWhereInput
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    cursor?: LabReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * Appointment.radiologyReports
   */
  export type Appointment$radiologyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    where?: RadiologyReportWhereInput
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    cursor?: RadiologyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyReportScalarFieldEnum | RadiologyReportScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
    prescriptionDate: Date | null
    diagnosis: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
    prescriptionDate: Date | null
    diagnosis: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentId: number
    prescriptionDate: number
    diagnosis: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    prescriptionDate?: true
    diagnosis?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    prescriptionDate?: true
    diagnosis?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    prescriptionDate?: true
    diagnosis?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentId: number | null
    prescriptionDate: Date
    diagnosis: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    prescriptionDate?: boolean
    diagnosis?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | Prescription$appointmentArgs<ExtArgs>
    medicines?: boolean | Prescription$medicinesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    prescriptionDate?: boolean
    diagnosis?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | Prescription$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    prescriptionDate?: boolean
    diagnosis?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | Prescription$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    prescriptionDate?: boolean
    diagnosis?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "appointmentId" | "prescriptionDate" | "diagnosis" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | Prescription$appointmentArgs<ExtArgs>
    medicines?: boolean | Prescription$medicinesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | Prescription$appointmentArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | Prescription$appointmentArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      medicines: Prisma.$PrescriptionMedicinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      doctorId: number
      appointmentId: number | null
      prescriptionDate: Date
      diagnosis: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends Prescription$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medicines<T extends Prescription$medicinesArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$medicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'Int'>
    readonly patientId: FieldRef<"Prescription", 'Int'>
    readonly doctorId: FieldRef<"Prescription", 'Int'>
    readonly appointmentId: FieldRef<"Prescription", 'Int'>
    readonly prescriptionDate: FieldRef<"Prescription", 'DateTime'>
    readonly diagnosis: FieldRef<"Prescription", 'String'>
    readonly notes: FieldRef<"Prescription", 'String'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly updatedAt: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.appointment
   */
  export type Prescription$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Prescription.medicines
   */
  export type Prescription$medicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    where?: PrescriptionMedicineWhereInput
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    cursor?: PrescriptionMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionMedicine
   */

  export type AggregatePrescriptionMedicine = {
    _count: PrescriptionMedicineCountAggregateOutputType | null
    _avg: PrescriptionMedicineAvgAggregateOutputType | null
    _sum: PrescriptionMedicineSumAggregateOutputType | null
    _min: PrescriptionMedicineMinAggregateOutputType | null
    _max: PrescriptionMedicineMaxAggregateOutputType | null
  }

  export type PrescriptionMedicineAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    medicineId: number | null
  }

  export type PrescriptionMedicineSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    medicineId: number | null
  }

  export type PrescriptionMedicineMinAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    medicineId: number | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrescriptionMedicineMaxAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    medicineId: number | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrescriptionMedicineCountAggregateOutputType = {
    id: number
    prescriptionId: number
    medicineId: number
    dosage: number
    frequency: number
    duration: number
    instructions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrescriptionMedicineAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
  }

  export type PrescriptionMedicineSumAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
  }

  export type PrescriptionMedicineMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrescriptionMedicineMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrescriptionMedicineCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrescriptionMedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionMedicine to aggregate.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionMedicines
    **/
    _count?: true | PrescriptionMedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionMedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionMedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMedicineMaxAggregateInputType
  }

  export type GetPrescriptionMedicineAggregateType<T extends PrescriptionMedicineAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionMedicine[P]>
      : GetScalarType<T[P], AggregatePrescriptionMedicine[P]>
  }




  export type PrescriptionMedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionMedicineWhereInput
    orderBy?: PrescriptionMedicineOrderByWithAggregationInput | PrescriptionMedicineOrderByWithAggregationInput[]
    by: PrescriptionMedicineScalarFieldEnum[] | PrescriptionMedicineScalarFieldEnum
    having?: PrescriptionMedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionMedicineCountAggregateInputType | true
    _avg?: PrescriptionMedicineAvgAggregateInputType
    _sum?: PrescriptionMedicineSumAggregateInputType
    _min?: PrescriptionMedicineMinAggregateInputType
    _max?: PrescriptionMedicineMaxAggregateInputType
  }

  export type PrescriptionMedicineGroupByOutputType = {
    id: number
    prescriptionId: number
    medicineId: number
    dosage: string
    frequency: string
    duration: string
    instructions: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrescriptionMedicineCountAggregateOutputType | null
    _avg: PrescriptionMedicineAvgAggregateOutputType | null
    _sum: PrescriptionMedicineSumAggregateOutputType | null
    _min: PrescriptionMedicineMinAggregateOutputType | null
    _max: PrescriptionMedicineMaxAggregateOutputType | null
  }

  type GetPrescriptionMedicineGroupByPayload<T extends PrescriptionMedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionMedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionMedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionMedicineGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionMedicineGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionMedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionMedicine"]>

  export type PrescriptionMedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionMedicine"]>

  export type PrescriptionMedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionMedicine"]>

  export type PrescriptionMedicineSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrescriptionMedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "medicineId" | "dosage" | "frequency" | "duration" | "instructions" | "createdAt" | "updatedAt", ExtArgs["result"]["prescriptionMedicine"]>
  export type PrescriptionMedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type PrescriptionMedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type PrescriptionMedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $PrescriptionMedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionMedicine"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prescriptionId: number
      medicineId: number
      dosage: string
      frequency: string
      duration: string
      instructions: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prescriptionMedicine"]>
    composites: {}
  }

  type PrescriptionMedicineGetPayload<S extends boolean | null | undefined | PrescriptionMedicineDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionMedicinePayload, S>

  type PrescriptionMedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionMedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionMedicineCountAggregateInputType | true
    }

  export interface PrescriptionMedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionMedicine'], meta: { name: 'PrescriptionMedicine' } }
    /**
     * Find zero or one PrescriptionMedicine that matches the filter.
     * @param {PrescriptionMedicineFindUniqueArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionMedicineFindUniqueArgs>(args: SelectSubset<T, PrescriptionMedicineFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionMedicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionMedicineFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionMedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionMedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionMedicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineFindFirstArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionMedicineFindFirstArgs>(args?: SelectSubset<T, PrescriptionMedicineFindFirstArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionMedicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineFindFirstOrThrowArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionMedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionMedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionMedicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionMedicines
     * const prescriptionMedicines = await prisma.prescriptionMedicine.findMany()
     * 
     * // Get first 10 PrescriptionMedicines
     * const prescriptionMedicines = await prisma.prescriptionMedicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionMedicineWithIdOnly = await prisma.prescriptionMedicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionMedicineFindManyArgs>(args?: SelectSubset<T, PrescriptionMedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionMedicine.
     * @param {PrescriptionMedicineCreateArgs} args - Arguments to create a PrescriptionMedicine.
     * @example
     * // Create one PrescriptionMedicine
     * const PrescriptionMedicine = await prisma.prescriptionMedicine.create({
     *   data: {
     *     // ... data to create a PrescriptionMedicine
     *   }
     * })
     * 
     */
    create<T extends PrescriptionMedicineCreateArgs>(args: SelectSubset<T, PrescriptionMedicineCreateArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionMedicines.
     * @param {PrescriptionMedicineCreateManyArgs} args - Arguments to create many PrescriptionMedicines.
     * @example
     * // Create many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionMedicineCreateManyArgs>(args?: SelectSubset<T, PrescriptionMedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionMedicines and returns the data saved in the database.
     * @param {PrescriptionMedicineCreateManyAndReturnArgs} args - Arguments to create many PrescriptionMedicines.
     * @example
     * // Create many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionMedicines and only return the `id`
     * const prescriptionMedicineWithIdOnly = await prisma.prescriptionMedicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionMedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionMedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionMedicine.
     * @param {PrescriptionMedicineDeleteArgs} args - Arguments to delete one PrescriptionMedicine.
     * @example
     * // Delete one PrescriptionMedicine
     * const PrescriptionMedicine = await prisma.prescriptionMedicine.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionMedicine
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionMedicineDeleteArgs>(args: SelectSubset<T, PrescriptionMedicineDeleteArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionMedicine.
     * @param {PrescriptionMedicineUpdateArgs} args - Arguments to update one PrescriptionMedicine.
     * @example
     * // Update one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionMedicineUpdateArgs>(args: SelectSubset<T, PrescriptionMedicineUpdateArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionMedicines.
     * @param {PrescriptionMedicineDeleteManyArgs} args - Arguments to filter PrescriptionMedicines to delete.
     * @example
     * // Delete a few PrescriptionMedicines
     * const { count } = await prisma.prescriptionMedicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionMedicineDeleteManyArgs>(args?: SelectSubset<T, PrescriptionMedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionMedicineUpdateManyArgs>(args: SelectSubset<T, PrescriptionMedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionMedicines and returns the data updated in the database.
     * @param {PrescriptionMedicineUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionMedicines.
     * @example
     * // Update many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionMedicines and only return the `id`
     * const prescriptionMedicineWithIdOnly = await prisma.prescriptionMedicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionMedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionMedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionMedicine.
     * @param {PrescriptionMedicineUpsertArgs} args - Arguments to update or create a PrescriptionMedicine.
     * @example
     * // Update or create a PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.upsert({
     *   create: {
     *     // ... data to create a PrescriptionMedicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionMedicine we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionMedicineUpsertArgs>(args: SelectSubset<T, PrescriptionMedicineUpsertArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineCountArgs} args - Arguments to filter PrescriptionMedicines to count.
     * @example
     * // Count the number of PrescriptionMedicines
     * const count = await prisma.prescriptionMedicine.count({
     *   where: {
     *     // ... the filter for the PrescriptionMedicines we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionMedicineCountArgs>(
      args?: Subset<T, PrescriptionMedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionMedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionMedicineAggregateArgs>(args: Subset<T, PrescriptionMedicineAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionMedicineAggregateType<T>>

    /**
     * Group by PrescriptionMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionMedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionMedicineGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionMedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionMedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionMedicine model
   */
  readonly fields: PrescriptionMedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionMedicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionMedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionMedicine model
   */
  interface PrescriptionMedicineFieldRefs {
    readonly id: FieldRef<"PrescriptionMedicine", 'Int'>
    readonly prescriptionId: FieldRef<"PrescriptionMedicine", 'Int'>
    readonly medicineId: FieldRef<"PrescriptionMedicine", 'Int'>
    readonly dosage: FieldRef<"PrescriptionMedicine", 'String'>
    readonly frequency: FieldRef<"PrescriptionMedicine", 'String'>
    readonly duration: FieldRef<"PrescriptionMedicine", 'String'>
    readonly instructions: FieldRef<"PrescriptionMedicine", 'String'>
    readonly createdAt: FieldRef<"PrescriptionMedicine", 'DateTime'>
    readonly updatedAt: FieldRef<"PrescriptionMedicine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionMedicine findUnique
   */
  export type PrescriptionMedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine findUniqueOrThrow
   */
  export type PrescriptionMedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine findFirst
   */
  export type PrescriptionMedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionMedicines.
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionMedicines.
     */
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * PrescriptionMedicine findFirstOrThrow
   */
  export type PrescriptionMedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionMedicines.
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionMedicines.
     */
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * PrescriptionMedicine findMany
   */
  export type PrescriptionMedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicines to fetch.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionMedicines.
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * PrescriptionMedicine create
   */
  export type PrescriptionMedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionMedicine.
     */
    data: XOR<PrescriptionMedicineCreateInput, PrescriptionMedicineUncheckedCreateInput>
  }

  /**
   * PrescriptionMedicine createMany
   */
  export type PrescriptionMedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionMedicines.
     */
    data: PrescriptionMedicineCreateManyInput | PrescriptionMedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionMedicine createManyAndReturn
   */
  export type PrescriptionMedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionMedicines.
     */
    data: PrescriptionMedicineCreateManyInput | PrescriptionMedicineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionMedicine update
   */
  export type PrescriptionMedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionMedicine.
     */
    data: XOR<PrescriptionMedicineUpdateInput, PrescriptionMedicineUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionMedicine to update.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine updateMany
   */
  export type PrescriptionMedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionMedicines.
     */
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionMedicines to update
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * Limit how many PrescriptionMedicines to update.
     */
    limit?: number
  }

  /**
   * PrescriptionMedicine updateManyAndReturn
   */
  export type PrescriptionMedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionMedicines.
     */
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionMedicines to update
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * Limit how many PrescriptionMedicines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionMedicine upsert
   */
  export type PrescriptionMedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionMedicine to update in case it exists.
     */
    where: PrescriptionMedicineWhereUniqueInput
    /**
     * In case the PrescriptionMedicine found by the `where` argument doesn't exist, create a new PrescriptionMedicine with this data.
     */
    create: XOR<PrescriptionMedicineCreateInput, PrescriptionMedicineUncheckedCreateInput>
    /**
     * In case the PrescriptionMedicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionMedicineUpdateInput, PrescriptionMedicineUncheckedUpdateInput>
  }

  /**
   * PrescriptionMedicine delete
   */
  export type PrescriptionMedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionMedicine to delete.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine deleteMany
   */
  export type PrescriptionMedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionMedicines to delete
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * Limit how many PrescriptionMedicines to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionMedicine without action
   */
  export type PrescriptionMedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
  }


  /**
   * Model Medicine
   */

  export type AggregateMedicine = {
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  export type MedicineAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    stock: number | null
    reorderLevel: number | null
  }

  export type MedicineSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    stock: number | null
    reorderLevel: number | null
  }

  export type MedicineMinAggregateOutputType = {
    id: number | null
    name: string | null
    genericName: string | null
    category: string | null
    manufacturer: string | null
    description: string | null
    dosageForm: string | null
    strength: string | null
    price: Decimal | null
    stock: number | null
    reorderLevel: number | null
    expiryDate: Date | null
    batchNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineMaxAggregateOutputType = {
    id: number | null
    name: string | null
    genericName: string | null
    category: string | null
    manufacturer: string | null
    description: string | null
    dosageForm: string | null
    strength: string | null
    price: Decimal | null
    stock: number | null
    reorderLevel: number | null
    expiryDate: Date | null
    batchNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineCountAggregateOutputType = {
    id: number
    name: number
    genericName: number
    category: number
    manufacturer: number
    description: number
    dosageForm: number
    strength: number
    price: number
    stock: number
    reorderLevel: number
    expiryDate: number
    batchNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineAvgAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    reorderLevel?: true
  }

  export type MedicineSumAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    reorderLevel?: true
  }

  export type MedicineMinAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    category?: true
    manufacturer?: true
    description?: true
    dosageForm?: true
    strength?: true
    price?: true
    stock?: true
    reorderLevel?: true
    expiryDate?: true
    batchNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineMaxAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    category?: true
    manufacturer?: true
    description?: true
    dosageForm?: true
    strength?: true
    price?: true
    stock?: true
    reorderLevel?: true
    expiryDate?: true
    batchNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineCountAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    category?: true
    manufacturer?: true
    description?: true
    dosageForm?: true
    strength?: true
    price?: true
    stock?: true
    reorderLevel?: true
    expiryDate?: true
    batchNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicine to aggregate.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicines
    **/
    _count?: true | MedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineMaxAggregateInputType
  }

  export type GetMedicineAggregateType<T extends MedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicine[P]>
      : GetScalarType<T[P], AggregateMedicine[P]>
  }




  export type MedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineWhereInput
    orderBy?: MedicineOrderByWithAggregationInput | MedicineOrderByWithAggregationInput[]
    by: MedicineScalarFieldEnum[] | MedicineScalarFieldEnum
    having?: MedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineCountAggregateInputType | true
    _avg?: MedicineAvgAggregateInputType
    _sum?: MedicineSumAggregateInputType
    _min?: MedicineMinAggregateInputType
    _max?: MedicineMaxAggregateInputType
  }

  export type MedicineGroupByOutputType = {
    id: number
    name: string
    genericName: string | null
    category: string | null
    manufacturer: string | null
    description: string | null
    dosageForm: string | null
    strength: string | null
    price: Decimal
    stock: number
    reorderLevel: number
    expiryDate: Date | null
    batchNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  type GetMedicineGroupByPayload<T extends MedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineGroupByOutputType[P]>
        }
      >
    >


  export type MedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    category?: boolean
    manufacturer?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    price?: boolean
    stock?: boolean
    reorderLevel?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prescriptionMedicines?: boolean | Medicine$prescriptionMedicinesArgs<ExtArgs>
    inventoryLogs?: boolean | Medicine$inventoryLogsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    category?: boolean
    manufacturer?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    price?: boolean
    stock?: boolean
    reorderLevel?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    category?: boolean
    manufacturer?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    price?: boolean
    stock?: boolean
    reorderLevel?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectScalar = {
    id?: boolean
    name?: boolean
    genericName?: boolean
    category?: boolean
    manufacturer?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    price?: boolean
    stock?: boolean
    reorderLevel?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "genericName" | "category" | "manufacturer" | "description" | "dosageForm" | "strength" | "price" | "stock" | "reorderLevel" | "expiryDate" | "batchNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["medicine"]>
  export type MedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionMedicines?: boolean | Medicine$prescriptionMedicinesArgs<ExtArgs>
    inventoryLogs?: boolean | Medicine$inventoryLogsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicine"
    objects: {
      prescriptionMedicines: Prisma.$PrescriptionMedicinePayload<ExtArgs>[]
      inventoryLogs: Prisma.$InventoryLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      genericName: string | null
      category: string | null
      manufacturer: string | null
      description: string | null
      dosageForm: string | null
      strength: string | null
      price: Prisma.Decimal
      stock: number
      reorderLevel: number
      expiryDate: Date | null
      batchNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicine"]>
    composites: {}
  }

  type MedicineGetPayload<S extends boolean | null | undefined | MedicineDefaultArgs> = $Result.GetResult<Prisma.$MedicinePayload, S>

  type MedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineCountAggregateInputType | true
    }

  export interface MedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicine'], meta: { name: 'Medicine' } }
    /**
     * Find zero or one Medicine that matches the filter.
     * @param {MedicineFindUniqueArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineFindUniqueArgs>(args: SelectSubset<T, MedicineFindUniqueArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineFindUniqueOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineFindFirstArgs>(args?: SelectSubset<T, MedicineFindFirstArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicines
     * const medicines = await prisma.medicine.findMany()
     * 
     * // Get first 10 Medicines
     * const medicines = await prisma.medicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineWithIdOnly = await prisma.medicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineFindManyArgs>(args?: SelectSubset<T, MedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medicine.
     * @param {MedicineCreateArgs} args - Arguments to create a Medicine.
     * @example
     * // Create one Medicine
     * const Medicine = await prisma.medicine.create({
     *   data: {
     *     // ... data to create a Medicine
     *   }
     * })
     * 
     */
    create<T extends MedicineCreateArgs>(args: SelectSubset<T, MedicineCreateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicines.
     * @param {MedicineCreateManyArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineCreateManyArgs>(args?: SelectSubset<T, MedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicines and returns the data saved in the database.
     * @param {MedicineCreateManyAndReturnArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medicine.
     * @param {MedicineDeleteArgs} args - Arguments to delete one Medicine.
     * @example
     * // Delete one Medicine
     * const Medicine = await prisma.medicine.delete({
     *   where: {
     *     // ... filter to delete one Medicine
     *   }
     * })
     * 
     */
    delete<T extends MedicineDeleteArgs>(args: SelectSubset<T, MedicineDeleteArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medicine.
     * @param {MedicineUpdateArgs} args - Arguments to update one Medicine.
     * @example
     * // Update one Medicine
     * const medicine = await prisma.medicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineUpdateArgs>(args: SelectSubset<T, MedicineUpdateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicines.
     * @param {MedicineDeleteManyArgs} args - Arguments to filter Medicines to delete.
     * @example
     * // Delete a few Medicines
     * const { count } = await prisma.medicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineDeleteManyArgs>(args?: SelectSubset<T, MedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineUpdateManyArgs>(args: SelectSubset<T, MedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines and returns the data updated in the database.
     * @param {MedicineUpdateManyAndReturnArgs} args - Arguments to update many Medicines.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medicine.
     * @param {MedicineUpsertArgs} args - Arguments to update or create a Medicine.
     * @example
     * // Update or create a Medicine
     * const medicine = await prisma.medicine.upsert({
     *   create: {
     *     // ... data to create a Medicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicine we want to update
     *   }
     * })
     */
    upsert<T extends MedicineUpsertArgs>(args: SelectSubset<T, MedicineUpsertArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineCountArgs} args - Arguments to filter Medicines to count.
     * @example
     * // Count the number of Medicines
     * const count = await prisma.medicine.count({
     *   where: {
     *     // ... the filter for the Medicines we want to count
     *   }
     * })
    **/
    count<T extends MedicineCountArgs>(
      args?: Subset<T, MedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineAggregateArgs>(args: Subset<T, MedicineAggregateArgs>): Prisma.PrismaPromise<GetMedicineAggregateType<T>>

    /**
     * Group by Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineGroupByArgs['orderBy'] }
        : { orderBy?: MedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicine model
   */
  readonly fields: MedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescriptionMedicines<T extends Medicine$prescriptionMedicinesArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$prescriptionMedicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryLogs<T extends Medicine$inventoryLogsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$inventoryLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicine model
   */
  interface MedicineFieldRefs {
    readonly id: FieldRef<"Medicine", 'Int'>
    readonly name: FieldRef<"Medicine", 'String'>
    readonly genericName: FieldRef<"Medicine", 'String'>
    readonly category: FieldRef<"Medicine", 'String'>
    readonly manufacturer: FieldRef<"Medicine", 'String'>
    readonly description: FieldRef<"Medicine", 'String'>
    readonly dosageForm: FieldRef<"Medicine", 'String'>
    readonly strength: FieldRef<"Medicine", 'String'>
    readonly price: FieldRef<"Medicine", 'Decimal'>
    readonly stock: FieldRef<"Medicine", 'Int'>
    readonly reorderLevel: FieldRef<"Medicine", 'Int'>
    readonly expiryDate: FieldRef<"Medicine", 'DateTime'>
    readonly batchNumber: FieldRef<"Medicine", 'String'>
    readonly createdAt: FieldRef<"Medicine", 'DateTime'>
    readonly updatedAt: FieldRef<"Medicine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medicine findUnique
   */
  export type MedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findUniqueOrThrow
   */
  export type MedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findFirst
   */
  export type MedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findFirstOrThrow
   */
  export type MedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findMany
   */
  export type MedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicines to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine create
   */
  export type MedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicine.
     */
    data: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
  }

  /**
   * Medicine createMany
   */
  export type MedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicine createManyAndReturn
   */
  export type MedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicine update
   */
  export type MedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicine.
     */
    data: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
    /**
     * Choose, which Medicine to update.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine updateMany
   */
  export type MedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to update.
     */
    limit?: number
  }

  /**
   * Medicine updateManyAndReturn
   */
  export type MedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to update.
     */
    limit?: number
  }

  /**
   * Medicine upsert
   */
  export type MedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicine to update in case it exists.
     */
    where: MedicineWhereUniqueInput
    /**
     * In case the Medicine found by the `where` argument doesn't exist, create a new Medicine with this data.
     */
    create: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
    /**
     * In case the Medicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
  }

  /**
   * Medicine delete
   */
  export type MedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter which Medicine to delete.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine deleteMany
   */
  export type MedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicines to delete
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to delete.
     */
    limit?: number
  }

  /**
   * Medicine.prescriptionMedicines
   */
  export type Medicine$prescriptionMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    where?: PrescriptionMedicineWhereInput
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    cursor?: PrescriptionMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * Medicine.inventoryLogs
   */
  export type Medicine$inventoryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    where?: InventoryLogWhereInput
    orderBy?: InventoryLogOrderByWithRelationInput | InventoryLogOrderByWithRelationInput[]
    cursor?: InventoryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLogScalarFieldEnum | InventoryLogScalarFieldEnum[]
  }

  /**
   * Medicine without action
   */
  export type MedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
  }


  /**
   * Model InventoryLog
   */

  export type AggregateInventoryLog = {
    _count: InventoryLogCountAggregateOutputType | null
    _avg: InventoryLogAvgAggregateOutputType | null
    _sum: InventoryLogSumAggregateOutputType | null
    _min: InventoryLogMinAggregateOutputType | null
    _max: InventoryLogMaxAggregateOutputType | null
  }

  export type InventoryLogAvgAggregateOutputType = {
    id: number | null
    medicineId: number | null
    quantity: number | null
  }

  export type InventoryLogSumAggregateOutputType = {
    id: number | null
    medicineId: number | null
    quantity: number | null
  }

  export type InventoryLogMinAggregateOutputType = {
    id: number | null
    medicineId: number | null
    quantity: number | null
    type: string | null
    reason: string | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryLogMaxAggregateOutputType = {
    id: number | null
    medicineId: number | null
    quantity: number | null
    type: string | null
    reason: string | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryLogCountAggregateOutputType = {
    id: number
    medicineId: number
    quantity: number
    type: number
    reason: number
    referenceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryLogAvgAggregateInputType = {
    id?: true
    medicineId?: true
    quantity?: true
  }

  export type InventoryLogSumAggregateInputType = {
    id?: true
    medicineId?: true
    quantity?: true
  }

  export type InventoryLogMinAggregateInputType = {
    id?: true
    medicineId?: true
    quantity?: true
    type?: true
    reason?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryLogMaxAggregateInputType = {
    id?: true
    medicineId?: true
    quantity?: true
    type?: true
    reason?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryLogCountAggregateInputType = {
    id?: true
    medicineId?: true
    quantity?: true
    type?: true
    reason?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryLog to aggregate.
     */
    where?: InventoryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLogs to fetch.
     */
    orderBy?: InventoryLogOrderByWithRelationInput | InventoryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryLogs
    **/
    _count?: true | InventoryLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryLogMaxAggregateInputType
  }

  export type GetInventoryLogAggregateType<T extends InventoryLogAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryLog[P]>
      : GetScalarType<T[P], AggregateInventoryLog[P]>
  }




  export type InventoryLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLogWhereInput
    orderBy?: InventoryLogOrderByWithAggregationInput | InventoryLogOrderByWithAggregationInput[]
    by: InventoryLogScalarFieldEnum[] | InventoryLogScalarFieldEnum
    having?: InventoryLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryLogCountAggregateInputType | true
    _avg?: InventoryLogAvgAggregateInputType
    _sum?: InventoryLogSumAggregateInputType
    _min?: InventoryLogMinAggregateInputType
    _max?: InventoryLogMaxAggregateInputType
  }

  export type InventoryLogGroupByOutputType = {
    id: number
    medicineId: number
    quantity: number
    type: string
    reason: string | null
    referenceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryLogCountAggregateOutputType | null
    _avg: InventoryLogAvgAggregateOutputType | null
    _sum: InventoryLogSumAggregateOutputType | null
    _min: InventoryLogMinAggregateOutputType | null
    _max: InventoryLogMaxAggregateOutputType | null
  }

  type GetInventoryLogGroupByPayload<T extends InventoryLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryLogGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryLogGroupByOutputType[P]>
        }
      >
    >


  export type InventoryLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    quantity?: boolean
    type?: boolean
    reason?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLog"]>

  export type InventoryLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    quantity?: boolean
    type?: boolean
    reason?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLog"]>

  export type InventoryLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicineId?: boolean
    quantity?: boolean
    type?: boolean
    reason?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLog"]>

  export type InventoryLogSelectScalar = {
    id?: boolean
    medicineId?: boolean
    quantity?: boolean
    type?: boolean
    reason?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicineId" | "quantity" | "type" | "reason" | "referenceId" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryLog"]>
  export type InventoryLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type InventoryLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type InventoryLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $InventoryLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryLog"
    objects: {
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medicineId: number
      quantity: number
      type: string
      reason: string | null
      referenceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryLog"]>
    composites: {}
  }

  type InventoryLogGetPayload<S extends boolean | null | undefined | InventoryLogDefaultArgs> = $Result.GetResult<Prisma.$InventoryLogPayload, S>

  type InventoryLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryLogCountAggregateInputType | true
    }

  export interface InventoryLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryLog'], meta: { name: 'InventoryLog' } }
    /**
     * Find zero or one InventoryLog that matches the filter.
     * @param {InventoryLogFindUniqueArgs} args - Arguments to find a InventoryLog
     * @example
     * // Get one InventoryLog
     * const inventoryLog = await prisma.inventoryLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryLogFindUniqueArgs>(args: SelectSubset<T, InventoryLogFindUniqueArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryLogFindUniqueOrThrowArgs} args - Arguments to find a InventoryLog
     * @example
     * // Get one InventoryLog
     * const inventoryLog = await prisma.inventoryLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryLogFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogFindFirstArgs} args - Arguments to find a InventoryLog
     * @example
     * // Get one InventoryLog
     * const inventoryLog = await prisma.inventoryLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryLogFindFirstArgs>(args?: SelectSubset<T, InventoryLogFindFirstArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogFindFirstOrThrowArgs} args - Arguments to find a InventoryLog
     * @example
     * // Get one InventoryLog
     * const inventoryLog = await prisma.inventoryLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryLogFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryLogs
     * const inventoryLogs = await prisma.inventoryLog.findMany()
     * 
     * // Get first 10 InventoryLogs
     * const inventoryLogs = await prisma.inventoryLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryLogWithIdOnly = await prisma.inventoryLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryLogFindManyArgs>(args?: SelectSubset<T, InventoryLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryLog.
     * @param {InventoryLogCreateArgs} args - Arguments to create a InventoryLog.
     * @example
     * // Create one InventoryLog
     * const InventoryLog = await prisma.inventoryLog.create({
     *   data: {
     *     // ... data to create a InventoryLog
     *   }
     * })
     * 
     */
    create<T extends InventoryLogCreateArgs>(args: SelectSubset<T, InventoryLogCreateArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryLogs.
     * @param {InventoryLogCreateManyArgs} args - Arguments to create many InventoryLogs.
     * @example
     * // Create many InventoryLogs
     * const inventoryLog = await prisma.inventoryLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryLogCreateManyArgs>(args?: SelectSubset<T, InventoryLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryLogs and returns the data saved in the database.
     * @param {InventoryLogCreateManyAndReturnArgs} args - Arguments to create many InventoryLogs.
     * @example
     * // Create many InventoryLogs
     * const inventoryLog = await prisma.inventoryLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryLogs and only return the `id`
     * const inventoryLogWithIdOnly = await prisma.inventoryLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryLogCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryLog.
     * @param {InventoryLogDeleteArgs} args - Arguments to delete one InventoryLog.
     * @example
     * // Delete one InventoryLog
     * const InventoryLog = await prisma.inventoryLog.delete({
     *   where: {
     *     // ... filter to delete one InventoryLog
     *   }
     * })
     * 
     */
    delete<T extends InventoryLogDeleteArgs>(args: SelectSubset<T, InventoryLogDeleteArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryLog.
     * @param {InventoryLogUpdateArgs} args - Arguments to update one InventoryLog.
     * @example
     * // Update one InventoryLog
     * const inventoryLog = await prisma.inventoryLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryLogUpdateArgs>(args: SelectSubset<T, InventoryLogUpdateArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryLogs.
     * @param {InventoryLogDeleteManyArgs} args - Arguments to filter InventoryLogs to delete.
     * @example
     * // Delete a few InventoryLogs
     * const { count } = await prisma.inventoryLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryLogDeleteManyArgs>(args?: SelectSubset<T, InventoryLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryLogs
     * const inventoryLog = await prisma.inventoryLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryLogUpdateManyArgs>(args: SelectSubset<T, InventoryLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryLogs and returns the data updated in the database.
     * @param {InventoryLogUpdateManyAndReturnArgs} args - Arguments to update many InventoryLogs.
     * @example
     * // Update many InventoryLogs
     * const inventoryLog = await prisma.inventoryLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryLogs and only return the `id`
     * const inventoryLogWithIdOnly = await prisma.inventoryLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryLogUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryLog.
     * @param {InventoryLogUpsertArgs} args - Arguments to update or create a InventoryLog.
     * @example
     * // Update or create a InventoryLog
     * const inventoryLog = await prisma.inventoryLog.upsert({
     *   create: {
     *     // ... data to create a InventoryLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryLog we want to update
     *   }
     * })
     */
    upsert<T extends InventoryLogUpsertArgs>(args: SelectSubset<T, InventoryLogUpsertArgs<ExtArgs>>): Prisma__InventoryLogClient<$Result.GetResult<Prisma.$InventoryLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogCountArgs} args - Arguments to filter InventoryLogs to count.
     * @example
     * // Count the number of InventoryLogs
     * const count = await prisma.inventoryLog.count({
     *   where: {
     *     // ... the filter for the InventoryLogs we want to count
     *   }
     * })
    **/
    count<T extends InventoryLogCountArgs>(
      args?: Subset<T, InventoryLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryLogAggregateArgs>(args: Subset<T, InventoryLogAggregateArgs>): Prisma.PrismaPromise<GetInventoryLogAggregateType<T>>

    /**
     * Group by InventoryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryLogGroupByArgs['orderBy'] }
        : { orderBy?: InventoryLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryLog model
   */
  readonly fields: InventoryLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryLog model
   */
  interface InventoryLogFieldRefs {
    readonly id: FieldRef<"InventoryLog", 'Int'>
    readonly medicineId: FieldRef<"InventoryLog", 'Int'>
    readonly quantity: FieldRef<"InventoryLog", 'Int'>
    readonly type: FieldRef<"InventoryLog", 'String'>
    readonly reason: FieldRef<"InventoryLog", 'String'>
    readonly referenceId: FieldRef<"InventoryLog", 'String'>
    readonly createdAt: FieldRef<"InventoryLog", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryLog findUnique
   */
  export type InventoryLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLog to fetch.
     */
    where: InventoryLogWhereUniqueInput
  }

  /**
   * InventoryLog findUniqueOrThrow
   */
  export type InventoryLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLog to fetch.
     */
    where: InventoryLogWhereUniqueInput
  }

  /**
   * InventoryLog findFirst
   */
  export type InventoryLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLog to fetch.
     */
    where?: InventoryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLogs to fetch.
     */
    orderBy?: InventoryLogOrderByWithRelationInput | InventoryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryLogs.
     */
    cursor?: InventoryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryLogs.
     */
    distinct?: InventoryLogScalarFieldEnum | InventoryLogScalarFieldEnum[]
  }

  /**
   * InventoryLog findFirstOrThrow
   */
  export type InventoryLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLog to fetch.
     */
    where?: InventoryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLogs to fetch.
     */
    orderBy?: InventoryLogOrderByWithRelationInput | InventoryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryLogs.
     */
    cursor?: InventoryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryLogs.
     */
    distinct?: InventoryLogScalarFieldEnum | InventoryLogScalarFieldEnum[]
  }

  /**
   * InventoryLog findMany
   */
  export type InventoryLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLogs to fetch.
     */
    where?: InventoryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLogs to fetch.
     */
    orderBy?: InventoryLogOrderByWithRelationInput | InventoryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryLogs.
     */
    cursor?: InventoryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLogs.
     */
    skip?: number
    distinct?: InventoryLogScalarFieldEnum | InventoryLogScalarFieldEnum[]
  }

  /**
   * InventoryLog create
   */
  export type InventoryLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryLog.
     */
    data: XOR<InventoryLogCreateInput, InventoryLogUncheckedCreateInput>
  }

  /**
   * InventoryLog createMany
   */
  export type InventoryLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryLogs.
     */
    data: InventoryLogCreateManyInput | InventoryLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryLog createManyAndReturn
   */
  export type InventoryLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryLogs.
     */
    data: InventoryLogCreateManyInput | InventoryLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryLog update
   */
  export type InventoryLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryLog.
     */
    data: XOR<InventoryLogUpdateInput, InventoryLogUncheckedUpdateInput>
    /**
     * Choose, which InventoryLog to update.
     */
    where: InventoryLogWhereUniqueInput
  }

  /**
   * InventoryLog updateMany
   */
  export type InventoryLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryLogs.
     */
    data: XOR<InventoryLogUpdateManyMutationInput, InventoryLogUncheckedUpdateManyInput>
    /**
     * Filter which InventoryLogs to update
     */
    where?: InventoryLogWhereInput
    /**
     * Limit how many InventoryLogs to update.
     */
    limit?: number
  }

  /**
   * InventoryLog updateManyAndReturn
   */
  export type InventoryLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * The data used to update InventoryLogs.
     */
    data: XOR<InventoryLogUpdateManyMutationInput, InventoryLogUncheckedUpdateManyInput>
    /**
     * Filter which InventoryLogs to update
     */
    where?: InventoryLogWhereInput
    /**
     * Limit how many InventoryLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryLog upsert
   */
  export type InventoryLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryLog to update in case it exists.
     */
    where: InventoryLogWhereUniqueInput
    /**
     * In case the InventoryLog found by the `where` argument doesn't exist, create a new InventoryLog with this data.
     */
    create: XOR<InventoryLogCreateInput, InventoryLogUncheckedCreateInput>
    /**
     * In case the InventoryLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryLogUpdateInput, InventoryLogUncheckedUpdateInput>
  }

  /**
   * InventoryLog delete
   */
  export type InventoryLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
    /**
     * Filter which InventoryLog to delete.
     */
    where: InventoryLogWhereUniqueInput
  }

  /**
   * InventoryLog deleteMany
   */
  export type InventoryLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryLogs to delete
     */
    where?: InventoryLogWhereInput
    /**
     * Limit how many InventoryLogs to delete.
     */
    limit?: number
  }

  /**
   * InventoryLog without action
   */
  export type InventoryLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLog
     */
    select?: InventoryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryLog
     */
    omit?: InventoryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLogInclude<ExtArgs> | null
  }


  /**
   * Model LabReport
   */

  export type AggregateLabReport = {
    _count: LabReportCountAggregateOutputType | null
    _avg: LabReportAvgAggregateOutputType | null
    _sum: LabReportSumAggregateOutputType | null
    _min: LabReportMinAggregateOutputType | null
    _max: LabReportMaxAggregateOutputType | null
  }

  export type LabReportAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type LabReportSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type LabReportMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
    testDate: Date | null
    reportDate: Date | null
    testType: string | null
    testResult: string | null
    normalRange: string | null
    notes: string | null
    attachmentUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabReportMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
    testDate: Date | null
    reportDate: Date | null
    testType: string | null
    testResult: string | null
    normalRange: string | null
    notes: string | null
    attachmentUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabReportCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentId: number
    testDate: number
    reportDate: number
    testType: number
    testResult: number
    normalRange: number
    notes: number
    attachmentUrl: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabReportAvgAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
  }

  export type LabReportSumAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
  }

  export type LabReportMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    testDate?: true
    reportDate?: true
    testType?: true
    testResult?: true
    normalRange?: true
    notes?: true
    attachmentUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabReportMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    testDate?: true
    reportDate?: true
    testType?: true
    testResult?: true
    normalRange?: true
    notes?: true
    attachmentUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabReportCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    testDate?: true
    reportDate?: true
    testType?: true
    testResult?: true
    normalRange?: true
    notes?: true
    attachmentUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabReport to aggregate.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabReports
    **/
    _count?: true | LabReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabReportMaxAggregateInputType
  }

  export type GetLabReportAggregateType<T extends LabReportAggregateArgs> = {
        [P in keyof T & keyof AggregateLabReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabReport[P]>
      : GetScalarType<T[P], AggregateLabReport[P]>
  }




  export type LabReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabReportWhereInput
    orderBy?: LabReportOrderByWithAggregationInput | LabReportOrderByWithAggregationInput[]
    by: LabReportScalarFieldEnum[] | LabReportScalarFieldEnum
    having?: LabReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabReportCountAggregateInputType | true
    _avg?: LabReportAvgAggregateInputType
    _sum?: LabReportSumAggregateInputType
    _min?: LabReportMinAggregateInputType
    _max?: LabReportMaxAggregateInputType
  }

  export type LabReportGroupByOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentId: number | null
    testDate: Date
    reportDate: Date | null
    testType: string
    testResult: string | null
    normalRange: string | null
    notes: string | null
    attachmentUrl: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LabReportCountAggregateOutputType | null
    _avg: LabReportAvgAggregateOutputType | null
    _sum: LabReportSumAggregateOutputType | null
    _min: LabReportMinAggregateOutputType | null
    _max: LabReportMaxAggregateOutputType | null
  }

  type GetLabReportGroupByPayload<T extends LabReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabReportGroupByOutputType[P]>
            : GetScalarType<T[P], LabReportGroupByOutputType[P]>
        }
      >
    >


  export type LabReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    testResult?: boolean
    normalRange?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | LabReport$appointmentArgs<ExtArgs>
    invoiceItems?: boolean | LabReport$invoiceItemsArgs<ExtArgs>
    _count?: boolean | LabReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labReport"]>

  export type LabReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    testResult?: boolean
    normalRange?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | LabReport$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["labReport"]>

  export type LabReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    testResult?: boolean
    normalRange?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | LabReport$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["labReport"]>

  export type LabReportSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    testResult?: boolean
    normalRange?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "appointmentId" | "testDate" | "reportDate" | "testType" | "testResult" | "normalRange" | "notes" | "attachmentUrl" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["labReport"]>
  export type LabReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | LabReport$appointmentArgs<ExtArgs>
    invoiceItems?: boolean | LabReport$invoiceItemsArgs<ExtArgs>
    _count?: boolean | LabReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | LabReport$appointmentArgs<ExtArgs>
  }
  export type LabReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | LabReport$appointmentArgs<ExtArgs>
  }

  export type $LabReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabReport"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      doctorId: number
      appointmentId: number | null
      testDate: Date
      reportDate: Date | null
      testType: string
      testResult: string | null
      normalRange: string | null
      notes: string | null
      attachmentUrl: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["labReport"]>
    composites: {}
  }

  type LabReportGetPayload<S extends boolean | null | undefined | LabReportDefaultArgs> = $Result.GetResult<Prisma.$LabReportPayload, S>

  type LabReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabReportCountAggregateInputType | true
    }

  export interface LabReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabReport'], meta: { name: 'LabReport' } }
    /**
     * Find zero or one LabReport that matches the filter.
     * @param {LabReportFindUniqueArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabReportFindUniqueArgs>(args: SelectSubset<T, LabReportFindUniqueArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabReportFindUniqueOrThrowArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabReportFindUniqueOrThrowArgs>(args: SelectSubset<T, LabReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportFindFirstArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabReportFindFirstArgs>(args?: SelectSubset<T, LabReportFindFirstArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportFindFirstOrThrowArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabReportFindFirstOrThrowArgs>(args?: SelectSubset<T, LabReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabReports
     * const labReports = await prisma.labReport.findMany()
     * 
     * // Get first 10 LabReports
     * const labReports = await prisma.labReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labReportWithIdOnly = await prisma.labReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabReportFindManyArgs>(args?: SelectSubset<T, LabReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabReport.
     * @param {LabReportCreateArgs} args - Arguments to create a LabReport.
     * @example
     * // Create one LabReport
     * const LabReport = await prisma.labReport.create({
     *   data: {
     *     // ... data to create a LabReport
     *   }
     * })
     * 
     */
    create<T extends LabReportCreateArgs>(args: SelectSubset<T, LabReportCreateArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabReports.
     * @param {LabReportCreateManyArgs} args - Arguments to create many LabReports.
     * @example
     * // Create many LabReports
     * const labReport = await prisma.labReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabReportCreateManyArgs>(args?: SelectSubset<T, LabReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabReports and returns the data saved in the database.
     * @param {LabReportCreateManyAndReturnArgs} args - Arguments to create many LabReports.
     * @example
     * // Create many LabReports
     * const labReport = await prisma.labReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabReports and only return the `id`
     * const labReportWithIdOnly = await prisma.labReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabReportCreateManyAndReturnArgs>(args?: SelectSubset<T, LabReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabReport.
     * @param {LabReportDeleteArgs} args - Arguments to delete one LabReport.
     * @example
     * // Delete one LabReport
     * const LabReport = await prisma.labReport.delete({
     *   where: {
     *     // ... filter to delete one LabReport
     *   }
     * })
     * 
     */
    delete<T extends LabReportDeleteArgs>(args: SelectSubset<T, LabReportDeleteArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabReport.
     * @param {LabReportUpdateArgs} args - Arguments to update one LabReport.
     * @example
     * // Update one LabReport
     * const labReport = await prisma.labReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabReportUpdateArgs>(args: SelectSubset<T, LabReportUpdateArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabReports.
     * @param {LabReportDeleteManyArgs} args - Arguments to filter LabReports to delete.
     * @example
     * // Delete a few LabReports
     * const { count } = await prisma.labReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabReportDeleteManyArgs>(args?: SelectSubset<T, LabReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabReports
     * const labReport = await prisma.labReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabReportUpdateManyArgs>(args: SelectSubset<T, LabReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabReports and returns the data updated in the database.
     * @param {LabReportUpdateManyAndReturnArgs} args - Arguments to update many LabReports.
     * @example
     * // Update many LabReports
     * const labReport = await prisma.labReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabReports and only return the `id`
     * const labReportWithIdOnly = await prisma.labReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabReportUpdateManyAndReturnArgs>(args: SelectSubset<T, LabReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabReport.
     * @param {LabReportUpsertArgs} args - Arguments to update or create a LabReport.
     * @example
     * // Update or create a LabReport
     * const labReport = await prisma.labReport.upsert({
     *   create: {
     *     // ... data to create a LabReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabReport we want to update
     *   }
     * })
     */
    upsert<T extends LabReportUpsertArgs>(args: SelectSubset<T, LabReportUpsertArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportCountArgs} args - Arguments to filter LabReports to count.
     * @example
     * // Count the number of LabReports
     * const count = await prisma.labReport.count({
     *   where: {
     *     // ... the filter for the LabReports we want to count
     *   }
     * })
    **/
    count<T extends LabReportCountArgs>(
      args?: Subset<T, LabReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabReportAggregateArgs>(args: Subset<T, LabReportAggregateArgs>): Prisma.PrismaPromise<GetLabReportAggregateType<T>>

    /**
     * Group by LabReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabReportGroupByArgs['orderBy'] }
        : { orderBy?: LabReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabReport model
   */
  readonly fields: LabReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends LabReport$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, LabReport$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoiceItems<T extends LabReport$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, LabReport$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabReport model
   */
  interface LabReportFieldRefs {
    readonly id: FieldRef<"LabReport", 'Int'>
    readonly patientId: FieldRef<"LabReport", 'Int'>
    readonly doctorId: FieldRef<"LabReport", 'Int'>
    readonly appointmentId: FieldRef<"LabReport", 'Int'>
    readonly testDate: FieldRef<"LabReport", 'DateTime'>
    readonly reportDate: FieldRef<"LabReport", 'DateTime'>
    readonly testType: FieldRef<"LabReport", 'String'>
    readonly testResult: FieldRef<"LabReport", 'String'>
    readonly normalRange: FieldRef<"LabReport", 'String'>
    readonly notes: FieldRef<"LabReport", 'String'>
    readonly attachmentUrl: FieldRef<"LabReport", 'String'>
    readonly status: FieldRef<"LabReport", 'String'>
    readonly createdAt: FieldRef<"LabReport", 'DateTime'>
    readonly updatedAt: FieldRef<"LabReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabReport findUnique
   */
  export type LabReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport findUniqueOrThrow
   */
  export type LabReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport findFirst
   */
  export type LabReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabReports.
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabReports.
     */
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * LabReport findFirstOrThrow
   */
  export type LabReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabReports.
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabReports.
     */
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * LabReport findMany
   */
  export type LabReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReports to fetch.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabReports.
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * LabReport create
   */
  export type LabReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * The data needed to create a LabReport.
     */
    data: XOR<LabReportCreateInput, LabReportUncheckedCreateInput>
  }

  /**
   * LabReport createMany
   */
  export type LabReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabReports.
     */
    data: LabReportCreateManyInput | LabReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabReport createManyAndReturn
   */
  export type LabReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * The data used to create many LabReports.
     */
    data: LabReportCreateManyInput | LabReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabReport update
   */
  export type LabReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * The data needed to update a LabReport.
     */
    data: XOR<LabReportUpdateInput, LabReportUncheckedUpdateInput>
    /**
     * Choose, which LabReport to update.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport updateMany
   */
  export type LabReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabReports.
     */
    data: XOR<LabReportUpdateManyMutationInput, LabReportUncheckedUpdateManyInput>
    /**
     * Filter which LabReports to update
     */
    where?: LabReportWhereInput
    /**
     * Limit how many LabReports to update.
     */
    limit?: number
  }

  /**
   * LabReport updateManyAndReturn
   */
  export type LabReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * The data used to update LabReports.
     */
    data: XOR<LabReportUpdateManyMutationInput, LabReportUncheckedUpdateManyInput>
    /**
     * Filter which LabReports to update
     */
    where?: LabReportWhereInput
    /**
     * Limit how many LabReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabReport upsert
   */
  export type LabReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * The filter to search for the LabReport to update in case it exists.
     */
    where: LabReportWhereUniqueInput
    /**
     * In case the LabReport found by the `where` argument doesn't exist, create a new LabReport with this data.
     */
    create: XOR<LabReportCreateInput, LabReportUncheckedCreateInput>
    /**
     * In case the LabReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabReportUpdateInput, LabReportUncheckedUpdateInput>
  }

  /**
   * LabReport delete
   */
  export type LabReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter which LabReport to delete.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport deleteMany
   */
  export type LabReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabReports to delete
     */
    where?: LabReportWhereInput
    /**
     * Limit how many LabReports to delete.
     */
    limit?: number
  }

  /**
   * LabReport.appointment
   */
  export type LabReport$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * LabReport.invoiceItems
   */
  export type LabReport$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * LabReport without action
   */
  export type LabReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
  }


  /**
   * Model RadiologyReport
   */

  export type AggregateRadiologyReport = {
    _count: RadiologyReportCountAggregateOutputType | null
    _avg: RadiologyReportAvgAggregateOutputType | null
    _sum: RadiologyReportSumAggregateOutputType | null
    _min: RadiologyReportMinAggregateOutputType | null
    _max: RadiologyReportMaxAggregateOutputType | null
  }

  export type RadiologyReportAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type RadiologyReportSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type RadiologyReportMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
    testDate: Date | null
    reportDate: Date | null
    testType: string | null
    findings: string | null
    impression: string | null
    notes: string | null
    attachmentUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadiologyReportMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    appointmentId: number | null
    testDate: Date | null
    reportDate: Date | null
    testType: string | null
    findings: string | null
    impression: string | null
    notes: string | null
    attachmentUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadiologyReportCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentId: number
    testDate: number
    reportDate: number
    testType: number
    findings: number
    impression: number
    notes: number
    attachmentUrl: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RadiologyReportAvgAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
  }

  export type RadiologyReportSumAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
  }

  export type RadiologyReportMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    testDate?: true
    reportDate?: true
    testType?: true
    findings?: true
    impression?: true
    notes?: true
    attachmentUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadiologyReportMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    testDate?: true
    reportDate?: true
    testType?: true
    findings?: true
    impression?: true
    notes?: true
    attachmentUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadiologyReportCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    appointmentId?: true
    testDate?: true
    reportDate?: true
    testType?: true
    findings?: true
    impression?: true
    notes?: true
    attachmentUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RadiologyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiologyReport to aggregate.
     */
    where?: RadiologyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyReports to fetch.
     */
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RadiologyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RadiologyReports
    **/
    _count?: true | RadiologyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RadiologyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RadiologyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RadiologyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RadiologyReportMaxAggregateInputType
  }

  export type GetRadiologyReportAggregateType<T extends RadiologyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateRadiologyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRadiologyReport[P]>
      : GetScalarType<T[P], AggregateRadiologyReport[P]>
  }




  export type RadiologyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyReportWhereInput
    orderBy?: RadiologyReportOrderByWithAggregationInput | RadiologyReportOrderByWithAggregationInput[]
    by: RadiologyReportScalarFieldEnum[] | RadiologyReportScalarFieldEnum
    having?: RadiologyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RadiologyReportCountAggregateInputType | true
    _avg?: RadiologyReportAvgAggregateInputType
    _sum?: RadiologyReportSumAggregateInputType
    _min?: RadiologyReportMinAggregateInputType
    _max?: RadiologyReportMaxAggregateInputType
  }

  export type RadiologyReportGroupByOutputType = {
    id: number
    patientId: number
    doctorId: number
    appointmentId: number | null
    testDate: Date
    reportDate: Date | null
    testType: string
    findings: string | null
    impression: string | null
    notes: string | null
    attachmentUrl: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: RadiologyReportCountAggregateOutputType | null
    _avg: RadiologyReportAvgAggregateOutputType | null
    _sum: RadiologyReportSumAggregateOutputType | null
    _min: RadiologyReportMinAggregateOutputType | null
    _max: RadiologyReportMaxAggregateOutputType | null
  }

  type GetRadiologyReportGroupByPayload<T extends RadiologyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RadiologyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RadiologyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RadiologyReportGroupByOutputType[P]>
            : GetScalarType<T[P], RadiologyReportGroupByOutputType[P]>
        }
      >
    >


  export type RadiologyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    findings?: boolean
    impression?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | RadiologyReport$appointmentArgs<ExtArgs>
    invoiceItems?: boolean | RadiologyReport$invoiceItemsArgs<ExtArgs>
    _count?: boolean | RadiologyReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["radiologyReport"]>

  export type RadiologyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    findings?: boolean
    impression?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | RadiologyReport$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["radiologyReport"]>

  export type RadiologyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    findings?: boolean
    impression?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | RadiologyReport$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["radiologyReport"]>

  export type RadiologyReportSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    testDate?: boolean
    reportDate?: boolean
    testType?: boolean
    findings?: boolean
    impression?: boolean
    notes?: boolean
    attachmentUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RadiologyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "appointmentId" | "testDate" | "reportDate" | "testType" | "findings" | "impression" | "notes" | "attachmentUrl" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["radiologyReport"]>
  export type RadiologyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | RadiologyReport$appointmentArgs<ExtArgs>
    invoiceItems?: boolean | RadiologyReport$invoiceItemsArgs<ExtArgs>
    _count?: boolean | RadiologyReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RadiologyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | RadiologyReport$appointmentArgs<ExtArgs>
  }
  export type RadiologyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    appointment?: boolean | RadiologyReport$appointmentArgs<ExtArgs>
  }

  export type $RadiologyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RadiologyReport"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      doctorId: number
      appointmentId: number | null
      testDate: Date
      reportDate: Date | null
      testType: string
      findings: string | null
      impression: string | null
      notes: string | null
      attachmentUrl: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["radiologyReport"]>
    composites: {}
  }

  type RadiologyReportGetPayload<S extends boolean | null | undefined | RadiologyReportDefaultArgs> = $Result.GetResult<Prisma.$RadiologyReportPayload, S>

  type RadiologyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RadiologyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RadiologyReportCountAggregateInputType | true
    }

  export interface RadiologyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RadiologyReport'], meta: { name: 'RadiologyReport' } }
    /**
     * Find zero or one RadiologyReport that matches the filter.
     * @param {RadiologyReportFindUniqueArgs} args - Arguments to find a RadiologyReport
     * @example
     * // Get one RadiologyReport
     * const radiologyReport = await prisma.radiologyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RadiologyReportFindUniqueArgs>(args: SelectSubset<T, RadiologyReportFindUniqueArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RadiologyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RadiologyReportFindUniqueOrThrowArgs} args - Arguments to find a RadiologyReport
     * @example
     * // Get one RadiologyReport
     * const radiologyReport = await prisma.radiologyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RadiologyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, RadiologyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiologyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportFindFirstArgs} args - Arguments to find a RadiologyReport
     * @example
     * // Get one RadiologyReport
     * const radiologyReport = await prisma.radiologyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RadiologyReportFindFirstArgs>(args?: SelectSubset<T, RadiologyReportFindFirstArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiologyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportFindFirstOrThrowArgs} args - Arguments to find a RadiologyReport
     * @example
     * // Get one RadiologyReport
     * const radiologyReport = await prisma.radiologyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RadiologyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, RadiologyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RadiologyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RadiologyReports
     * const radiologyReports = await prisma.radiologyReport.findMany()
     * 
     * // Get first 10 RadiologyReports
     * const radiologyReports = await prisma.radiologyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const radiologyReportWithIdOnly = await prisma.radiologyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RadiologyReportFindManyArgs>(args?: SelectSubset<T, RadiologyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RadiologyReport.
     * @param {RadiologyReportCreateArgs} args - Arguments to create a RadiologyReport.
     * @example
     * // Create one RadiologyReport
     * const RadiologyReport = await prisma.radiologyReport.create({
     *   data: {
     *     // ... data to create a RadiologyReport
     *   }
     * })
     * 
     */
    create<T extends RadiologyReportCreateArgs>(args: SelectSubset<T, RadiologyReportCreateArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RadiologyReports.
     * @param {RadiologyReportCreateManyArgs} args - Arguments to create many RadiologyReports.
     * @example
     * // Create many RadiologyReports
     * const radiologyReport = await prisma.radiologyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RadiologyReportCreateManyArgs>(args?: SelectSubset<T, RadiologyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RadiologyReports and returns the data saved in the database.
     * @param {RadiologyReportCreateManyAndReturnArgs} args - Arguments to create many RadiologyReports.
     * @example
     * // Create many RadiologyReports
     * const radiologyReport = await prisma.radiologyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RadiologyReports and only return the `id`
     * const radiologyReportWithIdOnly = await prisma.radiologyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RadiologyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, RadiologyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RadiologyReport.
     * @param {RadiologyReportDeleteArgs} args - Arguments to delete one RadiologyReport.
     * @example
     * // Delete one RadiologyReport
     * const RadiologyReport = await prisma.radiologyReport.delete({
     *   where: {
     *     // ... filter to delete one RadiologyReport
     *   }
     * })
     * 
     */
    delete<T extends RadiologyReportDeleteArgs>(args: SelectSubset<T, RadiologyReportDeleteArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RadiologyReport.
     * @param {RadiologyReportUpdateArgs} args - Arguments to update one RadiologyReport.
     * @example
     * // Update one RadiologyReport
     * const radiologyReport = await prisma.radiologyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RadiologyReportUpdateArgs>(args: SelectSubset<T, RadiologyReportUpdateArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RadiologyReports.
     * @param {RadiologyReportDeleteManyArgs} args - Arguments to filter RadiologyReports to delete.
     * @example
     * // Delete a few RadiologyReports
     * const { count } = await prisma.radiologyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RadiologyReportDeleteManyArgs>(args?: SelectSubset<T, RadiologyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiologyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RadiologyReports
     * const radiologyReport = await prisma.radiologyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RadiologyReportUpdateManyArgs>(args: SelectSubset<T, RadiologyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiologyReports and returns the data updated in the database.
     * @param {RadiologyReportUpdateManyAndReturnArgs} args - Arguments to update many RadiologyReports.
     * @example
     * // Update many RadiologyReports
     * const radiologyReport = await prisma.radiologyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RadiologyReports and only return the `id`
     * const radiologyReportWithIdOnly = await prisma.radiologyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RadiologyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, RadiologyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RadiologyReport.
     * @param {RadiologyReportUpsertArgs} args - Arguments to update or create a RadiologyReport.
     * @example
     * // Update or create a RadiologyReport
     * const radiologyReport = await prisma.radiologyReport.upsert({
     *   create: {
     *     // ... data to create a RadiologyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RadiologyReport we want to update
     *   }
     * })
     */
    upsert<T extends RadiologyReportUpsertArgs>(args: SelectSubset<T, RadiologyReportUpsertArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RadiologyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportCountArgs} args - Arguments to filter RadiologyReports to count.
     * @example
     * // Count the number of RadiologyReports
     * const count = await prisma.radiologyReport.count({
     *   where: {
     *     // ... the filter for the RadiologyReports we want to count
     *   }
     * })
    **/
    count<T extends RadiologyReportCountArgs>(
      args?: Subset<T, RadiologyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RadiologyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RadiologyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RadiologyReportAggregateArgs>(args: Subset<T, RadiologyReportAggregateArgs>): Prisma.PrismaPromise<GetRadiologyReportAggregateType<T>>

    /**
     * Group by RadiologyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RadiologyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RadiologyReportGroupByArgs['orderBy'] }
        : { orderBy?: RadiologyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RadiologyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRadiologyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RadiologyReport model
   */
  readonly fields: RadiologyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RadiologyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RadiologyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends RadiologyReport$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, RadiologyReport$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoiceItems<T extends RadiologyReport$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, RadiologyReport$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RadiologyReport model
   */
  interface RadiologyReportFieldRefs {
    readonly id: FieldRef<"RadiologyReport", 'Int'>
    readonly patientId: FieldRef<"RadiologyReport", 'Int'>
    readonly doctorId: FieldRef<"RadiologyReport", 'Int'>
    readonly appointmentId: FieldRef<"RadiologyReport", 'Int'>
    readonly testDate: FieldRef<"RadiologyReport", 'DateTime'>
    readonly reportDate: FieldRef<"RadiologyReport", 'DateTime'>
    readonly testType: FieldRef<"RadiologyReport", 'String'>
    readonly findings: FieldRef<"RadiologyReport", 'String'>
    readonly impression: FieldRef<"RadiologyReport", 'String'>
    readonly notes: FieldRef<"RadiologyReport", 'String'>
    readonly attachmentUrl: FieldRef<"RadiologyReport", 'String'>
    readonly status: FieldRef<"RadiologyReport", 'String'>
    readonly createdAt: FieldRef<"RadiologyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"RadiologyReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RadiologyReport findUnique
   */
  export type RadiologyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyReport to fetch.
     */
    where: RadiologyReportWhereUniqueInput
  }

  /**
   * RadiologyReport findUniqueOrThrow
   */
  export type RadiologyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyReport to fetch.
     */
    where: RadiologyReportWhereUniqueInput
  }

  /**
   * RadiologyReport findFirst
   */
  export type RadiologyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyReport to fetch.
     */
    where?: RadiologyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyReports to fetch.
     */
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiologyReports.
     */
    cursor?: RadiologyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiologyReports.
     */
    distinct?: RadiologyReportScalarFieldEnum | RadiologyReportScalarFieldEnum[]
  }

  /**
   * RadiologyReport findFirstOrThrow
   */
  export type RadiologyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyReport to fetch.
     */
    where?: RadiologyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyReports to fetch.
     */
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiologyReports.
     */
    cursor?: RadiologyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiologyReports.
     */
    distinct?: RadiologyReportScalarFieldEnum | RadiologyReportScalarFieldEnum[]
  }

  /**
   * RadiologyReport findMany
   */
  export type RadiologyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyReports to fetch.
     */
    where?: RadiologyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyReports to fetch.
     */
    orderBy?: RadiologyReportOrderByWithRelationInput | RadiologyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RadiologyReports.
     */
    cursor?: RadiologyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyReports.
     */
    skip?: number
    distinct?: RadiologyReportScalarFieldEnum | RadiologyReportScalarFieldEnum[]
  }

  /**
   * RadiologyReport create
   */
  export type RadiologyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a RadiologyReport.
     */
    data: XOR<RadiologyReportCreateInput, RadiologyReportUncheckedCreateInput>
  }

  /**
   * RadiologyReport createMany
   */
  export type RadiologyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RadiologyReports.
     */
    data: RadiologyReportCreateManyInput | RadiologyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RadiologyReport createManyAndReturn
   */
  export type RadiologyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * The data used to create many RadiologyReports.
     */
    data: RadiologyReportCreateManyInput | RadiologyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadiologyReport update
   */
  export type RadiologyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a RadiologyReport.
     */
    data: XOR<RadiologyReportUpdateInput, RadiologyReportUncheckedUpdateInput>
    /**
     * Choose, which RadiologyReport to update.
     */
    where: RadiologyReportWhereUniqueInput
  }

  /**
   * RadiologyReport updateMany
   */
  export type RadiologyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RadiologyReports.
     */
    data: XOR<RadiologyReportUpdateManyMutationInput, RadiologyReportUncheckedUpdateManyInput>
    /**
     * Filter which RadiologyReports to update
     */
    where?: RadiologyReportWhereInput
    /**
     * Limit how many RadiologyReports to update.
     */
    limit?: number
  }

  /**
   * RadiologyReport updateManyAndReturn
   */
  export type RadiologyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * The data used to update RadiologyReports.
     */
    data: XOR<RadiologyReportUpdateManyMutationInput, RadiologyReportUncheckedUpdateManyInput>
    /**
     * Filter which RadiologyReports to update
     */
    where?: RadiologyReportWhereInput
    /**
     * Limit how many RadiologyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadiologyReport upsert
   */
  export type RadiologyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the RadiologyReport to update in case it exists.
     */
    where: RadiologyReportWhereUniqueInput
    /**
     * In case the RadiologyReport found by the `where` argument doesn't exist, create a new RadiologyReport with this data.
     */
    create: XOR<RadiologyReportCreateInput, RadiologyReportUncheckedCreateInput>
    /**
     * In case the RadiologyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RadiologyReportUpdateInput, RadiologyReportUncheckedUpdateInput>
  }

  /**
   * RadiologyReport delete
   */
  export type RadiologyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    /**
     * Filter which RadiologyReport to delete.
     */
    where: RadiologyReportWhereUniqueInput
  }

  /**
   * RadiologyReport deleteMany
   */
  export type RadiologyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiologyReports to delete
     */
    where?: RadiologyReportWhereInput
    /**
     * Limit how many RadiologyReports to delete.
     */
    limit?: number
  }

  /**
   * RadiologyReport.appointment
   */
  export type RadiologyReport$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * RadiologyReport.invoiceItems
   */
  export type RadiologyReport$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * RadiologyReport without action
   */
  export type RadiologyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    netAmount: Decimal | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    netAmount: Decimal | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    patientId: number
    invoiceNumber: number
    invoiceDate: number
    dueDate: number
    totalAmount: number
    discountAmount: number
    taxAmount: number
    netAmount: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    patientId?: true
    totalAmount?: true
    discountAmount?: true
    taxAmount?: true
    netAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    patientId?: true
    totalAmount?: true
    discountAmount?: true
    taxAmount?: true
    netAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    patientId?: true
    invoiceNumber?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    discountAmount?: true
    taxAmount?: true
    netAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    patientId?: true
    invoiceNumber?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    discountAmount?: true
    taxAmount?: true
    netAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    patientId?: true
    invoiceNumber?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    discountAmount?: true
    taxAmount?: true
    netAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    patientId: number
    invoiceNumber: string
    invoiceDate: Date
    dueDate: Date
    totalAmount: Decimal
    discountAmount: Decimal
    taxAmount: Decimal
    netAmount: Decimal
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    netAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | UserDefaultArgs<ExtArgs>
    patientDetails?: boolean | PatientDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    subsidyClaims?: boolean | Invoice$subsidyClaimsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    netAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | UserDefaultArgs<ExtArgs>
    patientDetails?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    netAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | UserDefaultArgs<ExtArgs>
    patientDetails?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    patientId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    netAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "invoiceNumber" | "invoiceDate" | "dueDate" | "totalAmount" | "discountAmount" | "taxAmount" | "netAmount" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | UserDefaultArgs<ExtArgs>
    patientDetails?: boolean | PatientDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    subsidyClaims?: boolean | Invoice$subsidyClaimsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | UserDefaultArgs<ExtArgs>
    patientDetails?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | UserDefaultArgs<ExtArgs>
    patientDetails?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      patient: Prisma.$UserPayload<ExtArgs>
      patientDetails: Prisma.$PatientPayload<ExtArgs>
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      subsidyClaims: Prisma.$SubsidyClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      invoiceNumber: string
      invoiceDate: Date
      dueDate: Date
      totalAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      taxAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patientDetails<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoiceItems<T extends Invoice$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subsidyClaims<T extends Invoice$subsidyClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$subsidyClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly patientId: FieldRef<"Invoice", 'Int'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly discountAmount: FieldRef<"Invoice", 'Decimal'>
    readonly taxAmount: FieldRef<"Invoice", 'Decimal'>
    readonly netAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.invoiceItems
   */
  export type Invoice$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.subsidyClaims
   */
  export type Invoice$subsidyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    where?: SubsidyClaimWhereInput
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    cursor?: SubsidyClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubsidyClaimScalarFieldEnum | SubsidyClaimScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    labReportId: number | null
    radiologyReportId: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    labReportId: number | null
    radiologyReportId: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemType: string | null
    itemId: number | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    labReportId: number | null
    radiologyReportId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemType: string | null
    itemId: number | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    labReportId: number | null
    radiologyReportId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemType: number
    itemId: number
    description: number
    quantity: number
    unitPrice: number
    totalPrice: number
    labReportId: number
    radiologyReportId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    labReportId?: true
    radiologyReportId?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    labReportId?: true
    radiologyReportId?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    itemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    labReportId?: true
    radiologyReportId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    itemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    labReportId?: true
    radiologyReportId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    itemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    labReportId?: true
    radiologyReportId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    itemType: string
    itemId: number | null
    description: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    labReportId: number | null
    radiologyReportId: number | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    labReportId?: boolean
    radiologyReportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    labReport?: boolean | InvoiceItem$labReportArgs<ExtArgs>
    radiologyReport?: boolean | InvoiceItem$radiologyReportArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    labReportId?: boolean
    radiologyReportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    labReport?: boolean | InvoiceItem$labReportArgs<ExtArgs>
    radiologyReport?: boolean | InvoiceItem$radiologyReportArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    labReportId?: boolean
    radiologyReportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    labReport?: boolean | InvoiceItem$labReportArgs<ExtArgs>
    radiologyReport?: boolean | InvoiceItem$radiologyReportArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    labReportId?: boolean
    radiologyReportId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "itemType" | "itemId" | "description" | "quantity" | "unitPrice" | "totalPrice" | "labReportId" | "radiologyReportId" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    labReport?: boolean | InvoiceItem$labReportArgs<ExtArgs>
    radiologyReport?: boolean | InvoiceItem$radiologyReportArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    labReport?: boolean | InvoiceItem$labReportArgs<ExtArgs>
    radiologyReport?: boolean | InvoiceItem$radiologyReportArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    labReport?: boolean | InvoiceItem$labReportArgs<ExtArgs>
    radiologyReport?: boolean | InvoiceItem$radiologyReportArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      labReport: Prisma.$LabReportPayload<ExtArgs> | null
      radiologyReport: Prisma.$RadiologyReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      itemType: string
      itemId: number | null
      description: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      labReportId: number | null
      radiologyReportId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labReport<T extends InvoiceItem$labReportArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$labReportArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    radiologyReport<T extends InvoiceItem$radiologyReportArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$radiologyReportArgs<ExtArgs>>): Prisma__RadiologyReportClient<$Result.GetResult<Prisma.$RadiologyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'Int'>
    readonly itemType: FieldRef<"InvoiceItem", 'String'>
    readonly itemId: FieldRef<"InvoiceItem", 'Int'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly totalPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly labReportId: FieldRef<"InvoiceItem", 'Int'>
    readonly radiologyReportId: FieldRef<"InvoiceItem", 'Int'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem.labReport
   */
  export type InvoiceItem$labReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabReport
     */
    omit?: LabReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    where?: LabReportWhereInput
  }

  /**
   * InvoiceItem.radiologyReport
   */
  export type InvoiceItem$radiologyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyReport
     */
    select?: RadiologyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyReport
     */
    omit?: RadiologyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyReportInclude<ExtArgs> | null
    where?: RadiologyReportWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    patientId: number | null
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    patientId: number | null
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    patientId: number | null
    paymentDate: Date | null
    amount: Decimal | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    patientId: number | null
    paymentDate: Date | null
    amount: Decimal | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    patientId: number
    paymentDate: number
    amount: number
    paymentMethod: number
    transactionId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    patientId?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    invoiceId: number
    patientId: number
    paymentDate: Date
    amount: Decimal
    paymentMethod: string
    transactionId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    patientId?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "patientId" | "paymentDate" | "amount" | "paymentMethod" | "transactionId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    patient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      patient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      patientId: number
      paymentDate: Date
      amount: Prisma.Decimal
      paymentMethod: string
      transactionId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly invoiceId: FieldRef<"Payment", 'Int'>
    readonly patientId: FieldRef<"Payment", 'Int'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Bed
   */

  export type AggregateBed = {
    _count: BedCountAggregateOutputType | null
    _avg: BedAvgAggregateOutputType | null
    _sum: BedSumAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  export type BedAvgAggregateOutputType = {
    id: number | null
    wardId: number | null
    price: Decimal | null
  }

  export type BedSumAggregateOutputType = {
    id: number | null
    wardId: number | null
    price: Decimal | null
  }

  export type BedMinAggregateOutputType = {
    id: number | null
    bedNumber: string | null
    wardId: number | null
    status: string | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedMaxAggregateOutputType = {
    id: number | null
    bedNumber: string | null
    wardId: number | null
    status: string | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedCountAggregateOutputType = {
    id: number
    bedNumber: number
    wardId: number
    status: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BedAvgAggregateInputType = {
    id?: true
    wardId?: true
    price?: true
  }

  export type BedSumAggregateInputType = {
    id?: true
    wardId?: true
    price?: true
  }

  export type BedMinAggregateInputType = {
    id?: true
    bedNumber?: true
    wardId?: true
    status?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedMaxAggregateInputType = {
    id?: true
    bedNumber?: true
    wardId?: true
    status?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedCountAggregateInputType = {
    id?: true
    bedNumber?: true
    wardId?: true
    status?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bed to aggregate.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beds
    **/
    _count?: true | BedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedMaxAggregateInputType
  }

  export type GetBedAggregateType<T extends BedAggregateArgs> = {
        [P in keyof T & keyof AggregateBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBed[P]>
      : GetScalarType<T[P], AggregateBed[P]>
  }




  export type BedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
    orderBy?: BedOrderByWithAggregationInput | BedOrderByWithAggregationInput[]
    by: BedScalarFieldEnum[] | BedScalarFieldEnum
    having?: BedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedCountAggregateInputType | true
    _avg?: BedAvgAggregateInputType
    _sum?: BedSumAggregateInputType
    _min?: BedMinAggregateInputType
    _max?: BedMaxAggregateInputType
  }

  export type BedGroupByOutputType = {
    id: number
    bedNumber: string
    wardId: number
    status: string
    price: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BedCountAggregateOutputType | null
    _avg: BedAvgAggregateOutputType | null
    _sum: BedSumAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  type GetBedGroupByPayload<T extends BedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedGroupByOutputType[P]>
            : GetScalarType<T[P], BedGroupByOutputType[P]>
        }
      >
    >


  export type BedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bedNumber?: boolean
    wardId?: boolean
    status?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
    bedAllocations?: boolean | Bed$bedAllocationsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bedNumber?: boolean
    wardId?: boolean
    status?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bedNumber?: boolean
    wardId?: boolean
    status?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectScalar = {
    id?: boolean
    bedNumber?: boolean
    wardId?: boolean
    status?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bedNumber" | "wardId" | "status" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["bed"]>
  export type BedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
    bedAllocations?: boolean | Bed$bedAllocationsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }
  export type BedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }

  export type $BedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bed"
    objects: {
      ward: Prisma.$WardPayload<ExtArgs>
      bedAllocations: Prisma.$BedAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bedNumber: string
      wardId: number
      status: string
      price: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bed"]>
    composites: {}
  }

  type BedGetPayload<S extends boolean | null | undefined | BedDefaultArgs> = $Result.GetResult<Prisma.$BedPayload, S>

  type BedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedCountAggregateInputType | true
    }

  export interface BedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bed'], meta: { name: 'Bed' } }
    /**
     * Find zero or one Bed that matches the filter.
     * @param {BedFindUniqueArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedFindUniqueArgs>(args: SelectSubset<T, BedFindUniqueArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedFindUniqueOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedFindUniqueOrThrowArgs>(args: SelectSubset<T, BedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedFindFirstArgs>(args?: SelectSubset<T, BedFindFirstArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedFindFirstOrThrowArgs>(args?: SelectSubset<T, BedFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Beds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beds
     * const beds = await prisma.bed.findMany()
     * 
     * // Get first 10 Beds
     * const beds = await prisma.bed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedWithIdOnly = await prisma.bed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedFindManyArgs>(args?: SelectSubset<T, BedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bed.
     * @param {BedCreateArgs} args - Arguments to create a Bed.
     * @example
     * // Create one Bed
     * const Bed = await prisma.bed.create({
     *   data: {
     *     // ... data to create a Bed
     *   }
     * })
     * 
     */
    create<T extends BedCreateArgs>(args: SelectSubset<T, BedCreateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Beds.
     * @param {BedCreateManyArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedCreateManyArgs>(args?: SelectSubset<T, BedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beds and returns the data saved in the database.
     * @param {BedCreateManyAndReturnArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedCreateManyAndReturnArgs>(args?: SelectSubset<T, BedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bed.
     * @param {BedDeleteArgs} args - Arguments to delete one Bed.
     * @example
     * // Delete one Bed
     * const Bed = await prisma.bed.delete({
     *   where: {
     *     // ... filter to delete one Bed
     *   }
     * })
     * 
     */
    delete<T extends BedDeleteArgs>(args: SelectSubset<T, BedDeleteArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bed.
     * @param {BedUpdateArgs} args - Arguments to update one Bed.
     * @example
     * // Update one Bed
     * const bed = await prisma.bed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedUpdateArgs>(args: SelectSubset<T, BedUpdateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Beds.
     * @param {BedDeleteManyArgs} args - Arguments to filter Beds to delete.
     * @example
     * // Delete a few Beds
     * const { count } = await prisma.bed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedDeleteManyArgs>(args?: SelectSubset<T, BedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedUpdateManyArgs>(args: SelectSubset<T, BedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds and returns the data updated in the database.
     * @param {BedUpdateManyAndReturnArgs} args - Arguments to update many Beds.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedUpdateManyAndReturnArgs>(args: SelectSubset<T, BedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bed.
     * @param {BedUpsertArgs} args - Arguments to update or create a Bed.
     * @example
     * // Update or create a Bed
     * const bed = await prisma.bed.upsert({
     *   create: {
     *     // ... data to create a Bed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bed we want to update
     *   }
     * })
     */
    upsert<T extends BedUpsertArgs>(args: SelectSubset<T, BedUpsertArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedCountArgs} args - Arguments to filter Beds to count.
     * @example
     * // Count the number of Beds
     * const count = await prisma.bed.count({
     *   where: {
     *     // ... the filter for the Beds we want to count
     *   }
     * })
    **/
    count<T extends BedCountArgs>(
      args?: Subset<T, BedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedAggregateArgs>(args: Subset<T, BedAggregateArgs>): Prisma.PrismaPromise<GetBedAggregateType<T>>

    /**
     * Group by Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedGroupByArgs['orderBy'] }
        : { orderBy?: BedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bed model
   */
  readonly fields: BedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ward<T extends WardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardDefaultArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bedAllocations<T extends Bed$bedAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Bed$bedAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bed model
   */
  interface BedFieldRefs {
    readonly id: FieldRef<"Bed", 'Int'>
    readonly bedNumber: FieldRef<"Bed", 'String'>
    readonly wardId: FieldRef<"Bed", 'Int'>
    readonly status: FieldRef<"Bed", 'String'>
    readonly price: FieldRef<"Bed", 'Decimal'>
    readonly createdAt: FieldRef<"Bed", 'DateTime'>
    readonly updatedAt: FieldRef<"Bed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bed findUnique
   */
  export type BedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findUniqueOrThrow
   */
  export type BedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findFirst
   */
  export type BedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findFirstOrThrow
   */
  export type BedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findMany
   */
  export type BedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Beds to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed create
   */
  export type BedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to create a Bed.
     */
    data: XOR<BedCreateInput, BedUncheckedCreateInput>
  }

  /**
   * Bed createMany
   */
  export type BedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bed createManyAndReturn
   */
  export type BedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed update
   */
  export type BedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to update a Bed.
     */
    data: XOR<BedUpdateInput, BedUncheckedUpdateInput>
    /**
     * Choose, which Bed to update.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed updateMany
   */
  export type BedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to update.
     */
    limit?: number
  }

  /**
   * Bed updateManyAndReturn
   */
  export type BedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed upsert
   */
  export type BedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The filter to search for the Bed to update in case it exists.
     */
    where: BedWhereUniqueInput
    /**
     * In case the Bed found by the `where` argument doesn't exist, create a new Bed with this data.
     */
    create: XOR<BedCreateInput, BedUncheckedCreateInput>
    /**
     * In case the Bed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedUpdateInput, BedUncheckedUpdateInput>
  }

  /**
   * Bed delete
   */
  export type BedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter which Bed to delete.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed deleteMany
   */
  export type BedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beds to delete
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to delete.
     */
    limit?: number
  }

  /**
   * Bed.bedAllocations
   */
  export type Bed$bedAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    where?: BedAllocationWhereInput
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    cursor?: BedAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedAllocationScalarFieldEnum | BedAllocationScalarFieldEnum[]
  }

  /**
   * Bed without action
   */
  export type BedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
  }


  /**
   * Model Ward
   */

  export type AggregateWard = {
    _count: WardCountAggregateOutputType | null
    _avg: WardAvgAggregateOutputType | null
    _sum: WardSumAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  export type WardAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type WardSumAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type WardMinAggregateOutputType = {
    id: number | null
    name: string | null
    wardType: string | null
    floor: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardMaxAggregateOutputType = {
    id: number | null
    name: string | null
    wardType: string | null
    floor: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardCountAggregateOutputType = {
    id: number
    name: number
    wardType: number
    floor: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WardAvgAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type WardSumAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type WardMinAggregateInputType = {
    id?: true
    name?: true
    wardType?: true
    floor?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardMaxAggregateInputType = {
    id?: true
    name?: true
    wardType?: true
    floor?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardCountAggregateInputType = {
    id?: true
    name?: true
    wardType?: true
    floor?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ward to aggregate.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wards
    **/
    _count?: true | WardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMaxAggregateInputType
  }

  export type GetWardAggregateType<T extends WardAggregateArgs> = {
        [P in keyof T & keyof AggregateWard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWard[P]>
      : GetScalarType<T[P], AggregateWard[P]>
  }




  export type WardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
    orderBy?: WardOrderByWithAggregationInput | WardOrderByWithAggregationInput[]
    by: WardScalarFieldEnum[] | WardScalarFieldEnum
    having?: WardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardCountAggregateInputType | true
    _avg?: WardAvgAggregateInputType
    _sum?: WardSumAggregateInputType
    _min?: WardMinAggregateInputType
    _max?: WardMaxAggregateInputType
  }

  export type WardGroupByOutputType = {
    id: number
    name: string
    wardType: string
    floor: string | null
    capacity: number
    createdAt: Date
    updatedAt: Date
    _count: WardCountAggregateOutputType | null
    _avg: WardAvgAggregateOutputType | null
    _sum: WardSumAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  type GetWardGroupByPayload<T extends WardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardGroupByOutputType[P]>
            : GetScalarType<T[P], WardGroupByOutputType[P]>
        }
      >
    >


  export type WardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    wardType?: boolean
    floor?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beds?: boolean | Ward$bedsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    wardType?: boolean
    floor?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ward"]>

  export type WardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    wardType?: boolean
    floor?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ward"]>

  export type WardSelectScalar = {
    id?: boolean
    name?: boolean
    wardType?: boolean
    floor?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "wardType" | "floor" | "capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["ward"]>
  export type WardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | Ward$bedsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ward"
    objects: {
      beds: Prisma.$BedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      wardType: string
      floor: string | null
      capacity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ward"]>
    composites: {}
  }

  type WardGetPayload<S extends boolean | null | undefined | WardDefaultArgs> = $Result.GetResult<Prisma.$WardPayload, S>

  type WardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WardCountAggregateInputType | true
    }

  export interface WardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ward'], meta: { name: 'Ward' } }
    /**
     * Find zero or one Ward that matches the filter.
     * @param {WardFindUniqueArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardFindUniqueArgs>(args: SelectSubset<T, WardFindUniqueArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WardFindUniqueOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardFindUniqueOrThrowArgs>(args: SelectSubset<T, WardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardFindFirstArgs>(args?: SelectSubset<T, WardFindFirstArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardFindFirstOrThrowArgs>(args?: SelectSubset<T, WardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wards
     * const wards = await prisma.ward.findMany()
     * 
     * // Get first 10 Wards
     * const wards = await prisma.ward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wardWithIdOnly = await prisma.ward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WardFindManyArgs>(args?: SelectSubset<T, WardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ward.
     * @param {WardCreateArgs} args - Arguments to create a Ward.
     * @example
     * // Create one Ward
     * const Ward = await prisma.ward.create({
     *   data: {
     *     // ... data to create a Ward
     *   }
     * })
     * 
     */
    create<T extends WardCreateArgs>(args: SelectSubset<T, WardCreateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wards.
     * @param {WardCreateManyArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardCreateManyArgs>(args?: SelectSubset<T, WardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wards and returns the data saved in the database.
     * @param {WardCreateManyAndReturnArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardCreateManyAndReturnArgs>(args?: SelectSubset<T, WardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ward.
     * @param {WardDeleteArgs} args - Arguments to delete one Ward.
     * @example
     * // Delete one Ward
     * const Ward = await prisma.ward.delete({
     *   where: {
     *     // ... filter to delete one Ward
     *   }
     * })
     * 
     */
    delete<T extends WardDeleteArgs>(args: SelectSubset<T, WardDeleteArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ward.
     * @param {WardUpdateArgs} args - Arguments to update one Ward.
     * @example
     * // Update one Ward
     * const ward = await prisma.ward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardUpdateArgs>(args: SelectSubset<T, WardUpdateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wards.
     * @param {WardDeleteManyArgs} args - Arguments to filter Wards to delete.
     * @example
     * // Delete a few Wards
     * const { count } = await prisma.ward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardDeleteManyArgs>(args?: SelectSubset<T, WardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardUpdateManyArgs>(args: SelectSubset<T, WardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards and returns the data updated in the database.
     * @param {WardUpdateManyAndReturnArgs} args - Arguments to update many Wards.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WardUpdateManyAndReturnArgs>(args: SelectSubset<T, WardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ward.
     * @param {WardUpsertArgs} args - Arguments to update or create a Ward.
     * @example
     * // Update or create a Ward
     * const ward = await prisma.ward.upsert({
     *   create: {
     *     // ... data to create a Ward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ward we want to update
     *   }
     * })
     */
    upsert<T extends WardUpsertArgs>(args: SelectSubset<T, WardUpsertArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardCountArgs} args - Arguments to filter Wards to count.
     * @example
     * // Count the number of Wards
     * const count = await prisma.ward.count({
     *   where: {
     *     // ... the filter for the Wards we want to count
     *   }
     * })
    **/
    count<T extends WardCountArgs>(
      args?: Subset<T, WardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardAggregateArgs>(args: Subset<T, WardAggregateArgs>): Prisma.PrismaPromise<GetWardAggregateType<T>>

    /**
     * Group by Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardGroupByArgs['orderBy'] }
        : { orderBy?: WardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ward model
   */
  readonly fields: WardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beds<T extends Ward$bedsArgs<ExtArgs> = {}>(args?: Subset<T, Ward$bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ward model
   */
  interface WardFieldRefs {
    readonly id: FieldRef<"Ward", 'Int'>
    readonly name: FieldRef<"Ward", 'String'>
    readonly wardType: FieldRef<"Ward", 'String'>
    readonly floor: FieldRef<"Ward", 'String'>
    readonly capacity: FieldRef<"Ward", 'Int'>
    readonly createdAt: FieldRef<"Ward", 'DateTime'>
    readonly updatedAt: FieldRef<"Ward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ward findUnique
   */
  export type WardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findUniqueOrThrow
   */
  export type WardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findFirst
   */
  export type WardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findFirstOrThrow
   */
  export type WardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findMany
   */
  export type WardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Wards to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward create
   */
  export type WardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to create a Ward.
     */
    data: XOR<WardCreateInput, WardUncheckedCreateInput>
  }

  /**
   * Ward createMany
   */
  export type WardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ward createManyAndReturn
   */
  export type WardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ward update
   */
  export type WardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to update a Ward.
     */
    data: XOR<WardUpdateInput, WardUncheckedUpdateInput>
    /**
     * Choose, which Ward to update.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward updateMany
   */
  export type WardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
    /**
     * Limit how many Wards to update.
     */
    limit?: number
  }

  /**
   * Ward updateManyAndReturn
   */
  export type WardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
    /**
     * Limit how many Wards to update.
     */
    limit?: number
  }

  /**
   * Ward upsert
   */
  export type WardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The filter to search for the Ward to update in case it exists.
     */
    where: WardWhereUniqueInput
    /**
     * In case the Ward found by the `where` argument doesn't exist, create a new Ward with this data.
     */
    create: XOR<WardCreateInput, WardUncheckedCreateInput>
    /**
     * In case the Ward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardUpdateInput, WardUncheckedUpdateInput>
  }

  /**
   * Ward delete
   */
  export type WardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter which Ward to delete.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward deleteMany
   */
  export type WardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wards to delete
     */
    where?: WardWhereInput
    /**
     * Limit how many Wards to delete.
     */
    limit?: number
  }

  /**
   * Ward.beds
   */
  export type Ward$bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Ward without action
   */
  export type WardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
  }


  /**
   * Model BedAllocation
   */

  export type AggregateBedAllocation = {
    _count: BedAllocationCountAggregateOutputType | null
    _avg: BedAllocationAvgAggregateOutputType | null
    _sum: BedAllocationSumAggregateOutputType | null
    _min: BedAllocationMinAggregateOutputType | null
    _max: BedAllocationMaxAggregateOutputType | null
  }

  export type BedAllocationAvgAggregateOutputType = {
    id: number | null
    bedId: number | null
    patientId: number | null
    nurseId: number | null
  }

  export type BedAllocationSumAggregateOutputType = {
    id: number | null
    bedId: number | null
    patientId: number | null
    nurseId: number | null
  }

  export type BedAllocationMinAggregateOutputType = {
    id: number | null
    bedId: number | null
    patientId: number | null
    nurseId: number | null
    allocatedAt: Date | null
    dischargedAt: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedAllocationMaxAggregateOutputType = {
    id: number | null
    bedId: number | null
    patientId: number | null
    nurseId: number | null
    allocatedAt: Date | null
    dischargedAt: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedAllocationCountAggregateOutputType = {
    id: number
    bedId: number
    patientId: number
    nurseId: number
    allocatedAt: number
    dischargedAt: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BedAllocationAvgAggregateInputType = {
    id?: true
    bedId?: true
    patientId?: true
    nurseId?: true
  }

  export type BedAllocationSumAggregateInputType = {
    id?: true
    bedId?: true
    patientId?: true
    nurseId?: true
  }

  export type BedAllocationMinAggregateInputType = {
    id?: true
    bedId?: true
    patientId?: true
    nurseId?: true
    allocatedAt?: true
    dischargedAt?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedAllocationMaxAggregateInputType = {
    id?: true
    bedId?: true
    patientId?: true
    nurseId?: true
    allocatedAt?: true
    dischargedAt?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedAllocationCountAggregateInputType = {
    id?: true
    bedId?: true
    patientId?: true
    nurseId?: true
    allocatedAt?: true
    dischargedAt?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BedAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedAllocation to aggregate.
     */
    where?: BedAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedAllocations to fetch.
     */
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BedAllocations
    **/
    _count?: true | BedAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BedAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BedAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedAllocationMaxAggregateInputType
  }

  export type GetBedAllocationAggregateType<T extends BedAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateBedAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBedAllocation[P]>
      : GetScalarType<T[P], AggregateBedAllocation[P]>
  }




  export type BedAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedAllocationWhereInput
    orderBy?: BedAllocationOrderByWithAggregationInput | BedAllocationOrderByWithAggregationInput[]
    by: BedAllocationScalarFieldEnum[] | BedAllocationScalarFieldEnum
    having?: BedAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedAllocationCountAggregateInputType | true
    _avg?: BedAllocationAvgAggregateInputType
    _sum?: BedAllocationSumAggregateInputType
    _min?: BedAllocationMinAggregateInputType
    _max?: BedAllocationMaxAggregateInputType
  }

  export type BedAllocationGroupByOutputType = {
    id: number
    bedId: number
    patientId: number
    nurseId: number | null
    allocatedAt: Date
    dischargedAt: Date | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: BedAllocationCountAggregateOutputType | null
    _avg: BedAllocationAvgAggregateOutputType | null
    _sum: BedAllocationSumAggregateOutputType | null
    _min: BedAllocationMinAggregateOutputType | null
    _max: BedAllocationMaxAggregateOutputType | null
  }

  type GetBedAllocationGroupByPayload<T extends BedAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], BedAllocationGroupByOutputType[P]>
        }
      >
    >


  export type BedAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bedId?: boolean
    patientId?: boolean
    nurseId?: boolean
    allocatedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bed?: boolean | BedDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | BedAllocation$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["bedAllocation"]>

  export type BedAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bedId?: boolean
    patientId?: boolean
    nurseId?: boolean
    allocatedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bed?: boolean | BedDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | BedAllocation$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["bedAllocation"]>

  export type BedAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bedId?: boolean
    patientId?: boolean
    nurseId?: boolean
    allocatedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bed?: boolean | BedDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | BedAllocation$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["bedAllocation"]>

  export type BedAllocationSelectScalar = {
    id?: boolean
    bedId?: boolean
    patientId?: boolean
    nurseId?: boolean
    allocatedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BedAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bedId" | "patientId" | "nurseId" | "allocatedAt" | "dischargedAt" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["bedAllocation"]>
  export type BedAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bed?: boolean | BedDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | BedAllocation$nurseArgs<ExtArgs>
  }
  export type BedAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bed?: boolean | BedDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | BedAllocation$nurseArgs<ExtArgs>
  }
  export type BedAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bed?: boolean | BedDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | BedAllocation$nurseArgs<ExtArgs>
  }

  export type $BedAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BedAllocation"
    objects: {
      bed: Prisma.$BedPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      nurse: Prisma.$NursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bedId: number
      patientId: number
      nurseId: number | null
      allocatedAt: Date
      dischargedAt: Date | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bedAllocation"]>
    composites: {}
  }

  type BedAllocationGetPayload<S extends boolean | null | undefined | BedAllocationDefaultArgs> = $Result.GetResult<Prisma.$BedAllocationPayload, S>

  type BedAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedAllocationCountAggregateInputType | true
    }

  export interface BedAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BedAllocation'], meta: { name: 'BedAllocation' } }
    /**
     * Find zero or one BedAllocation that matches the filter.
     * @param {BedAllocationFindUniqueArgs} args - Arguments to find a BedAllocation
     * @example
     * // Get one BedAllocation
     * const bedAllocation = await prisma.bedAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedAllocationFindUniqueArgs>(args: SelectSubset<T, BedAllocationFindUniqueArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BedAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedAllocationFindUniqueOrThrowArgs} args - Arguments to find a BedAllocation
     * @example
     * // Get one BedAllocation
     * const bedAllocation = await prisma.bedAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, BedAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationFindFirstArgs} args - Arguments to find a BedAllocation
     * @example
     * // Get one BedAllocation
     * const bedAllocation = await prisma.bedAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedAllocationFindFirstArgs>(args?: SelectSubset<T, BedAllocationFindFirstArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationFindFirstOrThrowArgs} args - Arguments to find a BedAllocation
     * @example
     * // Get one BedAllocation
     * const bedAllocation = await prisma.bedAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, BedAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BedAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BedAllocations
     * const bedAllocations = await prisma.bedAllocation.findMany()
     * 
     * // Get first 10 BedAllocations
     * const bedAllocations = await prisma.bedAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedAllocationWithIdOnly = await prisma.bedAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedAllocationFindManyArgs>(args?: SelectSubset<T, BedAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BedAllocation.
     * @param {BedAllocationCreateArgs} args - Arguments to create a BedAllocation.
     * @example
     * // Create one BedAllocation
     * const BedAllocation = await prisma.bedAllocation.create({
     *   data: {
     *     // ... data to create a BedAllocation
     *   }
     * })
     * 
     */
    create<T extends BedAllocationCreateArgs>(args: SelectSubset<T, BedAllocationCreateArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BedAllocations.
     * @param {BedAllocationCreateManyArgs} args - Arguments to create many BedAllocations.
     * @example
     * // Create many BedAllocations
     * const bedAllocation = await prisma.bedAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedAllocationCreateManyArgs>(args?: SelectSubset<T, BedAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BedAllocations and returns the data saved in the database.
     * @param {BedAllocationCreateManyAndReturnArgs} args - Arguments to create many BedAllocations.
     * @example
     * // Create many BedAllocations
     * const bedAllocation = await prisma.bedAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BedAllocations and only return the `id`
     * const bedAllocationWithIdOnly = await prisma.bedAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, BedAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BedAllocation.
     * @param {BedAllocationDeleteArgs} args - Arguments to delete one BedAllocation.
     * @example
     * // Delete one BedAllocation
     * const BedAllocation = await prisma.bedAllocation.delete({
     *   where: {
     *     // ... filter to delete one BedAllocation
     *   }
     * })
     * 
     */
    delete<T extends BedAllocationDeleteArgs>(args: SelectSubset<T, BedAllocationDeleteArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BedAllocation.
     * @param {BedAllocationUpdateArgs} args - Arguments to update one BedAllocation.
     * @example
     * // Update one BedAllocation
     * const bedAllocation = await prisma.bedAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedAllocationUpdateArgs>(args: SelectSubset<T, BedAllocationUpdateArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BedAllocations.
     * @param {BedAllocationDeleteManyArgs} args - Arguments to filter BedAllocations to delete.
     * @example
     * // Delete a few BedAllocations
     * const { count } = await prisma.bedAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedAllocationDeleteManyArgs>(args?: SelectSubset<T, BedAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BedAllocations
     * const bedAllocation = await prisma.bedAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedAllocationUpdateManyArgs>(args: SelectSubset<T, BedAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedAllocations and returns the data updated in the database.
     * @param {BedAllocationUpdateManyAndReturnArgs} args - Arguments to update many BedAllocations.
     * @example
     * // Update many BedAllocations
     * const bedAllocation = await prisma.bedAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BedAllocations and only return the `id`
     * const bedAllocationWithIdOnly = await prisma.bedAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, BedAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BedAllocation.
     * @param {BedAllocationUpsertArgs} args - Arguments to update or create a BedAllocation.
     * @example
     * // Update or create a BedAllocation
     * const bedAllocation = await prisma.bedAllocation.upsert({
     *   create: {
     *     // ... data to create a BedAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BedAllocation we want to update
     *   }
     * })
     */
    upsert<T extends BedAllocationUpsertArgs>(args: SelectSubset<T, BedAllocationUpsertArgs<ExtArgs>>): Prisma__BedAllocationClient<$Result.GetResult<Prisma.$BedAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BedAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationCountArgs} args - Arguments to filter BedAllocations to count.
     * @example
     * // Count the number of BedAllocations
     * const count = await prisma.bedAllocation.count({
     *   where: {
     *     // ... the filter for the BedAllocations we want to count
     *   }
     * })
    **/
    count<T extends BedAllocationCountArgs>(
      args?: Subset<T, BedAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BedAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedAllocationAggregateArgs>(args: Subset<T, BedAllocationAggregateArgs>): Prisma.PrismaPromise<GetBedAllocationAggregateType<T>>

    /**
     * Group by BedAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedAllocationGroupByArgs['orderBy'] }
        : { orderBy?: BedAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BedAllocation model
   */
  readonly fields: BedAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BedAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bed<T extends BedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BedDefaultArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nurse<T extends BedAllocation$nurseArgs<ExtArgs> = {}>(args?: Subset<T, BedAllocation$nurseArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BedAllocation model
   */
  interface BedAllocationFieldRefs {
    readonly id: FieldRef<"BedAllocation", 'Int'>
    readonly bedId: FieldRef<"BedAllocation", 'Int'>
    readonly patientId: FieldRef<"BedAllocation", 'Int'>
    readonly nurseId: FieldRef<"BedAllocation", 'Int'>
    readonly allocatedAt: FieldRef<"BedAllocation", 'DateTime'>
    readonly dischargedAt: FieldRef<"BedAllocation", 'DateTime'>
    readonly status: FieldRef<"BedAllocation", 'String'>
    readonly notes: FieldRef<"BedAllocation", 'String'>
    readonly createdAt: FieldRef<"BedAllocation", 'DateTime'>
    readonly updatedAt: FieldRef<"BedAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BedAllocation findUnique
   */
  export type BedAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * Filter, which BedAllocation to fetch.
     */
    where: BedAllocationWhereUniqueInput
  }

  /**
   * BedAllocation findUniqueOrThrow
   */
  export type BedAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * Filter, which BedAllocation to fetch.
     */
    where: BedAllocationWhereUniqueInput
  }

  /**
   * BedAllocation findFirst
   */
  export type BedAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * Filter, which BedAllocation to fetch.
     */
    where?: BedAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedAllocations to fetch.
     */
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedAllocations.
     */
    cursor?: BedAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedAllocations.
     */
    distinct?: BedAllocationScalarFieldEnum | BedAllocationScalarFieldEnum[]
  }

  /**
   * BedAllocation findFirstOrThrow
   */
  export type BedAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * Filter, which BedAllocation to fetch.
     */
    where?: BedAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedAllocations to fetch.
     */
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedAllocations.
     */
    cursor?: BedAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedAllocations.
     */
    distinct?: BedAllocationScalarFieldEnum | BedAllocationScalarFieldEnum[]
  }

  /**
   * BedAllocation findMany
   */
  export type BedAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * Filter, which BedAllocations to fetch.
     */
    where?: BedAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedAllocations to fetch.
     */
    orderBy?: BedAllocationOrderByWithRelationInput | BedAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BedAllocations.
     */
    cursor?: BedAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedAllocations.
     */
    skip?: number
    distinct?: BedAllocationScalarFieldEnum | BedAllocationScalarFieldEnum[]
  }

  /**
   * BedAllocation create
   */
  export type BedAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a BedAllocation.
     */
    data: XOR<BedAllocationCreateInput, BedAllocationUncheckedCreateInput>
  }

  /**
   * BedAllocation createMany
   */
  export type BedAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BedAllocations.
     */
    data: BedAllocationCreateManyInput | BedAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BedAllocation createManyAndReturn
   */
  export type BedAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many BedAllocations.
     */
    data: BedAllocationCreateManyInput | BedAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BedAllocation update
   */
  export type BedAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a BedAllocation.
     */
    data: XOR<BedAllocationUpdateInput, BedAllocationUncheckedUpdateInput>
    /**
     * Choose, which BedAllocation to update.
     */
    where: BedAllocationWhereUniqueInput
  }

  /**
   * BedAllocation updateMany
   */
  export type BedAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BedAllocations.
     */
    data: XOR<BedAllocationUpdateManyMutationInput, BedAllocationUncheckedUpdateManyInput>
    /**
     * Filter which BedAllocations to update
     */
    where?: BedAllocationWhereInput
    /**
     * Limit how many BedAllocations to update.
     */
    limit?: number
  }

  /**
   * BedAllocation updateManyAndReturn
   */
  export type BedAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * The data used to update BedAllocations.
     */
    data: XOR<BedAllocationUpdateManyMutationInput, BedAllocationUncheckedUpdateManyInput>
    /**
     * Filter which BedAllocations to update
     */
    where?: BedAllocationWhereInput
    /**
     * Limit how many BedAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BedAllocation upsert
   */
  export type BedAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the BedAllocation to update in case it exists.
     */
    where: BedAllocationWhereUniqueInput
    /**
     * In case the BedAllocation found by the `where` argument doesn't exist, create a new BedAllocation with this data.
     */
    create: XOR<BedAllocationCreateInput, BedAllocationUncheckedCreateInput>
    /**
     * In case the BedAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedAllocationUpdateInput, BedAllocationUncheckedUpdateInput>
  }

  /**
   * BedAllocation delete
   */
  export type BedAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
    /**
     * Filter which BedAllocation to delete.
     */
    where: BedAllocationWhereUniqueInput
  }

  /**
   * BedAllocation deleteMany
   */
  export type BedAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedAllocations to delete
     */
    where?: BedAllocationWhereInput
    /**
     * Limit how many BedAllocations to delete.
     */
    limit?: number
  }

  /**
   * BedAllocation.nurse
   */
  export type BedAllocation$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nurse
     */
    select?: NurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nurse
     */
    omit?: NurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseInclude<ExtArgs> | null
    where?: NurseWhereInput
  }

  /**
   * BedAllocation without action
   */
  export type BedAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedAllocation
     */
    select?: BedAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedAllocation
     */
    omit?: BedAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedAllocationInclude<ExtArgs> | null
  }


  /**
   * Model VitalSign
   */

  export type AggregateVitalSign = {
    _count: VitalSignCountAggregateOutputType | null
    _avg: VitalSignAvgAggregateOutputType | null
    _sum: VitalSignSumAggregateOutputType | null
    _min: VitalSignMinAggregateOutputType | null
    _max: VitalSignMaxAggregateOutputType | null
  }

  export type VitalSignAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    recordedBy: number | null
    temperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respiratoryRate: number | null
    oxygenSaturation: number | null
    height: number | null
    weight: number | null
  }

  export type VitalSignSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    recordedBy: number | null
    temperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respiratoryRate: number | null
    oxygenSaturation: number | null
    height: number | null
    weight: number | null
  }

  export type VitalSignMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    recordedBy: number | null
    temperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respiratoryRate: number | null
    oxygenSaturation: number | null
    height: number | null
    weight: number | null
    notes: string | null
    recordedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VitalSignMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    recordedBy: number | null
    temperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respiratoryRate: number | null
    oxygenSaturation: number | null
    height: number | null
    weight: number | null
    notes: string | null
    recordedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VitalSignCountAggregateOutputType = {
    id: number
    patientId: number
    recordedBy: number
    temperature: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    heartRate: number
    respiratoryRate: number
    oxygenSaturation: number
    height: number
    weight: number
    notes: number
    recordedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VitalSignAvgAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    temperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygenSaturation?: true
    height?: true
    weight?: true
  }

  export type VitalSignSumAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    temperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygenSaturation?: true
    height?: true
    weight?: true
  }

  export type VitalSignMinAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    temperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygenSaturation?: true
    height?: true
    weight?: true
    notes?: true
    recordedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VitalSignMaxAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    temperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygenSaturation?: true
    height?: true
    weight?: true
    notes?: true
    recordedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VitalSignCountAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    temperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygenSaturation?: true
    height?: true
    weight?: true
    notes?: true
    recordedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VitalSignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSign to aggregate.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitalSigns
    **/
    _count?: true | VitalSignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalSignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalSignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalSignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalSignMaxAggregateInputType
  }

  export type GetVitalSignAggregateType<T extends VitalSignAggregateArgs> = {
        [P in keyof T & keyof AggregateVitalSign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitalSign[P]>
      : GetScalarType<T[P], AggregateVitalSign[P]>
  }




  export type VitalSignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithAggregationInput | VitalSignOrderByWithAggregationInput[]
    by: VitalSignScalarFieldEnum[] | VitalSignScalarFieldEnum
    having?: VitalSignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalSignCountAggregateInputType | true
    _avg?: VitalSignAvgAggregateInputType
    _sum?: VitalSignSumAggregateInputType
    _min?: VitalSignMinAggregateInputType
    _max?: VitalSignMaxAggregateInputType
  }

  export type VitalSignGroupByOutputType = {
    id: number
    patientId: number
    recordedBy: number
    temperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respiratoryRate: number | null
    oxygenSaturation: number | null
    height: number | null
    weight: number | null
    notes: string | null
    recordedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VitalSignCountAggregateOutputType | null
    _avg: VitalSignAvgAggregateOutputType | null
    _sum: VitalSignSumAggregateOutputType | null
    _min: VitalSignMinAggregateOutputType | null
    _max: VitalSignMaxAggregateOutputType | null
  }

  type GetVitalSignGroupByPayload<T extends VitalSignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalSignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalSignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalSignGroupByOutputType[P]>
            : GetScalarType<T[P], VitalSignGroupByOutputType[P]>
        }
      >
    >


  export type VitalSignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    recordedBy?: boolean
    temperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygenSaturation?: boolean
    height?: boolean
    weight?: boolean
    notes?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | NurseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    recordedBy?: boolean
    temperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygenSaturation?: boolean
    height?: boolean
    weight?: boolean
    notes?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | NurseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    recordedBy?: boolean
    temperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygenSaturation?: boolean
    height?: boolean
    weight?: boolean
    notes?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | NurseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectScalar = {
    id?: boolean
    patientId?: boolean
    recordedBy?: boolean
    temperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygenSaturation?: boolean
    height?: boolean
    weight?: boolean
    notes?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VitalSignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "recordedBy" | "temperature" | "bloodPressureSystolic" | "bloodPressureDiastolic" | "heartRate" | "respiratoryRate" | "oxygenSaturation" | "height" | "weight" | "notes" | "recordedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["vitalSign"]>
  export type VitalSignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | NurseDefaultArgs<ExtArgs>
  }
  export type VitalSignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | NurseDefaultArgs<ExtArgs>
  }
  export type VitalSignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nurse?: boolean | NurseDefaultArgs<ExtArgs>
  }

  export type $VitalSignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VitalSign"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      nurse: Prisma.$NursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      recordedBy: number
      temperature: number | null
      bloodPressureSystolic: number | null
      bloodPressureDiastolic: number | null
      heartRate: number | null
      respiratoryRate: number | null
      oxygenSaturation: number | null
      height: number | null
      weight: number | null
      notes: string | null
      recordedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vitalSign"]>
    composites: {}
  }

  type VitalSignGetPayload<S extends boolean | null | undefined | VitalSignDefaultArgs> = $Result.GetResult<Prisma.$VitalSignPayload, S>

  type VitalSignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalSignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalSignCountAggregateInputType | true
    }

  export interface VitalSignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VitalSign'], meta: { name: 'VitalSign' } }
    /**
     * Find zero or one VitalSign that matches the filter.
     * @param {VitalSignFindUniqueArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalSignFindUniqueArgs>(args: SelectSubset<T, VitalSignFindUniqueArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VitalSign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalSignFindUniqueOrThrowArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalSignFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalSignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindFirstArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalSignFindFirstArgs>(args?: SelectSubset<T, VitalSignFindFirstArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindFirstOrThrowArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalSignFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalSignFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitalSigns
     * const vitalSigns = await prisma.vitalSign.findMany()
     * 
     * // Get first 10 VitalSigns
     * const vitalSigns = await prisma.vitalSign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalSignFindManyArgs>(args?: SelectSubset<T, VitalSignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VitalSign.
     * @param {VitalSignCreateArgs} args - Arguments to create a VitalSign.
     * @example
     * // Create one VitalSign
     * const VitalSign = await prisma.vitalSign.create({
     *   data: {
     *     // ... data to create a VitalSign
     *   }
     * })
     * 
     */
    create<T extends VitalSignCreateArgs>(args: SelectSubset<T, VitalSignCreateArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VitalSigns.
     * @param {VitalSignCreateManyArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSign = await prisma.vitalSign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalSignCreateManyArgs>(args?: SelectSubset<T, VitalSignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VitalSigns and returns the data saved in the database.
     * @param {VitalSignCreateManyAndReturnArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSign = await prisma.vitalSign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VitalSigns and only return the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VitalSignCreateManyAndReturnArgs>(args?: SelectSubset<T, VitalSignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VitalSign.
     * @param {VitalSignDeleteArgs} args - Arguments to delete one VitalSign.
     * @example
     * // Delete one VitalSign
     * const VitalSign = await prisma.vitalSign.delete({
     *   where: {
     *     // ... filter to delete one VitalSign
     *   }
     * })
     * 
     */
    delete<T extends VitalSignDeleteArgs>(args: SelectSubset<T, VitalSignDeleteArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VitalSign.
     * @param {VitalSignUpdateArgs} args - Arguments to update one VitalSign.
     * @example
     * // Update one VitalSign
     * const vitalSign = await prisma.vitalSign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalSignUpdateArgs>(args: SelectSubset<T, VitalSignUpdateArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VitalSigns.
     * @param {VitalSignDeleteManyArgs} args - Arguments to filter VitalSigns to delete.
     * @example
     * // Delete a few VitalSigns
     * const { count } = await prisma.vitalSign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalSignDeleteManyArgs>(args?: SelectSubset<T, VitalSignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitalSigns
     * const vitalSign = await prisma.vitalSign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalSignUpdateManyArgs>(args: SelectSubset<T, VitalSignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns and returns the data updated in the database.
     * @param {VitalSignUpdateManyAndReturnArgs} args - Arguments to update many VitalSigns.
     * @example
     * // Update many VitalSigns
     * const vitalSign = await prisma.vitalSign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VitalSigns and only return the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VitalSignUpdateManyAndReturnArgs>(args: SelectSubset<T, VitalSignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VitalSign.
     * @param {VitalSignUpsertArgs} args - Arguments to update or create a VitalSign.
     * @example
     * // Update or create a VitalSign
     * const vitalSign = await prisma.vitalSign.upsert({
     *   create: {
     *     // ... data to create a VitalSign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitalSign we want to update
     *   }
     * })
     */
    upsert<T extends VitalSignUpsertArgs>(args: SelectSubset<T, VitalSignUpsertArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignCountArgs} args - Arguments to filter VitalSigns to count.
     * @example
     * // Count the number of VitalSigns
     * const count = await prisma.vitalSign.count({
     *   where: {
     *     // ... the filter for the VitalSigns we want to count
     *   }
     * })
    **/
    count<T extends VitalSignCountArgs>(
      args?: Subset<T, VitalSignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalSignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitalSign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalSignAggregateArgs>(args: Subset<T, VitalSignAggregateArgs>): Prisma.PrismaPromise<GetVitalSignAggregateType<T>>

    /**
     * Group by VitalSign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalSignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalSignGroupByArgs['orderBy'] }
        : { orderBy?: VitalSignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalSignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalSignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VitalSign model
   */
  readonly fields: VitalSignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitalSign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalSignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nurse<T extends NurseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NurseDefaultArgs<ExtArgs>>): Prisma__NurseClient<$Result.GetResult<Prisma.$NursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VitalSign model
   */
  interface VitalSignFieldRefs {
    readonly id: FieldRef<"VitalSign", 'Int'>
    readonly patientId: FieldRef<"VitalSign", 'Int'>
    readonly recordedBy: FieldRef<"VitalSign", 'Int'>
    readonly temperature: FieldRef<"VitalSign", 'Float'>
    readonly bloodPressureSystolic: FieldRef<"VitalSign", 'Int'>
    readonly bloodPressureDiastolic: FieldRef<"VitalSign", 'Int'>
    readonly heartRate: FieldRef<"VitalSign", 'Int'>
    readonly respiratoryRate: FieldRef<"VitalSign", 'Int'>
    readonly oxygenSaturation: FieldRef<"VitalSign", 'Float'>
    readonly height: FieldRef<"VitalSign", 'Float'>
    readonly weight: FieldRef<"VitalSign", 'Float'>
    readonly notes: FieldRef<"VitalSign", 'String'>
    readonly recordedAt: FieldRef<"VitalSign", 'DateTime'>
    readonly createdAt: FieldRef<"VitalSign", 'DateTime'>
    readonly updatedAt: FieldRef<"VitalSign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VitalSign findUnique
   */
  export type VitalSignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign findUniqueOrThrow
   */
  export type VitalSignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign findFirst
   */
  export type VitalSignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign findFirstOrThrow
   */
  export type VitalSignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign findMany
   */
  export type VitalSignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign create
   */
  export type VitalSignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The data needed to create a VitalSign.
     */
    data: XOR<VitalSignCreateInput, VitalSignUncheckedCreateInput>
  }

  /**
   * VitalSign createMany
   */
  export type VitalSignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignCreateManyInput | VitalSignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VitalSign createManyAndReturn
   */
  export type VitalSignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignCreateManyInput | VitalSignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSign update
   */
  export type VitalSignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The data needed to update a VitalSign.
     */
    data: XOR<VitalSignUpdateInput, VitalSignUncheckedUpdateInput>
    /**
     * Choose, which VitalSign to update.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign updateMany
   */
  export type VitalSignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
  }

  /**
   * VitalSign updateManyAndReturn
   */
  export type VitalSignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSign upsert
   */
  export type VitalSignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The filter to search for the VitalSign to update in case it exists.
     */
    where: VitalSignWhereUniqueInput
    /**
     * In case the VitalSign found by the `where` argument doesn't exist, create a new VitalSign with this data.
     */
    create: XOR<VitalSignCreateInput, VitalSignUncheckedCreateInput>
    /**
     * In case the VitalSign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalSignUpdateInput, VitalSignUncheckedUpdateInput>
  }

  /**
   * VitalSign delete
   */
  export type VitalSignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter which VitalSign to delete.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign deleteMany
   */
  export type VitalSignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to delete
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to delete.
     */
    limit?: number
  }

  /**
   * VitalSign without action
   */
  export type VitalSignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
  }


  /**
   * Model OperationTheater
   */

  export type AggregateOperationTheater = {
    _count: OperationTheaterCountAggregateOutputType | null
    _avg: OperationTheaterAvgAggregateOutputType | null
    _sum: OperationTheaterSumAggregateOutputType | null
    _min: OperationTheaterMinAggregateOutputType | null
    _max: OperationTheaterMaxAggregateOutputType | null
  }

  export type OperationTheaterAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
  }

  export type OperationTheaterSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
  }

  export type OperationTheaterMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    status: string | null
    doctorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperationTheaterMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    status: string | null
    doctorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperationTheaterCountAggregateOutputType = {
    id: number
    name: number
    location: number
    status: number
    doctorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperationTheaterAvgAggregateInputType = {
    id?: true
    doctorId?: true
  }

  export type OperationTheaterSumAggregateInputType = {
    id?: true
    doctorId?: true
  }

  export type OperationTheaterMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    status?: true
    doctorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperationTheaterMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    status?: true
    doctorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperationTheaterCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    status?: true
    doctorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperationTheaterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationTheater to aggregate.
     */
    where?: OperationTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaters to fetch.
     */
    orderBy?: OperationTheaterOrderByWithRelationInput | OperationTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationTheaters
    **/
    _count?: true | OperationTheaterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationTheaterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationTheaterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationTheaterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationTheaterMaxAggregateInputType
  }

  export type GetOperationTheaterAggregateType<T extends OperationTheaterAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationTheater]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationTheater[P]>
      : GetScalarType<T[P], AggregateOperationTheater[P]>
  }




  export type OperationTheaterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationTheaterWhereInput
    orderBy?: OperationTheaterOrderByWithAggregationInput | OperationTheaterOrderByWithAggregationInput[]
    by: OperationTheaterScalarFieldEnum[] | OperationTheaterScalarFieldEnum
    having?: OperationTheaterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationTheaterCountAggregateInputType | true
    _avg?: OperationTheaterAvgAggregateInputType
    _sum?: OperationTheaterSumAggregateInputType
    _min?: OperationTheaterMinAggregateInputType
    _max?: OperationTheaterMaxAggregateInputType
  }

  export type OperationTheaterGroupByOutputType = {
    id: number
    name: string
    location: string | null
    status: string
    doctorId: number | null
    createdAt: Date
    updatedAt: Date
    _count: OperationTheaterCountAggregateOutputType | null
    _avg: OperationTheaterAvgAggregateOutputType | null
    _sum: OperationTheaterSumAggregateOutputType | null
    _min: OperationTheaterMinAggregateOutputType | null
    _max: OperationTheaterMaxAggregateOutputType | null
  }

  type GetOperationTheaterGroupByPayload<T extends OperationTheaterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationTheaterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationTheaterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationTheaterGroupByOutputType[P]>
            : GetScalarType<T[P], OperationTheaterGroupByOutputType[P]>
        }
      >
    >


  export type OperationTheaterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    doctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | OperationTheater$doctorArgs<ExtArgs>
    surgeries?: boolean | OperationTheater$surgeriesArgs<ExtArgs>
    equipments?: boolean | OperationTheater$equipmentsArgs<ExtArgs>
    _count?: boolean | OperationTheaterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationTheater"]>

  export type OperationTheaterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    doctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | OperationTheater$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["operationTheater"]>

  export type OperationTheaterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    doctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | OperationTheater$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["operationTheater"]>

  export type OperationTheaterSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    doctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperationTheaterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "status" | "doctorId" | "createdAt" | "updatedAt", ExtArgs["result"]["operationTheater"]>
  export type OperationTheaterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | OperationTheater$doctorArgs<ExtArgs>
    surgeries?: boolean | OperationTheater$surgeriesArgs<ExtArgs>
    equipments?: boolean | OperationTheater$equipmentsArgs<ExtArgs>
    _count?: boolean | OperationTheaterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OperationTheaterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | OperationTheater$doctorArgs<ExtArgs>
  }
  export type OperationTheaterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | OperationTheater$doctorArgs<ExtArgs>
  }

  export type $OperationTheaterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationTheater"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
      surgeries: Prisma.$SurgeryPayload<ExtArgs>[]
      equipments: Prisma.$OperationTheaterEquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      status: string
      doctorId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operationTheater"]>
    composites: {}
  }

  type OperationTheaterGetPayload<S extends boolean | null | undefined | OperationTheaterDefaultArgs> = $Result.GetResult<Prisma.$OperationTheaterPayload, S>

  type OperationTheaterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperationTheaterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperationTheaterCountAggregateInputType | true
    }

  export interface OperationTheaterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationTheater'], meta: { name: 'OperationTheater' } }
    /**
     * Find zero or one OperationTheater that matches the filter.
     * @param {OperationTheaterFindUniqueArgs} args - Arguments to find a OperationTheater
     * @example
     * // Get one OperationTheater
     * const operationTheater = await prisma.operationTheater.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationTheaterFindUniqueArgs>(args: SelectSubset<T, OperationTheaterFindUniqueArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperationTheater that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperationTheaterFindUniqueOrThrowArgs} args - Arguments to find a OperationTheater
     * @example
     * // Get one OperationTheater
     * const operationTheater = await prisma.operationTheater.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationTheaterFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationTheaterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperationTheater that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterFindFirstArgs} args - Arguments to find a OperationTheater
     * @example
     * // Get one OperationTheater
     * const operationTheater = await prisma.operationTheater.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationTheaterFindFirstArgs>(args?: SelectSubset<T, OperationTheaterFindFirstArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperationTheater that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterFindFirstOrThrowArgs} args - Arguments to find a OperationTheater
     * @example
     * // Get one OperationTheater
     * const operationTheater = await prisma.operationTheater.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationTheaterFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationTheaterFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperationTheaters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationTheaters
     * const operationTheaters = await prisma.operationTheater.findMany()
     * 
     * // Get first 10 OperationTheaters
     * const operationTheaters = await prisma.operationTheater.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationTheaterWithIdOnly = await prisma.operationTheater.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationTheaterFindManyArgs>(args?: SelectSubset<T, OperationTheaterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperationTheater.
     * @param {OperationTheaterCreateArgs} args - Arguments to create a OperationTheater.
     * @example
     * // Create one OperationTheater
     * const OperationTheater = await prisma.operationTheater.create({
     *   data: {
     *     // ... data to create a OperationTheater
     *   }
     * })
     * 
     */
    create<T extends OperationTheaterCreateArgs>(args: SelectSubset<T, OperationTheaterCreateArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperationTheaters.
     * @param {OperationTheaterCreateManyArgs} args - Arguments to create many OperationTheaters.
     * @example
     * // Create many OperationTheaters
     * const operationTheater = await prisma.operationTheater.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationTheaterCreateManyArgs>(args?: SelectSubset<T, OperationTheaterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationTheaters and returns the data saved in the database.
     * @param {OperationTheaterCreateManyAndReturnArgs} args - Arguments to create many OperationTheaters.
     * @example
     * // Create many OperationTheaters
     * const operationTheater = await prisma.operationTheater.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationTheaters and only return the `id`
     * const operationTheaterWithIdOnly = await prisma.operationTheater.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperationTheaterCreateManyAndReturnArgs>(args?: SelectSubset<T, OperationTheaterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperationTheater.
     * @param {OperationTheaterDeleteArgs} args - Arguments to delete one OperationTheater.
     * @example
     * // Delete one OperationTheater
     * const OperationTheater = await prisma.operationTheater.delete({
     *   where: {
     *     // ... filter to delete one OperationTheater
     *   }
     * })
     * 
     */
    delete<T extends OperationTheaterDeleteArgs>(args: SelectSubset<T, OperationTheaterDeleteArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperationTheater.
     * @param {OperationTheaterUpdateArgs} args - Arguments to update one OperationTheater.
     * @example
     * // Update one OperationTheater
     * const operationTheater = await prisma.operationTheater.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationTheaterUpdateArgs>(args: SelectSubset<T, OperationTheaterUpdateArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperationTheaters.
     * @param {OperationTheaterDeleteManyArgs} args - Arguments to filter OperationTheaters to delete.
     * @example
     * // Delete a few OperationTheaters
     * const { count } = await prisma.operationTheater.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationTheaterDeleteManyArgs>(args?: SelectSubset<T, OperationTheaterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationTheaters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationTheaters
     * const operationTheater = await prisma.operationTheater.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationTheaterUpdateManyArgs>(args: SelectSubset<T, OperationTheaterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationTheaters and returns the data updated in the database.
     * @param {OperationTheaterUpdateManyAndReturnArgs} args - Arguments to update many OperationTheaters.
     * @example
     * // Update many OperationTheaters
     * const operationTheater = await prisma.operationTheater.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperationTheaters and only return the `id`
     * const operationTheaterWithIdOnly = await prisma.operationTheater.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperationTheaterUpdateManyAndReturnArgs>(args: SelectSubset<T, OperationTheaterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperationTheater.
     * @param {OperationTheaterUpsertArgs} args - Arguments to update or create a OperationTheater.
     * @example
     * // Update or create a OperationTheater
     * const operationTheater = await prisma.operationTheater.upsert({
     *   create: {
     *     // ... data to create a OperationTheater
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationTheater we want to update
     *   }
     * })
     */
    upsert<T extends OperationTheaterUpsertArgs>(args: SelectSubset<T, OperationTheaterUpsertArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperationTheaters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterCountArgs} args - Arguments to filter OperationTheaters to count.
     * @example
     * // Count the number of OperationTheaters
     * const count = await prisma.operationTheater.count({
     *   where: {
     *     // ... the filter for the OperationTheaters we want to count
     *   }
     * })
    **/
    count<T extends OperationTheaterCountArgs>(
      args?: Subset<T, OperationTheaterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationTheaterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationTheater.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationTheaterAggregateArgs>(args: Subset<T, OperationTheaterAggregateArgs>): Prisma.PrismaPromise<GetOperationTheaterAggregateType<T>>

    /**
     * Group by OperationTheater.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationTheaterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationTheaterGroupByArgs['orderBy'] }
        : { orderBy?: OperationTheaterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationTheaterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationTheaterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationTheater model
   */
  readonly fields: OperationTheaterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationTheater.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationTheaterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends OperationTheater$doctorArgs<ExtArgs> = {}>(args?: Subset<T, OperationTheater$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    surgeries<T extends OperationTheater$surgeriesArgs<ExtArgs> = {}>(args?: Subset<T, OperationTheater$surgeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipments<T extends OperationTheater$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, OperationTheater$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationTheater model
   */
  interface OperationTheaterFieldRefs {
    readonly id: FieldRef<"OperationTheater", 'Int'>
    readonly name: FieldRef<"OperationTheater", 'String'>
    readonly location: FieldRef<"OperationTheater", 'String'>
    readonly status: FieldRef<"OperationTheater", 'String'>
    readonly doctorId: FieldRef<"OperationTheater", 'Int'>
    readonly createdAt: FieldRef<"OperationTheater", 'DateTime'>
    readonly updatedAt: FieldRef<"OperationTheater", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationTheater findUnique
   */
  export type OperationTheaterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheater to fetch.
     */
    where: OperationTheaterWhereUniqueInput
  }

  /**
   * OperationTheater findUniqueOrThrow
   */
  export type OperationTheaterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheater to fetch.
     */
    where: OperationTheaterWhereUniqueInput
  }

  /**
   * OperationTheater findFirst
   */
  export type OperationTheaterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheater to fetch.
     */
    where?: OperationTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaters to fetch.
     */
    orderBy?: OperationTheaterOrderByWithRelationInput | OperationTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationTheaters.
     */
    cursor?: OperationTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationTheaters.
     */
    distinct?: OperationTheaterScalarFieldEnum | OperationTheaterScalarFieldEnum[]
  }

  /**
   * OperationTheater findFirstOrThrow
   */
  export type OperationTheaterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheater to fetch.
     */
    where?: OperationTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaters to fetch.
     */
    orderBy?: OperationTheaterOrderByWithRelationInput | OperationTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationTheaters.
     */
    cursor?: OperationTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationTheaters.
     */
    distinct?: OperationTheaterScalarFieldEnum | OperationTheaterScalarFieldEnum[]
  }

  /**
   * OperationTheater findMany
   */
  export type OperationTheaterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheaters to fetch.
     */
    where?: OperationTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaters to fetch.
     */
    orderBy?: OperationTheaterOrderByWithRelationInput | OperationTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationTheaters.
     */
    cursor?: OperationTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaters.
     */
    skip?: number
    distinct?: OperationTheaterScalarFieldEnum | OperationTheaterScalarFieldEnum[]
  }

  /**
   * OperationTheater create
   */
  export type OperationTheaterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationTheater.
     */
    data: XOR<OperationTheaterCreateInput, OperationTheaterUncheckedCreateInput>
  }

  /**
   * OperationTheater createMany
   */
  export type OperationTheaterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationTheaters.
     */
    data: OperationTheaterCreateManyInput | OperationTheaterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationTheater createManyAndReturn
   */
  export type OperationTheaterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * The data used to create many OperationTheaters.
     */
    data: OperationTheaterCreateManyInput | OperationTheaterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationTheater update
   */
  export type OperationTheaterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationTheater.
     */
    data: XOR<OperationTheaterUpdateInput, OperationTheaterUncheckedUpdateInput>
    /**
     * Choose, which OperationTheater to update.
     */
    where: OperationTheaterWhereUniqueInput
  }

  /**
   * OperationTheater updateMany
   */
  export type OperationTheaterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationTheaters.
     */
    data: XOR<OperationTheaterUpdateManyMutationInput, OperationTheaterUncheckedUpdateManyInput>
    /**
     * Filter which OperationTheaters to update
     */
    where?: OperationTheaterWhereInput
    /**
     * Limit how many OperationTheaters to update.
     */
    limit?: number
  }

  /**
   * OperationTheater updateManyAndReturn
   */
  export type OperationTheaterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * The data used to update OperationTheaters.
     */
    data: XOR<OperationTheaterUpdateManyMutationInput, OperationTheaterUncheckedUpdateManyInput>
    /**
     * Filter which OperationTheaters to update
     */
    where?: OperationTheaterWhereInput
    /**
     * Limit how many OperationTheaters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationTheater upsert
   */
  export type OperationTheaterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationTheater to update in case it exists.
     */
    where: OperationTheaterWhereUniqueInput
    /**
     * In case the OperationTheater found by the `where` argument doesn't exist, create a new OperationTheater with this data.
     */
    create: XOR<OperationTheaterCreateInput, OperationTheaterUncheckedCreateInput>
    /**
     * In case the OperationTheater was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationTheaterUpdateInput, OperationTheaterUncheckedUpdateInput>
  }

  /**
   * OperationTheater delete
   */
  export type OperationTheaterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
    /**
     * Filter which OperationTheater to delete.
     */
    where: OperationTheaterWhereUniqueInput
  }

  /**
   * OperationTheater deleteMany
   */
  export type OperationTheaterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationTheaters to delete
     */
    where?: OperationTheaterWhereInput
    /**
     * Limit how many OperationTheaters to delete.
     */
    limit?: number
  }

  /**
   * OperationTheater.doctor
   */
  export type OperationTheater$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * OperationTheater.surgeries
   */
  export type OperationTheater$surgeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    where?: SurgeryWhereInput
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    cursor?: SurgeryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * OperationTheater.equipments
   */
  export type OperationTheater$equipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    where?: OperationTheaterEquipmentWhereInput
    orderBy?: OperationTheaterEquipmentOrderByWithRelationInput | OperationTheaterEquipmentOrderByWithRelationInput[]
    cursor?: OperationTheaterEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationTheaterEquipmentScalarFieldEnum | OperationTheaterEquipmentScalarFieldEnum[]
  }

  /**
   * OperationTheater without action
   */
  export type OperationTheaterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheater
     */
    select?: OperationTheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheater
     */
    omit?: OperationTheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterInclude<ExtArgs> | null
  }


  /**
   * Model Surgery
   */

  export type AggregateSurgery = {
    _count: SurgeryCountAggregateOutputType | null
    _avg: SurgeryAvgAggregateOutputType | null
    _sum: SurgerySumAggregateOutputType | null
    _min: SurgeryMinAggregateOutputType | null
    _max: SurgeryMaxAggregateOutputType | null
  }

  export type SurgeryAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    operationTheaterId: number | null
  }

  export type SurgerySumAggregateOutputType = {
    id: number | null
    patientId: number | null
    operationTheaterId: number | null
  }

  export type SurgeryMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    operationTheaterId: number | null
    surgeryDate: Date | null
    startTime: string | null
    endTime: string | null
    surgeryType: string | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurgeryMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    operationTheaterId: number | null
    surgeryDate: Date | null
    startTime: string | null
    endTime: string | null
    surgeryType: string | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurgeryCountAggregateOutputType = {
    id: number
    patientId: number
    operationTheaterId: number
    surgeryDate: number
    startTime: number
    endTime: number
    surgeryType: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurgeryAvgAggregateInputType = {
    id?: true
    patientId?: true
    operationTheaterId?: true
  }

  export type SurgerySumAggregateInputType = {
    id?: true
    patientId?: true
    operationTheaterId?: true
  }

  export type SurgeryMinAggregateInputType = {
    id?: true
    patientId?: true
    operationTheaterId?: true
    surgeryDate?: true
    startTime?: true
    endTime?: true
    surgeryType?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurgeryMaxAggregateInputType = {
    id?: true
    patientId?: true
    operationTheaterId?: true
    surgeryDate?: true
    startTime?: true
    endTime?: true
    surgeryType?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurgeryCountAggregateInputType = {
    id?: true
    patientId?: true
    operationTheaterId?: true
    surgeryDate?: true
    startTime?: true
    endTime?: true
    surgeryType?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurgeryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surgery to aggregate.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surgeries
    **/
    _count?: true | SurgeryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurgeryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurgerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurgeryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurgeryMaxAggregateInputType
  }

  export type GetSurgeryAggregateType<T extends SurgeryAggregateArgs> = {
        [P in keyof T & keyof AggregateSurgery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurgery[P]>
      : GetScalarType<T[P], AggregateSurgery[P]>
  }




  export type SurgeryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgeryWhereInput
    orderBy?: SurgeryOrderByWithAggregationInput | SurgeryOrderByWithAggregationInput[]
    by: SurgeryScalarFieldEnum[] | SurgeryScalarFieldEnum
    having?: SurgeryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurgeryCountAggregateInputType | true
    _avg?: SurgeryAvgAggregateInputType
    _sum?: SurgerySumAggregateInputType
    _min?: SurgeryMinAggregateInputType
    _max?: SurgeryMaxAggregateInputType
  }

  export type SurgeryGroupByOutputType = {
    id: number
    patientId: number
    operationTheaterId: number
    surgeryDate: Date
    startTime: string
    endTime: string
    surgeryType: string
    notes: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SurgeryCountAggregateOutputType | null
    _avg: SurgeryAvgAggregateOutputType | null
    _sum: SurgerySumAggregateOutputType | null
    _min: SurgeryMinAggregateOutputType | null
    _max: SurgeryMaxAggregateOutputType | null
  }

  type GetSurgeryGroupByPayload<T extends SurgeryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurgeryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurgeryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurgeryGroupByOutputType[P]>
            : GetScalarType<T[P], SurgeryGroupByOutputType[P]>
        }
      >
    >


  export type SurgerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    operationTheaterId?: boolean
    surgeryDate?: boolean
    startTime?: boolean
    endTime?: boolean
    surgeryType?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgery"]>

  export type SurgerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    operationTheaterId?: boolean
    surgeryDate?: boolean
    startTime?: boolean
    endTime?: boolean
    surgeryType?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgery"]>

  export type SurgerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    operationTheaterId?: boolean
    surgeryDate?: boolean
    startTime?: boolean
    endTime?: boolean
    surgeryType?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgery"]>

  export type SurgerySelectScalar = {
    id?: boolean
    patientId?: boolean
    operationTheaterId?: boolean
    surgeryDate?: boolean
    startTime?: boolean
    endTime?: boolean
    surgeryType?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SurgeryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "operationTheaterId" | "surgeryDate" | "startTime" | "endTime" | "surgeryType" | "notes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["surgery"]>
  export type SurgeryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }
  export type SurgeryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }
  export type SurgeryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }

  export type $SurgeryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Surgery"
    objects: {
      operationTheater: Prisma.$OperationTheaterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      operationTheaterId: number
      surgeryDate: Date
      startTime: string
      endTime: string
      surgeryType: string
      notes: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["surgery"]>
    composites: {}
  }

  type SurgeryGetPayload<S extends boolean | null | undefined | SurgeryDefaultArgs> = $Result.GetResult<Prisma.$SurgeryPayload, S>

  type SurgeryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurgeryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurgeryCountAggregateInputType | true
    }

  export interface SurgeryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Surgery'], meta: { name: 'Surgery' } }
    /**
     * Find zero or one Surgery that matches the filter.
     * @param {SurgeryFindUniqueArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurgeryFindUniqueArgs>(args: SelectSubset<T, SurgeryFindUniqueArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Surgery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurgeryFindUniqueOrThrowArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurgeryFindUniqueOrThrowArgs>(args: SelectSubset<T, SurgeryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surgery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryFindFirstArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurgeryFindFirstArgs>(args?: SelectSubset<T, SurgeryFindFirstArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surgery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryFindFirstOrThrowArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurgeryFindFirstOrThrowArgs>(args?: SelectSubset<T, SurgeryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Surgeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surgeries
     * const surgeries = await prisma.surgery.findMany()
     * 
     * // Get first 10 Surgeries
     * const surgeries = await prisma.surgery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surgeryWithIdOnly = await prisma.surgery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurgeryFindManyArgs>(args?: SelectSubset<T, SurgeryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Surgery.
     * @param {SurgeryCreateArgs} args - Arguments to create a Surgery.
     * @example
     * // Create one Surgery
     * const Surgery = await prisma.surgery.create({
     *   data: {
     *     // ... data to create a Surgery
     *   }
     * })
     * 
     */
    create<T extends SurgeryCreateArgs>(args: SelectSubset<T, SurgeryCreateArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Surgeries.
     * @param {SurgeryCreateManyArgs} args - Arguments to create many Surgeries.
     * @example
     * // Create many Surgeries
     * const surgery = await prisma.surgery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurgeryCreateManyArgs>(args?: SelectSubset<T, SurgeryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surgeries and returns the data saved in the database.
     * @param {SurgeryCreateManyAndReturnArgs} args - Arguments to create many Surgeries.
     * @example
     * // Create many Surgeries
     * const surgery = await prisma.surgery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surgeries and only return the `id`
     * const surgeryWithIdOnly = await prisma.surgery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurgeryCreateManyAndReturnArgs>(args?: SelectSubset<T, SurgeryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Surgery.
     * @param {SurgeryDeleteArgs} args - Arguments to delete one Surgery.
     * @example
     * // Delete one Surgery
     * const Surgery = await prisma.surgery.delete({
     *   where: {
     *     // ... filter to delete one Surgery
     *   }
     * })
     * 
     */
    delete<T extends SurgeryDeleteArgs>(args: SelectSubset<T, SurgeryDeleteArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Surgery.
     * @param {SurgeryUpdateArgs} args - Arguments to update one Surgery.
     * @example
     * // Update one Surgery
     * const surgery = await prisma.surgery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurgeryUpdateArgs>(args: SelectSubset<T, SurgeryUpdateArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Surgeries.
     * @param {SurgeryDeleteManyArgs} args - Arguments to filter Surgeries to delete.
     * @example
     * // Delete a few Surgeries
     * const { count } = await prisma.surgery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurgeryDeleteManyArgs>(args?: SelectSubset<T, SurgeryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surgeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surgeries
     * const surgery = await prisma.surgery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurgeryUpdateManyArgs>(args: SelectSubset<T, SurgeryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surgeries and returns the data updated in the database.
     * @param {SurgeryUpdateManyAndReturnArgs} args - Arguments to update many Surgeries.
     * @example
     * // Update many Surgeries
     * const surgery = await prisma.surgery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Surgeries and only return the `id`
     * const surgeryWithIdOnly = await prisma.surgery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurgeryUpdateManyAndReturnArgs>(args: SelectSubset<T, SurgeryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Surgery.
     * @param {SurgeryUpsertArgs} args - Arguments to update or create a Surgery.
     * @example
     * // Update or create a Surgery
     * const surgery = await prisma.surgery.upsert({
     *   create: {
     *     // ... data to create a Surgery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surgery we want to update
     *   }
     * })
     */
    upsert<T extends SurgeryUpsertArgs>(args: SelectSubset<T, SurgeryUpsertArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Surgeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryCountArgs} args - Arguments to filter Surgeries to count.
     * @example
     * // Count the number of Surgeries
     * const count = await prisma.surgery.count({
     *   where: {
     *     // ... the filter for the Surgeries we want to count
     *   }
     * })
    **/
    count<T extends SurgeryCountArgs>(
      args?: Subset<T, SurgeryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurgeryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surgery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurgeryAggregateArgs>(args: Subset<T, SurgeryAggregateArgs>): Prisma.PrismaPromise<GetSurgeryAggregateType<T>>

    /**
     * Group by Surgery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurgeryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurgeryGroupByArgs['orderBy'] }
        : { orderBy?: SurgeryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurgeryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurgeryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Surgery model
   */
  readonly fields: SurgeryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Surgery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurgeryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operationTheater<T extends OperationTheaterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationTheaterDefaultArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Surgery model
   */
  interface SurgeryFieldRefs {
    readonly id: FieldRef<"Surgery", 'Int'>
    readonly patientId: FieldRef<"Surgery", 'Int'>
    readonly operationTheaterId: FieldRef<"Surgery", 'Int'>
    readonly surgeryDate: FieldRef<"Surgery", 'DateTime'>
    readonly startTime: FieldRef<"Surgery", 'String'>
    readonly endTime: FieldRef<"Surgery", 'String'>
    readonly surgeryType: FieldRef<"Surgery", 'String'>
    readonly notes: FieldRef<"Surgery", 'String'>
    readonly status: FieldRef<"Surgery", 'String'>
    readonly createdAt: FieldRef<"Surgery", 'DateTime'>
    readonly updatedAt: FieldRef<"Surgery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Surgery findUnique
   */
  export type SurgeryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery findUniqueOrThrow
   */
  export type SurgeryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery findFirst
   */
  export type SurgeryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surgeries.
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surgeries.
     */
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Surgery findFirstOrThrow
   */
  export type SurgeryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surgeries.
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surgeries.
     */
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Surgery findMany
   */
  export type SurgeryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgeries to fetch.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surgeries.
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Surgery create
   */
  export type SurgeryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * The data needed to create a Surgery.
     */
    data: XOR<SurgeryCreateInput, SurgeryUncheckedCreateInput>
  }

  /**
   * Surgery createMany
   */
  export type SurgeryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Surgeries.
     */
    data: SurgeryCreateManyInput | SurgeryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Surgery createManyAndReturn
   */
  export type SurgeryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * The data used to create many Surgeries.
     */
    data: SurgeryCreateManyInput | SurgeryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Surgery update
   */
  export type SurgeryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * The data needed to update a Surgery.
     */
    data: XOR<SurgeryUpdateInput, SurgeryUncheckedUpdateInput>
    /**
     * Choose, which Surgery to update.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery updateMany
   */
  export type SurgeryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Surgeries.
     */
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyInput>
    /**
     * Filter which Surgeries to update
     */
    where?: SurgeryWhereInput
    /**
     * Limit how many Surgeries to update.
     */
    limit?: number
  }

  /**
   * Surgery updateManyAndReturn
   */
  export type SurgeryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * The data used to update Surgeries.
     */
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyInput>
    /**
     * Filter which Surgeries to update
     */
    where?: SurgeryWhereInput
    /**
     * Limit how many Surgeries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Surgery upsert
   */
  export type SurgeryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * The filter to search for the Surgery to update in case it exists.
     */
    where: SurgeryWhereUniqueInput
    /**
     * In case the Surgery found by the `where` argument doesn't exist, create a new Surgery with this data.
     */
    create: XOR<SurgeryCreateInput, SurgeryUncheckedCreateInput>
    /**
     * In case the Surgery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurgeryUpdateInput, SurgeryUncheckedUpdateInput>
  }

  /**
   * Surgery delete
   */
  export type SurgeryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter which Surgery to delete.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery deleteMany
   */
  export type SurgeryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surgeries to delete
     */
    where?: SurgeryWhereInput
    /**
     * Limit how many Surgeries to delete.
     */
    limit?: number
  }

  /**
   * Surgery without action
   */
  export type SurgeryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
  }


  /**
   * Model OperationTheaterEquipment
   */

  export type AggregateOperationTheaterEquipment = {
    _count: OperationTheaterEquipmentCountAggregateOutputType | null
    _avg: OperationTheaterEquipmentAvgAggregateOutputType | null
    _sum: OperationTheaterEquipmentSumAggregateOutputType | null
    _min: OperationTheaterEquipmentMinAggregateOutputType | null
    _max: OperationTheaterEquipmentMaxAggregateOutputType | null
  }

  export type OperationTheaterEquipmentAvgAggregateOutputType = {
    id: number | null
    operationTheaterId: number | null
  }

  export type OperationTheaterEquipmentSumAggregateOutputType = {
    id: number | null
    operationTheaterId: number | null
  }

  export type OperationTheaterEquipmentMinAggregateOutputType = {
    id: number | null
    operationTheaterId: number | null
    name: string | null
    serialNumber: string | null
    manufacturer: string | null
    purchaseDate: Date | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperationTheaterEquipmentMaxAggregateOutputType = {
    id: number | null
    operationTheaterId: number | null
    name: string | null
    serialNumber: string | null
    manufacturer: string | null
    purchaseDate: Date | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperationTheaterEquipmentCountAggregateOutputType = {
    id: number
    operationTheaterId: number
    name: number
    serialNumber: number
    manufacturer: number
    purchaseDate: number
    lastMaintenanceDate: number
    nextMaintenanceDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperationTheaterEquipmentAvgAggregateInputType = {
    id?: true
    operationTheaterId?: true
  }

  export type OperationTheaterEquipmentSumAggregateInputType = {
    id?: true
    operationTheaterId?: true
  }

  export type OperationTheaterEquipmentMinAggregateInputType = {
    id?: true
    operationTheaterId?: true
    name?: true
    serialNumber?: true
    manufacturer?: true
    purchaseDate?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperationTheaterEquipmentMaxAggregateInputType = {
    id?: true
    operationTheaterId?: true
    name?: true
    serialNumber?: true
    manufacturer?: true
    purchaseDate?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperationTheaterEquipmentCountAggregateInputType = {
    id?: true
    operationTheaterId?: true
    name?: true
    serialNumber?: true
    manufacturer?: true
    purchaseDate?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperationTheaterEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationTheaterEquipment to aggregate.
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaterEquipments to fetch.
     */
    orderBy?: OperationTheaterEquipmentOrderByWithRelationInput | OperationTheaterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationTheaterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationTheaterEquipments
    **/
    _count?: true | OperationTheaterEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationTheaterEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationTheaterEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationTheaterEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationTheaterEquipmentMaxAggregateInputType
  }

  export type GetOperationTheaterEquipmentAggregateType<T extends OperationTheaterEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationTheaterEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationTheaterEquipment[P]>
      : GetScalarType<T[P], AggregateOperationTheaterEquipment[P]>
  }




  export type OperationTheaterEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationTheaterEquipmentWhereInput
    orderBy?: OperationTheaterEquipmentOrderByWithAggregationInput | OperationTheaterEquipmentOrderByWithAggregationInput[]
    by: OperationTheaterEquipmentScalarFieldEnum[] | OperationTheaterEquipmentScalarFieldEnum
    having?: OperationTheaterEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationTheaterEquipmentCountAggregateInputType | true
    _avg?: OperationTheaterEquipmentAvgAggregateInputType
    _sum?: OperationTheaterEquipmentSumAggregateInputType
    _min?: OperationTheaterEquipmentMinAggregateInputType
    _max?: OperationTheaterEquipmentMaxAggregateInputType
  }

  export type OperationTheaterEquipmentGroupByOutputType = {
    id: number
    operationTheaterId: number
    name: string
    serialNumber: string | null
    manufacturer: string | null
    purchaseDate: Date | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OperationTheaterEquipmentCountAggregateOutputType | null
    _avg: OperationTheaterEquipmentAvgAggregateOutputType | null
    _sum: OperationTheaterEquipmentSumAggregateOutputType | null
    _min: OperationTheaterEquipmentMinAggregateOutputType | null
    _max: OperationTheaterEquipmentMaxAggregateOutputType | null
  }

  type GetOperationTheaterEquipmentGroupByPayload<T extends OperationTheaterEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationTheaterEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationTheaterEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationTheaterEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], OperationTheaterEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type OperationTheaterEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operationTheaterId?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    purchaseDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationTheaterEquipment"]>

  export type OperationTheaterEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operationTheaterId?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    purchaseDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationTheaterEquipment"]>

  export type OperationTheaterEquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operationTheaterId?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    purchaseDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationTheaterEquipment"]>

  export type OperationTheaterEquipmentSelectScalar = {
    id?: boolean
    operationTheaterId?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    purchaseDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperationTheaterEquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "operationTheaterId" | "name" | "serialNumber" | "manufacturer" | "purchaseDate" | "lastMaintenanceDate" | "nextMaintenanceDate" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["operationTheaterEquipment"]>
  export type OperationTheaterEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }
  export type OperationTheaterEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }
  export type OperationTheaterEquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationTheater?: boolean | OperationTheaterDefaultArgs<ExtArgs>
  }

  export type $OperationTheaterEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationTheaterEquipment"
    objects: {
      operationTheater: Prisma.$OperationTheaterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operationTheaterId: number
      name: string
      serialNumber: string | null
      manufacturer: string | null
      purchaseDate: Date | null
      lastMaintenanceDate: Date | null
      nextMaintenanceDate: Date | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operationTheaterEquipment"]>
    composites: {}
  }

  type OperationTheaterEquipmentGetPayload<S extends boolean | null | undefined | OperationTheaterEquipmentDefaultArgs> = $Result.GetResult<Prisma.$OperationTheaterEquipmentPayload, S>

  type OperationTheaterEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperationTheaterEquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperationTheaterEquipmentCountAggregateInputType | true
    }

  export interface OperationTheaterEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationTheaterEquipment'], meta: { name: 'OperationTheaterEquipment' } }
    /**
     * Find zero or one OperationTheaterEquipment that matches the filter.
     * @param {OperationTheaterEquipmentFindUniqueArgs} args - Arguments to find a OperationTheaterEquipment
     * @example
     * // Get one OperationTheaterEquipment
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationTheaterEquipmentFindUniqueArgs>(args: SelectSubset<T, OperationTheaterEquipmentFindUniqueArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperationTheaterEquipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperationTheaterEquipmentFindUniqueOrThrowArgs} args - Arguments to find a OperationTheaterEquipment
     * @example
     * // Get one OperationTheaterEquipment
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationTheaterEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationTheaterEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperationTheaterEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentFindFirstArgs} args - Arguments to find a OperationTheaterEquipment
     * @example
     * // Get one OperationTheaterEquipment
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationTheaterEquipmentFindFirstArgs>(args?: SelectSubset<T, OperationTheaterEquipmentFindFirstArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperationTheaterEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentFindFirstOrThrowArgs} args - Arguments to find a OperationTheaterEquipment
     * @example
     * // Get one OperationTheaterEquipment
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationTheaterEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationTheaterEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperationTheaterEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationTheaterEquipments
     * const operationTheaterEquipments = await prisma.operationTheaterEquipment.findMany()
     * 
     * // Get first 10 OperationTheaterEquipments
     * const operationTheaterEquipments = await prisma.operationTheaterEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationTheaterEquipmentWithIdOnly = await prisma.operationTheaterEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationTheaterEquipmentFindManyArgs>(args?: SelectSubset<T, OperationTheaterEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperationTheaterEquipment.
     * @param {OperationTheaterEquipmentCreateArgs} args - Arguments to create a OperationTheaterEquipment.
     * @example
     * // Create one OperationTheaterEquipment
     * const OperationTheaterEquipment = await prisma.operationTheaterEquipment.create({
     *   data: {
     *     // ... data to create a OperationTheaterEquipment
     *   }
     * })
     * 
     */
    create<T extends OperationTheaterEquipmentCreateArgs>(args: SelectSubset<T, OperationTheaterEquipmentCreateArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperationTheaterEquipments.
     * @param {OperationTheaterEquipmentCreateManyArgs} args - Arguments to create many OperationTheaterEquipments.
     * @example
     * // Create many OperationTheaterEquipments
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationTheaterEquipmentCreateManyArgs>(args?: SelectSubset<T, OperationTheaterEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationTheaterEquipments and returns the data saved in the database.
     * @param {OperationTheaterEquipmentCreateManyAndReturnArgs} args - Arguments to create many OperationTheaterEquipments.
     * @example
     * // Create many OperationTheaterEquipments
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationTheaterEquipments and only return the `id`
     * const operationTheaterEquipmentWithIdOnly = await prisma.operationTheaterEquipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperationTheaterEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, OperationTheaterEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperationTheaterEquipment.
     * @param {OperationTheaterEquipmentDeleteArgs} args - Arguments to delete one OperationTheaterEquipment.
     * @example
     * // Delete one OperationTheaterEquipment
     * const OperationTheaterEquipment = await prisma.operationTheaterEquipment.delete({
     *   where: {
     *     // ... filter to delete one OperationTheaterEquipment
     *   }
     * })
     * 
     */
    delete<T extends OperationTheaterEquipmentDeleteArgs>(args: SelectSubset<T, OperationTheaterEquipmentDeleteArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperationTheaterEquipment.
     * @param {OperationTheaterEquipmentUpdateArgs} args - Arguments to update one OperationTheaterEquipment.
     * @example
     * // Update one OperationTheaterEquipment
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationTheaterEquipmentUpdateArgs>(args: SelectSubset<T, OperationTheaterEquipmentUpdateArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperationTheaterEquipments.
     * @param {OperationTheaterEquipmentDeleteManyArgs} args - Arguments to filter OperationTheaterEquipments to delete.
     * @example
     * // Delete a few OperationTheaterEquipments
     * const { count } = await prisma.operationTheaterEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationTheaterEquipmentDeleteManyArgs>(args?: SelectSubset<T, OperationTheaterEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationTheaterEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationTheaterEquipments
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationTheaterEquipmentUpdateManyArgs>(args: SelectSubset<T, OperationTheaterEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationTheaterEquipments and returns the data updated in the database.
     * @param {OperationTheaterEquipmentUpdateManyAndReturnArgs} args - Arguments to update many OperationTheaterEquipments.
     * @example
     * // Update many OperationTheaterEquipments
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperationTheaterEquipments and only return the `id`
     * const operationTheaterEquipmentWithIdOnly = await prisma.operationTheaterEquipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperationTheaterEquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, OperationTheaterEquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperationTheaterEquipment.
     * @param {OperationTheaterEquipmentUpsertArgs} args - Arguments to update or create a OperationTheaterEquipment.
     * @example
     * // Update or create a OperationTheaterEquipment
     * const operationTheaterEquipment = await prisma.operationTheaterEquipment.upsert({
     *   create: {
     *     // ... data to create a OperationTheaterEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationTheaterEquipment we want to update
     *   }
     * })
     */
    upsert<T extends OperationTheaterEquipmentUpsertArgs>(args: SelectSubset<T, OperationTheaterEquipmentUpsertArgs<ExtArgs>>): Prisma__OperationTheaterEquipmentClient<$Result.GetResult<Prisma.$OperationTheaterEquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperationTheaterEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentCountArgs} args - Arguments to filter OperationTheaterEquipments to count.
     * @example
     * // Count the number of OperationTheaterEquipments
     * const count = await prisma.operationTheaterEquipment.count({
     *   where: {
     *     // ... the filter for the OperationTheaterEquipments we want to count
     *   }
     * })
    **/
    count<T extends OperationTheaterEquipmentCountArgs>(
      args?: Subset<T, OperationTheaterEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationTheaterEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationTheaterEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationTheaterEquipmentAggregateArgs>(args: Subset<T, OperationTheaterEquipmentAggregateArgs>): Prisma.PrismaPromise<GetOperationTheaterEquipmentAggregateType<T>>

    /**
     * Group by OperationTheaterEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationTheaterEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationTheaterEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationTheaterEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: OperationTheaterEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationTheaterEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationTheaterEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationTheaterEquipment model
   */
  readonly fields: OperationTheaterEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationTheaterEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationTheaterEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operationTheater<T extends OperationTheaterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationTheaterDefaultArgs<ExtArgs>>): Prisma__OperationTheaterClient<$Result.GetResult<Prisma.$OperationTheaterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationTheaterEquipment model
   */
  interface OperationTheaterEquipmentFieldRefs {
    readonly id: FieldRef<"OperationTheaterEquipment", 'Int'>
    readonly operationTheaterId: FieldRef<"OperationTheaterEquipment", 'Int'>
    readonly name: FieldRef<"OperationTheaterEquipment", 'String'>
    readonly serialNumber: FieldRef<"OperationTheaterEquipment", 'String'>
    readonly manufacturer: FieldRef<"OperationTheaterEquipment", 'String'>
    readonly purchaseDate: FieldRef<"OperationTheaterEquipment", 'DateTime'>
    readonly lastMaintenanceDate: FieldRef<"OperationTheaterEquipment", 'DateTime'>
    readonly nextMaintenanceDate: FieldRef<"OperationTheaterEquipment", 'DateTime'>
    readonly status: FieldRef<"OperationTheaterEquipment", 'String'>
    readonly notes: FieldRef<"OperationTheaterEquipment", 'String'>
    readonly createdAt: FieldRef<"OperationTheaterEquipment", 'DateTime'>
    readonly updatedAt: FieldRef<"OperationTheaterEquipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationTheaterEquipment findUnique
   */
  export type OperationTheaterEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheaterEquipment to fetch.
     */
    where: OperationTheaterEquipmentWhereUniqueInput
  }

  /**
   * OperationTheaterEquipment findUniqueOrThrow
   */
  export type OperationTheaterEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheaterEquipment to fetch.
     */
    where: OperationTheaterEquipmentWhereUniqueInput
  }

  /**
   * OperationTheaterEquipment findFirst
   */
  export type OperationTheaterEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheaterEquipment to fetch.
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaterEquipments to fetch.
     */
    orderBy?: OperationTheaterEquipmentOrderByWithRelationInput | OperationTheaterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationTheaterEquipments.
     */
    cursor?: OperationTheaterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationTheaterEquipments.
     */
    distinct?: OperationTheaterEquipmentScalarFieldEnum | OperationTheaterEquipmentScalarFieldEnum[]
  }

  /**
   * OperationTheaterEquipment findFirstOrThrow
   */
  export type OperationTheaterEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheaterEquipment to fetch.
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaterEquipments to fetch.
     */
    orderBy?: OperationTheaterEquipmentOrderByWithRelationInput | OperationTheaterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationTheaterEquipments.
     */
    cursor?: OperationTheaterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationTheaterEquipments.
     */
    distinct?: OperationTheaterEquipmentScalarFieldEnum | OperationTheaterEquipmentScalarFieldEnum[]
  }

  /**
   * OperationTheaterEquipment findMany
   */
  export type OperationTheaterEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which OperationTheaterEquipments to fetch.
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationTheaterEquipments to fetch.
     */
    orderBy?: OperationTheaterEquipmentOrderByWithRelationInput | OperationTheaterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationTheaterEquipments.
     */
    cursor?: OperationTheaterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationTheaterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationTheaterEquipments.
     */
    skip?: number
    distinct?: OperationTheaterEquipmentScalarFieldEnum | OperationTheaterEquipmentScalarFieldEnum[]
  }

  /**
   * OperationTheaterEquipment create
   */
  export type OperationTheaterEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationTheaterEquipment.
     */
    data: XOR<OperationTheaterEquipmentCreateInput, OperationTheaterEquipmentUncheckedCreateInput>
  }

  /**
   * OperationTheaterEquipment createMany
   */
  export type OperationTheaterEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationTheaterEquipments.
     */
    data: OperationTheaterEquipmentCreateManyInput | OperationTheaterEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationTheaterEquipment createManyAndReturn
   */
  export type OperationTheaterEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many OperationTheaterEquipments.
     */
    data: OperationTheaterEquipmentCreateManyInput | OperationTheaterEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationTheaterEquipment update
   */
  export type OperationTheaterEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationTheaterEquipment.
     */
    data: XOR<OperationTheaterEquipmentUpdateInput, OperationTheaterEquipmentUncheckedUpdateInput>
    /**
     * Choose, which OperationTheaterEquipment to update.
     */
    where: OperationTheaterEquipmentWhereUniqueInput
  }

  /**
   * OperationTheaterEquipment updateMany
   */
  export type OperationTheaterEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationTheaterEquipments.
     */
    data: XOR<OperationTheaterEquipmentUpdateManyMutationInput, OperationTheaterEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which OperationTheaterEquipments to update
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * Limit how many OperationTheaterEquipments to update.
     */
    limit?: number
  }

  /**
   * OperationTheaterEquipment updateManyAndReturn
   */
  export type OperationTheaterEquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * The data used to update OperationTheaterEquipments.
     */
    data: XOR<OperationTheaterEquipmentUpdateManyMutationInput, OperationTheaterEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which OperationTheaterEquipments to update
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * Limit how many OperationTheaterEquipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationTheaterEquipment upsert
   */
  export type OperationTheaterEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationTheaterEquipment to update in case it exists.
     */
    where: OperationTheaterEquipmentWhereUniqueInput
    /**
     * In case the OperationTheaterEquipment found by the `where` argument doesn't exist, create a new OperationTheaterEquipment with this data.
     */
    create: XOR<OperationTheaterEquipmentCreateInput, OperationTheaterEquipmentUncheckedCreateInput>
    /**
     * In case the OperationTheaterEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationTheaterEquipmentUpdateInput, OperationTheaterEquipmentUncheckedUpdateInput>
  }

  /**
   * OperationTheaterEquipment delete
   */
  export type OperationTheaterEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
    /**
     * Filter which OperationTheaterEquipment to delete.
     */
    where: OperationTheaterEquipmentWhereUniqueInput
  }

  /**
   * OperationTheaterEquipment deleteMany
   */
  export type OperationTheaterEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationTheaterEquipments to delete
     */
    where?: OperationTheaterEquipmentWhereInput
    /**
     * Limit how many OperationTheaterEquipments to delete.
     */
    limit?: number
  }

  /**
   * OperationTheaterEquipment without action
   */
  export type OperationTheaterEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationTheaterEquipment
     */
    select?: OperationTheaterEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationTheaterEquipment
     */
    omit?: OperationTheaterEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationTheaterEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model MedicalGasCylinder
   */

  export type AggregateMedicalGasCylinder = {
    _count: MedicalGasCylinderCountAggregateOutputType | null
    _avg: MedicalGasCylinderAvgAggregateOutputType | null
    _sum: MedicalGasCylinderSumAggregateOutputType | null
    _min: MedicalGasCylinderMinAggregateOutputType | null
    _max: MedicalGasCylinderMaxAggregateOutputType | null
  }

  export type MedicalGasCylinderAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
    currentLevel: number | null
  }

  export type MedicalGasCylinderSumAggregateOutputType = {
    id: number | null
    capacity: number | null
    currentLevel: number | null
  }

  export type MedicalGasCylinderMinAggregateOutputType = {
    id: number | null
    cylinderNumber: string | null
    gasType: string | null
    capacity: number | null
    currentLevel: number | null
    location: string | null
    status: string | null
    lastRefillDate: Date | null
    nextRefillDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalGasCylinderMaxAggregateOutputType = {
    id: number | null
    cylinderNumber: string | null
    gasType: string | null
    capacity: number | null
    currentLevel: number | null
    location: string | null
    status: string | null
    lastRefillDate: Date | null
    nextRefillDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalGasCylinderCountAggregateOutputType = {
    id: number
    cylinderNumber: number
    gasType: number
    capacity: number
    currentLevel: number
    location: number
    status: number
    lastRefillDate: number
    nextRefillDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalGasCylinderAvgAggregateInputType = {
    id?: true
    capacity?: true
    currentLevel?: true
  }

  export type MedicalGasCylinderSumAggregateInputType = {
    id?: true
    capacity?: true
    currentLevel?: true
  }

  export type MedicalGasCylinderMinAggregateInputType = {
    id?: true
    cylinderNumber?: true
    gasType?: true
    capacity?: true
    currentLevel?: true
    location?: true
    status?: true
    lastRefillDate?: true
    nextRefillDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalGasCylinderMaxAggregateInputType = {
    id?: true
    cylinderNumber?: true
    gasType?: true
    capacity?: true
    currentLevel?: true
    location?: true
    status?: true
    lastRefillDate?: true
    nextRefillDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalGasCylinderCountAggregateInputType = {
    id?: true
    cylinderNumber?: true
    gasType?: true
    capacity?: true
    currentLevel?: true
    location?: true
    status?: true
    lastRefillDate?: true
    nextRefillDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalGasCylinderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalGasCylinder to aggregate.
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalGasCylinders to fetch.
     */
    orderBy?: MedicalGasCylinderOrderByWithRelationInput | MedicalGasCylinderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalGasCylinderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalGasCylinders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalGasCylinders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalGasCylinders
    **/
    _count?: true | MedicalGasCylinderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalGasCylinderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalGasCylinderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalGasCylinderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalGasCylinderMaxAggregateInputType
  }

  export type GetMedicalGasCylinderAggregateType<T extends MedicalGasCylinderAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalGasCylinder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalGasCylinder[P]>
      : GetScalarType<T[P], AggregateMedicalGasCylinder[P]>
  }




  export type MedicalGasCylinderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalGasCylinderWhereInput
    orderBy?: MedicalGasCylinderOrderByWithAggregationInput | MedicalGasCylinderOrderByWithAggregationInput[]
    by: MedicalGasCylinderScalarFieldEnum[] | MedicalGasCylinderScalarFieldEnum
    having?: MedicalGasCylinderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalGasCylinderCountAggregateInputType | true
    _avg?: MedicalGasCylinderAvgAggregateInputType
    _sum?: MedicalGasCylinderSumAggregateInputType
    _min?: MedicalGasCylinderMinAggregateInputType
    _max?: MedicalGasCylinderMaxAggregateInputType
  }

  export type MedicalGasCylinderGroupByOutputType = {
    id: number
    cylinderNumber: string
    gasType: string
    capacity: number
    currentLevel: number
    location: string | null
    status: string
    lastRefillDate: Date | null
    nextRefillDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalGasCylinderCountAggregateOutputType | null
    _avg: MedicalGasCylinderAvgAggregateOutputType | null
    _sum: MedicalGasCylinderSumAggregateOutputType | null
    _min: MedicalGasCylinderMinAggregateOutputType | null
    _max: MedicalGasCylinderMaxAggregateOutputType | null
  }

  type GetMedicalGasCylinderGroupByPayload<T extends MedicalGasCylinderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalGasCylinderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalGasCylinderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalGasCylinderGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalGasCylinderGroupByOutputType[P]>
        }
      >
    >


  export type MedicalGasCylinderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cylinderNumber?: boolean
    gasType?: boolean
    capacity?: boolean
    currentLevel?: boolean
    location?: boolean
    status?: boolean
    lastRefillDate?: boolean
    nextRefillDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicalGasCylinder"]>

  export type MedicalGasCylinderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cylinderNumber?: boolean
    gasType?: boolean
    capacity?: boolean
    currentLevel?: boolean
    location?: boolean
    status?: boolean
    lastRefillDate?: boolean
    nextRefillDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicalGasCylinder"]>

  export type MedicalGasCylinderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cylinderNumber?: boolean
    gasType?: boolean
    capacity?: boolean
    currentLevel?: boolean
    location?: boolean
    status?: boolean
    lastRefillDate?: boolean
    nextRefillDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicalGasCylinder"]>

  export type MedicalGasCylinderSelectScalar = {
    id?: boolean
    cylinderNumber?: boolean
    gasType?: boolean
    capacity?: boolean
    currentLevel?: boolean
    location?: boolean
    status?: boolean
    lastRefillDate?: boolean
    nextRefillDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalGasCylinderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cylinderNumber" | "gasType" | "capacity" | "currentLevel" | "location" | "status" | "lastRefillDate" | "nextRefillDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalGasCylinder"]>

  export type $MedicalGasCylinderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalGasCylinder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cylinderNumber: string
      gasType: string
      capacity: number
      currentLevel: number
      location: string | null
      status: string
      lastRefillDate: Date | null
      nextRefillDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalGasCylinder"]>
    composites: {}
  }

  type MedicalGasCylinderGetPayload<S extends boolean | null | undefined | MedicalGasCylinderDefaultArgs> = $Result.GetResult<Prisma.$MedicalGasCylinderPayload, S>

  type MedicalGasCylinderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalGasCylinderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalGasCylinderCountAggregateInputType | true
    }

  export interface MedicalGasCylinderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalGasCylinder'], meta: { name: 'MedicalGasCylinder' } }
    /**
     * Find zero or one MedicalGasCylinder that matches the filter.
     * @param {MedicalGasCylinderFindUniqueArgs} args - Arguments to find a MedicalGasCylinder
     * @example
     * // Get one MedicalGasCylinder
     * const medicalGasCylinder = await prisma.medicalGasCylinder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalGasCylinderFindUniqueArgs>(args: SelectSubset<T, MedicalGasCylinderFindUniqueArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalGasCylinder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalGasCylinderFindUniqueOrThrowArgs} args - Arguments to find a MedicalGasCylinder
     * @example
     * // Get one MedicalGasCylinder
     * const medicalGasCylinder = await prisma.medicalGasCylinder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalGasCylinderFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalGasCylinderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalGasCylinder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderFindFirstArgs} args - Arguments to find a MedicalGasCylinder
     * @example
     * // Get one MedicalGasCylinder
     * const medicalGasCylinder = await prisma.medicalGasCylinder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalGasCylinderFindFirstArgs>(args?: SelectSubset<T, MedicalGasCylinderFindFirstArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalGasCylinder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderFindFirstOrThrowArgs} args - Arguments to find a MedicalGasCylinder
     * @example
     * // Get one MedicalGasCylinder
     * const medicalGasCylinder = await prisma.medicalGasCylinder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalGasCylinderFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalGasCylinderFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalGasCylinders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalGasCylinders
     * const medicalGasCylinders = await prisma.medicalGasCylinder.findMany()
     * 
     * // Get first 10 MedicalGasCylinders
     * const medicalGasCylinders = await prisma.medicalGasCylinder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalGasCylinderWithIdOnly = await prisma.medicalGasCylinder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalGasCylinderFindManyArgs>(args?: SelectSubset<T, MedicalGasCylinderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalGasCylinder.
     * @param {MedicalGasCylinderCreateArgs} args - Arguments to create a MedicalGasCylinder.
     * @example
     * // Create one MedicalGasCylinder
     * const MedicalGasCylinder = await prisma.medicalGasCylinder.create({
     *   data: {
     *     // ... data to create a MedicalGasCylinder
     *   }
     * })
     * 
     */
    create<T extends MedicalGasCylinderCreateArgs>(args: SelectSubset<T, MedicalGasCylinderCreateArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalGasCylinders.
     * @param {MedicalGasCylinderCreateManyArgs} args - Arguments to create many MedicalGasCylinders.
     * @example
     * // Create many MedicalGasCylinders
     * const medicalGasCylinder = await prisma.medicalGasCylinder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalGasCylinderCreateManyArgs>(args?: SelectSubset<T, MedicalGasCylinderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalGasCylinders and returns the data saved in the database.
     * @param {MedicalGasCylinderCreateManyAndReturnArgs} args - Arguments to create many MedicalGasCylinders.
     * @example
     * // Create many MedicalGasCylinders
     * const medicalGasCylinder = await prisma.medicalGasCylinder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalGasCylinders and only return the `id`
     * const medicalGasCylinderWithIdOnly = await prisma.medicalGasCylinder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalGasCylinderCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalGasCylinderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalGasCylinder.
     * @param {MedicalGasCylinderDeleteArgs} args - Arguments to delete one MedicalGasCylinder.
     * @example
     * // Delete one MedicalGasCylinder
     * const MedicalGasCylinder = await prisma.medicalGasCylinder.delete({
     *   where: {
     *     // ... filter to delete one MedicalGasCylinder
     *   }
     * })
     * 
     */
    delete<T extends MedicalGasCylinderDeleteArgs>(args: SelectSubset<T, MedicalGasCylinderDeleteArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalGasCylinder.
     * @param {MedicalGasCylinderUpdateArgs} args - Arguments to update one MedicalGasCylinder.
     * @example
     * // Update one MedicalGasCylinder
     * const medicalGasCylinder = await prisma.medicalGasCylinder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalGasCylinderUpdateArgs>(args: SelectSubset<T, MedicalGasCylinderUpdateArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalGasCylinders.
     * @param {MedicalGasCylinderDeleteManyArgs} args - Arguments to filter MedicalGasCylinders to delete.
     * @example
     * // Delete a few MedicalGasCylinders
     * const { count } = await prisma.medicalGasCylinder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalGasCylinderDeleteManyArgs>(args?: SelectSubset<T, MedicalGasCylinderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalGasCylinders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalGasCylinders
     * const medicalGasCylinder = await prisma.medicalGasCylinder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalGasCylinderUpdateManyArgs>(args: SelectSubset<T, MedicalGasCylinderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalGasCylinders and returns the data updated in the database.
     * @param {MedicalGasCylinderUpdateManyAndReturnArgs} args - Arguments to update many MedicalGasCylinders.
     * @example
     * // Update many MedicalGasCylinders
     * const medicalGasCylinder = await prisma.medicalGasCylinder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalGasCylinders and only return the `id`
     * const medicalGasCylinderWithIdOnly = await prisma.medicalGasCylinder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalGasCylinderUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalGasCylinderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalGasCylinder.
     * @param {MedicalGasCylinderUpsertArgs} args - Arguments to update or create a MedicalGasCylinder.
     * @example
     * // Update or create a MedicalGasCylinder
     * const medicalGasCylinder = await prisma.medicalGasCylinder.upsert({
     *   create: {
     *     // ... data to create a MedicalGasCylinder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalGasCylinder we want to update
     *   }
     * })
     */
    upsert<T extends MedicalGasCylinderUpsertArgs>(args: SelectSubset<T, MedicalGasCylinderUpsertArgs<ExtArgs>>): Prisma__MedicalGasCylinderClient<$Result.GetResult<Prisma.$MedicalGasCylinderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalGasCylinders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderCountArgs} args - Arguments to filter MedicalGasCylinders to count.
     * @example
     * // Count the number of MedicalGasCylinders
     * const count = await prisma.medicalGasCylinder.count({
     *   where: {
     *     // ... the filter for the MedicalGasCylinders we want to count
     *   }
     * })
    **/
    count<T extends MedicalGasCylinderCountArgs>(
      args?: Subset<T, MedicalGasCylinderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalGasCylinderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalGasCylinder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalGasCylinderAggregateArgs>(args: Subset<T, MedicalGasCylinderAggregateArgs>): Prisma.PrismaPromise<GetMedicalGasCylinderAggregateType<T>>

    /**
     * Group by MedicalGasCylinder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalGasCylinderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalGasCylinderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalGasCylinderGroupByArgs['orderBy'] }
        : { orderBy?: MedicalGasCylinderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalGasCylinderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalGasCylinderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalGasCylinder model
   */
  readonly fields: MedicalGasCylinderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalGasCylinder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalGasCylinderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalGasCylinder model
   */
  interface MedicalGasCylinderFieldRefs {
    readonly id: FieldRef<"MedicalGasCylinder", 'Int'>
    readonly cylinderNumber: FieldRef<"MedicalGasCylinder", 'String'>
    readonly gasType: FieldRef<"MedicalGasCylinder", 'String'>
    readonly capacity: FieldRef<"MedicalGasCylinder", 'Float'>
    readonly currentLevel: FieldRef<"MedicalGasCylinder", 'Float'>
    readonly location: FieldRef<"MedicalGasCylinder", 'String'>
    readonly status: FieldRef<"MedicalGasCylinder", 'String'>
    readonly lastRefillDate: FieldRef<"MedicalGasCylinder", 'DateTime'>
    readonly nextRefillDate: FieldRef<"MedicalGasCylinder", 'DateTime'>
    readonly notes: FieldRef<"MedicalGasCylinder", 'String'>
    readonly createdAt: FieldRef<"MedicalGasCylinder", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalGasCylinder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalGasCylinder findUnique
   */
  export type MedicalGasCylinderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * Filter, which MedicalGasCylinder to fetch.
     */
    where: MedicalGasCylinderWhereUniqueInput
  }

  /**
   * MedicalGasCylinder findUniqueOrThrow
   */
  export type MedicalGasCylinderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * Filter, which MedicalGasCylinder to fetch.
     */
    where: MedicalGasCylinderWhereUniqueInput
  }

  /**
   * MedicalGasCylinder findFirst
   */
  export type MedicalGasCylinderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * Filter, which MedicalGasCylinder to fetch.
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalGasCylinders to fetch.
     */
    orderBy?: MedicalGasCylinderOrderByWithRelationInput | MedicalGasCylinderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalGasCylinders.
     */
    cursor?: MedicalGasCylinderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalGasCylinders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalGasCylinders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalGasCylinders.
     */
    distinct?: MedicalGasCylinderScalarFieldEnum | MedicalGasCylinderScalarFieldEnum[]
  }

  /**
   * MedicalGasCylinder findFirstOrThrow
   */
  export type MedicalGasCylinderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * Filter, which MedicalGasCylinder to fetch.
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalGasCylinders to fetch.
     */
    orderBy?: MedicalGasCylinderOrderByWithRelationInput | MedicalGasCylinderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalGasCylinders.
     */
    cursor?: MedicalGasCylinderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalGasCylinders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalGasCylinders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalGasCylinders.
     */
    distinct?: MedicalGasCylinderScalarFieldEnum | MedicalGasCylinderScalarFieldEnum[]
  }

  /**
   * MedicalGasCylinder findMany
   */
  export type MedicalGasCylinderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * Filter, which MedicalGasCylinders to fetch.
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalGasCylinders to fetch.
     */
    orderBy?: MedicalGasCylinderOrderByWithRelationInput | MedicalGasCylinderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalGasCylinders.
     */
    cursor?: MedicalGasCylinderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalGasCylinders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalGasCylinders.
     */
    skip?: number
    distinct?: MedicalGasCylinderScalarFieldEnum | MedicalGasCylinderScalarFieldEnum[]
  }

  /**
   * MedicalGasCylinder create
   */
  export type MedicalGasCylinderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * The data needed to create a MedicalGasCylinder.
     */
    data: XOR<MedicalGasCylinderCreateInput, MedicalGasCylinderUncheckedCreateInput>
  }

  /**
   * MedicalGasCylinder createMany
   */
  export type MedicalGasCylinderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalGasCylinders.
     */
    data: MedicalGasCylinderCreateManyInput | MedicalGasCylinderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalGasCylinder createManyAndReturn
   */
  export type MedicalGasCylinderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalGasCylinders.
     */
    data: MedicalGasCylinderCreateManyInput | MedicalGasCylinderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalGasCylinder update
   */
  export type MedicalGasCylinderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * The data needed to update a MedicalGasCylinder.
     */
    data: XOR<MedicalGasCylinderUpdateInput, MedicalGasCylinderUncheckedUpdateInput>
    /**
     * Choose, which MedicalGasCylinder to update.
     */
    where: MedicalGasCylinderWhereUniqueInput
  }

  /**
   * MedicalGasCylinder updateMany
   */
  export type MedicalGasCylinderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalGasCylinders.
     */
    data: XOR<MedicalGasCylinderUpdateManyMutationInput, MedicalGasCylinderUncheckedUpdateManyInput>
    /**
     * Filter which MedicalGasCylinders to update
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * Limit how many MedicalGasCylinders to update.
     */
    limit?: number
  }

  /**
   * MedicalGasCylinder updateManyAndReturn
   */
  export type MedicalGasCylinderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * The data used to update MedicalGasCylinders.
     */
    data: XOR<MedicalGasCylinderUpdateManyMutationInput, MedicalGasCylinderUncheckedUpdateManyInput>
    /**
     * Filter which MedicalGasCylinders to update
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * Limit how many MedicalGasCylinders to update.
     */
    limit?: number
  }

  /**
   * MedicalGasCylinder upsert
   */
  export type MedicalGasCylinderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * The filter to search for the MedicalGasCylinder to update in case it exists.
     */
    where: MedicalGasCylinderWhereUniqueInput
    /**
     * In case the MedicalGasCylinder found by the `where` argument doesn't exist, create a new MedicalGasCylinder with this data.
     */
    create: XOR<MedicalGasCylinderCreateInput, MedicalGasCylinderUncheckedCreateInput>
    /**
     * In case the MedicalGasCylinder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalGasCylinderUpdateInput, MedicalGasCylinderUncheckedUpdateInput>
  }

  /**
   * MedicalGasCylinder delete
   */
  export type MedicalGasCylinderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
    /**
     * Filter which MedicalGasCylinder to delete.
     */
    where: MedicalGasCylinderWhereUniqueInput
  }

  /**
   * MedicalGasCylinder deleteMany
   */
  export type MedicalGasCylinderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalGasCylinders to delete
     */
    where?: MedicalGasCylinderWhereInput
    /**
     * Limit how many MedicalGasCylinders to delete.
     */
    limit?: number
  }

  /**
   * MedicalGasCylinder without action
   */
  export type MedicalGasCylinderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalGasCylinder
     */
    select?: MedicalGasCylinderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalGasCylinder
     */
    omit?: MedicalGasCylinderOmit<ExtArgs> | null
  }


  /**
   * Model EquipmentMaintenance
   */

  export type AggregateEquipmentMaintenance = {
    _count: EquipmentMaintenanceCountAggregateOutputType | null
    _avg: EquipmentMaintenanceAvgAggregateOutputType | null
    _sum: EquipmentMaintenanceSumAggregateOutputType | null
    _min: EquipmentMaintenanceMinAggregateOutputType | null
    _max: EquipmentMaintenanceMaxAggregateOutputType | null
  }

  export type EquipmentMaintenanceAvgAggregateOutputType = {
    id: number | null
    equipmentId: number | null
    cost: Decimal | null
  }

  export type EquipmentMaintenanceSumAggregateOutputType = {
    id: number | null
    equipmentId: number | null
    cost: Decimal | null
  }

  export type EquipmentMaintenanceMinAggregateOutputType = {
    id: number | null
    equipmentType: string | null
    equipmentId: number | null
    maintenanceDate: Date | null
    maintenanceType: string | null
    performedBy: string | null
    cost: Decimal | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentMaintenanceMaxAggregateOutputType = {
    id: number | null
    equipmentType: string | null
    equipmentId: number | null
    maintenanceDate: Date | null
    maintenanceType: string | null
    performedBy: string | null
    cost: Decimal | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentMaintenanceCountAggregateOutputType = {
    id: number
    equipmentType: number
    equipmentId: number
    maintenanceDate: number
    maintenanceType: number
    performedBy: number
    cost: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentMaintenanceAvgAggregateInputType = {
    id?: true
    equipmentId?: true
    cost?: true
  }

  export type EquipmentMaintenanceSumAggregateInputType = {
    id?: true
    equipmentId?: true
    cost?: true
  }

  export type EquipmentMaintenanceMinAggregateInputType = {
    id?: true
    equipmentType?: true
    equipmentId?: true
    maintenanceDate?: true
    maintenanceType?: true
    performedBy?: true
    cost?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentMaintenanceMaxAggregateInputType = {
    id?: true
    equipmentType?: true
    equipmentId?: true
    maintenanceDate?: true
    maintenanceType?: true
    performedBy?: true
    cost?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentMaintenanceCountAggregateInputType = {
    id?: true
    equipmentType?: true
    equipmentId?: true
    maintenanceDate?: true
    maintenanceType?: true
    performedBy?: true
    cost?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentMaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentMaintenance to aggregate.
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentMaintenances to fetch.
     */
    orderBy?: EquipmentMaintenanceOrderByWithRelationInput | EquipmentMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentMaintenances
    **/
    _count?: true | EquipmentMaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentMaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentMaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaintenanceMaxAggregateInputType
  }

  export type GetEquipmentMaintenanceAggregateType<T extends EquipmentMaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentMaintenance[P]>
      : GetScalarType<T[P], AggregateEquipmentMaintenance[P]>
  }




  export type EquipmentMaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentMaintenanceWhereInput
    orderBy?: EquipmentMaintenanceOrderByWithAggregationInput | EquipmentMaintenanceOrderByWithAggregationInput[]
    by: EquipmentMaintenanceScalarFieldEnum[] | EquipmentMaintenanceScalarFieldEnum
    having?: EquipmentMaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentMaintenanceCountAggregateInputType | true
    _avg?: EquipmentMaintenanceAvgAggregateInputType
    _sum?: EquipmentMaintenanceSumAggregateInputType
    _min?: EquipmentMaintenanceMinAggregateInputType
    _max?: EquipmentMaintenanceMaxAggregateInputType
  }

  export type EquipmentMaintenanceGroupByOutputType = {
    id: number
    equipmentType: string
    equipmentId: number
    maintenanceDate: Date
    maintenanceType: string
    performedBy: string
    cost: Decimal
    notes: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: EquipmentMaintenanceCountAggregateOutputType | null
    _avg: EquipmentMaintenanceAvgAggregateOutputType | null
    _sum: EquipmentMaintenanceSumAggregateOutputType | null
    _min: EquipmentMaintenanceMinAggregateOutputType | null
    _max: EquipmentMaintenanceMaxAggregateOutputType | null
  }

  type GetEquipmentMaintenanceGroupByPayload<T extends EquipmentMaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentMaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentMaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentMaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentMaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentMaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentType?: boolean
    equipmentId?: boolean
    maintenanceDate?: boolean
    maintenanceType?: boolean
    performedBy?: boolean
    cost?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipmentMaintenance"]>

  export type EquipmentMaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentType?: boolean
    equipmentId?: boolean
    maintenanceDate?: boolean
    maintenanceType?: boolean
    performedBy?: boolean
    cost?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipmentMaintenance"]>

  export type EquipmentMaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentType?: boolean
    equipmentId?: boolean
    maintenanceDate?: boolean
    maintenanceType?: boolean
    performedBy?: boolean
    cost?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipmentMaintenance"]>

  export type EquipmentMaintenanceSelectScalar = {
    id?: boolean
    equipmentType?: boolean
    equipmentId?: boolean
    maintenanceDate?: boolean
    maintenanceType?: boolean
    performedBy?: boolean
    cost?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentMaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentType" | "equipmentId" | "maintenanceDate" | "maintenanceType" | "performedBy" | "cost" | "notes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["equipmentMaintenance"]>

  export type $EquipmentMaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentMaintenance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      equipmentType: string
      equipmentId: number
      maintenanceDate: Date
      maintenanceType: string
      performedBy: string
      cost: Prisma.Decimal
      notes: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentMaintenance"]>
    composites: {}
  }

  type EquipmentMaintenanceGetPayload<S extends boolean | null | undefined | EquipmentMaintenanceDefaultArgs> = $Result.GetResult<Prisma.$EquipmentMaintenancePayload, S>

  type EquipmentMaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentMaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentMaintenanceCountAggregateInputType | true
    }

  export interface EquipmentMaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentMaintenance'], meta: { name: 'EquipmentMaintenance' } }
    /**
     * Find zero or one EquipmentMaintenance that matches the filter.
     * @param {EquipmentMaintenanceFindUniqueArgs} args - Arguments to find a EquipmentMaintenance
     * @example
     * // Get one EquipmentMaintenance
     * const equipmentMaintenance = await prisma.equipmentMaintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentMaintenanceFindUniqueArgs>(args: SelectSubset<T, EquipmentMaintenanceFindUniqueArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentMaintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentMaintenanceFindUniqueOrThrowArgs} args - Arguments to find a EquipmentMaintenance
     * @example
     * // Get one EquipmentMaintenance
     * const equipmentMaintenance = await prisma.equipmentMaintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentMaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentMaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentMaintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceFindFirstArgs} args - Arguments to find a EquipmentMaintenance
     * @example
     * // Get one EquipmentMaintenance
     * const equipmentMaintenance = await prisma.equipmentMaintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentMaintenanceFindFirstArgs>(args?: SelectSubset<T, EquipmentMaintenanceFindFirstArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentMaintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceFindFirstOrThrowArgs} args - Arguments to find a EquipmentMaintenance
     * @example
     * // Get one EquipmentMaintenance
     * const equipmentMaintenance = await prisma.equipmentMaintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentMaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentMaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentMaintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentMaintenances
     * const equipmentMaintenances = await prisma.equipmentMaintenance.findMany()
     * 
     * // Get first 10 EquipmentMaintenances
     * const equipmentMaintenances = await prisma.equipmentMaintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentMaintenanceWithIdOnly = await prisma.equipmentMaintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentMaintenanceFindManyArgs>(args?: SelectSubset<T, EquipmentMaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentMaintenance.
     * @param {EquipmentMaintenanceCreateArgs} args - Arguments to create a EquipmentMaintenance.
     * @example
     * // Create one EquipmentMaintenance
     * const EquipmentMaintenance = await prisma.equipmentMaintenance.create({
     *   data: {
     *     // ... data to create a EquipmentMaintenance
     *   }
     * })
     * 
     */
    create<T extends EquipmentMaintenanceCreateArgs>(args: SelectSubset<T, EquipmentMaintenanceCreateArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentMaintenances.
     * @param {EquipmentMaintenanceCreateManyArgs} args - Arguments to create many EquipmentMaintenances.
     * @example
     * // Create many EquipmentMaintenances
     * const equipmentMaintenance = await prisma.equipmentMaintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentMaintenanceCreateManyArgs>(args?: SelectSubset<T, EquipmentMaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentMaintenances and returns the data saved in the database.
     * @param {EquipmentMaintenanceCreateManyAndReturnArgs} args - Arguments to create many EquipmentMaintenances.
     * @example
     * // Create many EquipmentMaintenances
     * const equipmentMaintenance = await prisma.equipmentMaintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentMaintenances and only return the `id`
     * const equipmentMaintenanceWithIdOnly = await prisma.equipmentMaintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentMaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentMaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentMaintenance.
     * @param {EquipmentMaintenanceDeleteArgs} args - Arguments to delete one EquipmentMaintenance.
     * @example
     * // Delete one EquipmentMaintenance
     * const EquipmentMaintenance = await prisma.equipmentMaintenance.delete({
     *   where: {
     *     // ... filter to delete one EquipmentMaintenance
     *   }
     * })
     * 
     */
    delete<T extends EquipmentMaintenanceDeleteArgs>(args: SelectSubset<T, EquipmentMaintenanceDeleteArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentMaintenance.
     * @param {EquipmentMaintenanceUpdateArgs} args - Arguments to update one EquipmentMaintenance.
     * @example
     * // Update one EquipmentMaintenance
     * const equipmentMaintenance = await prisma.equipmentMaintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentMaintenanceUpdateArgs>(args: SelectSubset<T, EquipmentMaintenanceUpdateArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentMaintenances.
     * @param {EquipmentMaintenanceDeleteManyArgs} args - Arguments to filter EquipmentMaintenances to delete.
     * @example
     * // Delete a few EquipmentMaintenances
     * const { count } = await prisma.equipmentMaintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentMaintenanceDeleteManyArgs>(args?: SelectSubset<T, EquipmentMaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentMaintenances
     * const equipmentMaintenance = await prisma.equipmentMaintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentMaintenanceUpdateManyArgs>(args: SelectSubset<T, EquipmentMaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentMaintenances and returns the data updated in the database.
     * @param {EquipmentMaintenanceUpdateManyAndReturnArgs} args - Arguments to update many EquipmentMaintenances.
     * @example
     * // Update many EquipmentMaintenances
     * const equipmentMaintenance = await prisma.equipmentMaintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentMaintenances and only return the `id`
     * const equipmentMaintenanceWithIdOnly = await prisma.equipmentMaintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentMaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentMaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentMaintenance.
     * @param {EquipmentMaintenanceUpsertArgs} args - Arguments to update or create a EquipmentMaintenance.
     * @example
     * // Update or create a EquipmentMaintenance
     * const equipmentMaintenance = await prisma.equipmentMaintenance.upsert({
     *   create: {
     *     // ... data to create a EquipmentMaintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentMaintenance we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentMaintenanceUpsertArgs>(args: SelectSubset<T, EquipmentMaintenanceUpsertArgs<ExtArgs>>): Prisma__EquipmentMaintenanceClient<$Result.GetResult<Prisma.$EquipmentMaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceCountArgs} args - Arguments to filter EquipmentMaintenances to count.
     * @example
     * // Count the number of EquipmentMaintenances
     * const count = await prisma.equipmentMaintenance.count({
     *   where: {
     *     // ... the filter for the EquipmentMaintenances we want to count
     *   }
     * })
    **/
    count<T extends EquipmentMaintenanceCountArgs>(
      args?: Subset<T, EquipmentMaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentMaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentMaintenanceAggregateArgs>(args: Subset<T, EquipmentMaintenanceAggregateArgs>): Prisma.PrismaPromise<GetEquipmentMaintenanceAggregateType<T>>

    /**
     * Group by EquipmentMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentMaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentMaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentMaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentMaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentMaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentMaintenance model
   */
  readonly fields: EquipmentMaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentMaintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentMaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentMaintenance model
   */
  interface EquipmentMaintenanceFieldRefs {
    readonly id: FieldRef<"EquipmentMaintenance", 'Int'>
    readonly equipmentType: FieldRef<"EquipmentMaintenance", 'String'>
    readonly equipmentId: FieldRef<"EquipmentMaintenance", 'Int'>
    readonly maintenanceDate: FieldRef<"EquipmentMaintenance", 'DateTime'>
    readonly maintenanceType: FieldRef<"EquipmentMaintenance", 'String'>
    readonly performedBy: FieldRef<"EquipmentMaintenance", 'String'>
    readonly cost: FieldRef<"EquipmentMaintenance", 'Decimal'>
    readonly notes: FieldRef<"EquipmentMaintenance", 'String'>
    readonly status: FieldRef<"EquipmentMaintenance", 'String'>
    readonly createdAt: FieldRef<"EquipmentMaintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentMaintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentMaintenance findUnique
   */
  export type EquipmentMaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which EquipmentMaintenance to fetch.
     */
    where: EquipmentMaintenanceWhereUniqueInput
  }

  /**
   * EquipmentMaintenance findUniqueOrThrow
   */
  export type EquipmentMaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which EquipmentMaintenance to fetch.
     */
    where: EquipmentMaintenanceWhereUniqueInput
  }

  /**
   * EquipmentMaintenance findFirst
   */
  export type EquipmentMaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which EquipmentMaintenance to fetch.
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentMaintenances to fetch.
     */
    orderBy?: EquipmentMaintenanceOrderByWithRelationInput | EquipmentMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentMaintenances.
     */
    cursor?: EquipmentMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentMaintenances.
     */
    distinct?: EquipmentMaintenanceScalarFieldEnum | EquipmentMaintenanceScalarFieldEnum[]
  }

  /**
   * EquipmentMaintenance findFirstOrThrow
   */
  export type EquipmentMaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which EquipmentMaintenance to fetch.
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentMaintenances to fetch.
     */
    orderBy?: EquipmentMaintenanceOrderByWithRelationInput | EquipmentMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentMaintenances.
     */
    cursor?: EquipmentMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentMaintenances.
     */
    distinct?: EquipmentMaintenanceScalarFieldEnum | EquipmentMaintenanceScalarFieldEnum[]
  }

  /**
   * EquipmentMaintenance findMany
   */
  export type EquipmentMaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which EquipmentMaintenances to fetch.
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentMaintenances to fetch.
     */
    orderBy?: EquipmentMaintenanceOrderByWithRelationInput | EquipmentMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentMaintenances.
     */
    cursor?: EquipmentMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentMaintenances.
     */
    skip?: number
    distinct?: EquipmentMaintenanceScalarFieldEnum | EquipmentMaintenanceScalarFieldEnum[]
  }

  /**
   * EquipmentMaintenance create
   */
  export type EquipmentMaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * The data needed to create a EquipmentMaintenance.
     */
    data: XOR<EquipmentMaintenanceCreateInput, EquipmentMaintenanceUncheckedCreateInput>
  }

  /**
   * EquipmentMaintenance createMany
   */
  export type EquipmentMaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentMaintenances.
     */
    data: EquipmentMaintenanceCreateManyInput | EquipmentMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentMaintenance createManyAndReturn
   */
  export type EquipmentMaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentMaintenances.
     */
    data: EquipmentMaintenanceCreateManyInput | EquipmentMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentMaintenance update
   */
  export type EquipmentMaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * The data needed to update a EquipmentMaintenance.
     */
    data: XOR<EquipmentMaintenanceUpdateInput, EquipmentMaintenanceUncheckedUpdateInput>
    /**
     * Choose, which EquipmentMaintenance to update.
     */
    where: EquipmentMaintenanceWhereUniqueInput
  }

  /**
   * EquipmentMaintenance updateMany
   */
  export type EquipmentMaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentMaintenances.
     */
    data: XOR<EquipmentMaintenanceUpdateManyMutationInput, EquipmentMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentMaintenances to update
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * Limit how many EquipmentMaintenances to update.
     */
    limit?: number
  }

  /**
   * EquipmentMaintenance updateManyAndReturn
   */
  export type EquipmentMaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentMaintenances.
     */
    data: XOR<EquipmentMaintenanceUpdateManyMutationInput, EquipmentMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentMaintenances to update
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * Limit how many EquipmentMaintenances to update.
     */
    limit?: number
  }

  /**
   * EquipmentMaintenance upsert
   */
  export type EquipmentMaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * The filter to search for the EquipmentMaintenance to update in case it exists.
     */
    where: EquipmentMaintenanceWhereUniqueInput
    /**
     * In case the EquipmentMaintenance found by the `where` argument doesn't exist, create a new EquipmentMaintenance with this data.
     */
    create: XOR<EquipmentMaintenanceCreateInput, EquipmentMaintenanceUncheckedCreateInput>
    /**
     * In case the EquipmentMaintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentMaintenanceUpdateInput, EquipmentMaintenanceUncheckedUpdateInput>
  }

  /**
   * EquipmentMaintenance delete
   */
  export type EquipmentMaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
    /**
     * Filter which EquipmentMaintenance to delete.
     */
    where: EquipmentMaintenanceWhereUniqueInput
  }

  /**
   * EquipmentMaintenance deleteMany
   */
  export type EquipmentMaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentMaintenances to delete
     */
    where?: EquipmentMaintenanceWhereInput
    /**
     * Limit how many EquipmentMaintenances to delete.
     */
    limit?: number
  }

  /**
   * EquipmentMaintenance without action
   */
  export type EquipmentMaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentMaintenance
     */
    select?: EquipmentMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentMaintenance
     */
    omit?: EquipmentMaintenanceOmit<ExtArgs> | null
  }


  /**
   * Model Ambulance
   */

  export type AggregateAmbulance = {
    _count: AmbulanceCountAggregateOutputType | null
    _avg: AmbulanceAvgAggregateOutputType | null
    _sum: AmbulanceSumAggregateOutputType | null
    _min: AmbulanceMinAggregateOutputType | null
    _max: AmbulanceMaxAggregateOutputType | null
  }

  export type AmbulanceAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type AmbulanceSumAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type AmbulanceMinAggregateOutputType = {
    id: number | null
    vehicleNumber: string | null
    model: string | null
    type: string | null
    capacity: number | null
    driverName: string | null
    driverContact: string | null
    status: string | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmbulanceMaxAggregateOutputType = {
    id: number | null
    vehicleNumber: string | null
    model: string | null
    type: string | null
    capacity: number | null
    driverName: string | null
    driverContact: string | null
    status: string | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmbulanceCountAggregateOutputType = {
    id: number
    vehicleNumber: number
    model: number
    type: number
    capacity: number
    driverName: number
    driverContact: number
    status: number
    lastMaintenanceDate: number
    nextMaintenanceDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmbulanceAvgAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type AmbulanceSumAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type AmbulanceMinAggregateInputType = {
    id?: true
    vehicleNumber?: true
    model?: true
    type?: true
    capacity?: true
    driverName?: true
    driverContact?: true
    status?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmbulanceMaxAggregateInputType = {
    id?: true
    vehicleNumber?: true
    model?: true
    type?: true
    capacity?: true
    driverName?: true
    driverContact?: true
    status?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmbulanceCountAggregateInputType = {
    id?: true
    vehicleNumber?: true
    model?: true
    type?: true
    capacity?: true
    driverName?: true
    driverContact?: true
    status?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmbulanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ambulance to aggregate.
     */
    where?: AmbulanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ambulances to fetch.
     */
    orderBy?: AmbulanceOrderByWithRelationInput | AmbulanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmbulanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ambulances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ambulances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ambulances
    **/
    _count?: true | AmbulanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmbulanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmbulanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmbulanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmbulanceMaxAggregateInputType
  }

  export type GetAmbulanceAggregateType<T extends AmbulanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAmbulance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmbulance[P]>
      : GetScalarType<T[P], AggregateAmbulance[P]>
  }




  export type AmbulanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmbulanceWhereInput
    orderBy?: AmbulanceOrderByWithAggregationInput | AmbulanceOrderByWithAggregationInput[]
    by: AmbulanceScalarFieldEnum[] | AmbulanceScalarFieldEnum
    having?: AmbulanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmbulanceCountAggregateInputType | true
    _avg?: AmbulanceAvgAggregateInputType
    _sum?: AmbulanceSumAggregateInputType
    _min?: AmbulanceMinAggregateInputType
    _max?: AmbulanceMaxAggregateInputType
  }

  export type AmbulanceGroupByOutputType = {
    id: number
    vehicleNumber: string
    model: string | null
    type: string
    capacity: number
    driverName: string | null
    driverContact: string | null
    status: string
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AmbulanceCountAggregateOutputType | null
    _avg: AmbulanceAvgAggregateOutputType | null
    _sum: AmbulanceSumAggregateOutputType | null
    _min: AmbulanceMinAggregateOutputType | null
    _max: AmbulanceMaxAggregateOutputType | null
  }

  type GetAmbulanceGroupByPayload<T extends AmbulanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmbulanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmbulanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmbulanceGroupByOutputType[P]>
            : GetScalarType<T[P], AmbulanceGroupByOutputType[P]>
        }
      >
    >


  export type AmbulanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleNumber?: boolean
    model?: boolean
    type?: boolean
    capacity?: boolean
    driverName?: boolean
    driverContact?: boolean
    status?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambulanceServices?: boolean | Ambulance$ambulanceServicesArgs<ExtArgs>
    _count?: boolean | AmbulanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulance"]>

  export type AmbulanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleNumber?: boolean
    model?: boolean
    type?: boolean
    capacity?: boolean
    driverName?: boolean
    driverContact?: boolean
    status?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ambulance"]>

  export type AmbulanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleNumber?: boolean
    model?: boolean
    type?: boolean
    capacity?: boolean
    driverName?: boolean
    driverContact?: boolean
    status?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ambulance"]>

  export type AmbulanceSelectScalar = {
    id?: boolean
    vehicleNumber?: boolean
    model?: boolean
    type?: boolean
    capacity?: boolean
    driverName?: boolean
    driverContact?: boolean
    status?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmbulanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicleNumber" | "model" | "type" | "capacity" | "driverName" | "driverContact" | "status" | "lastMaintenanceDate" | "nextMaintenanceDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["ambulance"]>
  export type AmbulanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambulanceServices?: boolean | Ambulance$ambulanceServicesArgs<ExtArgs>
    _count?: boolean | AmbulanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmbulanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmbulanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmbulancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ambulance"
    objects: {
      ambulanceServices: Prisma.$AmbulanceServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vehicleNumber: string
      model: string | null
      type: string
      capacity: number
      driverName: string | null
      driverContact: string | null
      status: string
      lastMaintenanceDate: Date | null
      nextMaintenanceDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ambulance"]>
    composites: {}
  }

  type AmbulanceGetPayload<S extends boolean | null | undefined | AmbulanceDefaultArgs> = $Result.GetResult<Prisma.$AmbulancePayload, S>

  type AmbulanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmbulanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmbulanceCountAggregateInputType | true
    }

  export interface AmbulanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ambulance'], meta: { name: 'Ambulance' } }
    /**
     * Find zero or one Ambulance that matches the filter.
     * @param {AmbulanceFindUniqueArgs} args - Arguments to find a Ambulance
     * @example
     * // Get one Ambulance
     * const ambulance = await prisma.ambulance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmbulanceFindUniqueArgs>(args: SelectSubset<T, AmbulanceFindUniqueArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ambulance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmbulanceFindUniqueOrThrowArgs} args - Arguments to find a Ambulance
     * @example
     * // Get one Ambulance
     * const ambulance = await prisma.ambulance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmbulanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AmbulanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ambulance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceFindFirstArgs} args - Arguments to find a Ambulance
     * @example
     * // Get one Ambulance
     * const ambulance = await prisma.ambulance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmbulanceFindFirstArgs>(args?: SelectSubset<T, AmbulanceFindFirstArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ambulance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceFindFirstOrThrowArgs} args - Arguments to find a Ambulance
     * @example
     * // Get one Ambulance
     * const ambulance = await prisma.ambulance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmbulanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AmbulanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ambulances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ambulances
     * const ambulances = await prisma.ambulance.findMany()
     * 
     * // Get first 10 Ambulances
     * const ambulances = await prisma.ambulance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ambulanceWithIdOnly = await prisma.ambulance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmbulanceFindManyArgs>(args?: SelectSubset<T, AmbulanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ambulance.
     * @param {AmbulanceCreateArgs} args - Arguments to create a Ambulance.
     * @example
     * // Create one Ambulance
     * const Ambulance = await prisma.ambulance.create({
     *   data: {
     *     // ... data to create a Ambulance
     *   }
     * })
     * 
     */
    create<T extends AmbulanceCreateArgs>(args: SelectSubset<T, AmbulanceCreateArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ambulances.
     * @param {AmbulanceCreateManyArgs} args - Arguments to create many Ambulances.
     * @example
     * // Create many Ambulances
     * const ambulance = await prisma.ambulance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmbulanceCreateManyArgs>(args?: SelectSubset<T, AmbulanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ambulances and returns the data saved in the database.
     * @param {AmbulanceCreateManyAndReturnArgs} args - Arguments to create many Ambulances.
     * @example
     * // Create many Ambulances
     * const ambulance = await prisma.ambulance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ambulances and only return the `id`
     * const ambulanceWithIdOnly = await prisma.ambulance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmbulanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AmbulanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ambulance.
     * @param {AmbulanceDeleteArgs} args - Arguments to delete one Ambulance.
     * @example
     * // Delete one Ambulance
     * const Ambulance = await prisma.ambulance.delete({
     *   where: {
     *     // ... filter to delete one Ambulance
     *   }
     * })
     * 
     */
    delete<T extends AmbulanceDeleteArgs>(args: SelectSubset<T, AmbulanceDeleteArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ambulance.
     * @param {AmbulanceUpdateArgs} args - Arguments to update one Ambulance.
     * @example
     * // Update one Ambulance
     * const ambulance = await prisma.ambulance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmbulanceUpdateArgs>(args: SelectSubset<T, AmbulanceUpdateArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ambulances.
     * @param {AmbulanceDeleteManyArgs} args - Arguments to filter Ambulances to delete.
     * @example
     * // Delete a few Ambulances
     * const { count } = await prisma.ambulance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmbulanceDeleteManyArgs>(args?: SelectSubset<T, AmbulanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ambulances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ambulances
     * const ambulance = await prisma.ambulance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmbulanceUpdateManyArgs>(args: SelectSubset<T, AmbulanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ambulances and returns the data updated in the database.
     * @param {AmbulanceUpdateManyAndReturnArgs} args - Arguments to update many Ambulances.
     * @example
     * // Update many Ambulances
     * const ambulance = await prisma.ambulance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ambulances and only return the `id`
     * const ambulanceWithIdOnly = await prisma.ambulance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmbulanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AmbulanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ambulance.
     * @param {AmbulanceUpsertArgs} args - Arguments to update or create a Ambulance.
     * @example
     * // Update or create a Ambulance
     * const ambulance = await prisma.ambulance.upsert({
     *   create: {
     *     // ... data to create a Ambulance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ambulance we want to update
     *   }
     * })
     */
    upsert<T extends AmbulanceUpsertArgs>(args: SelectSubset<T, AmbulanceUpsertArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ambulances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceCountArgs} args - Arguments to filter Ambulances to count.
     * @example
     * // Count the number of Ambulances
     * const count = await prisma.ambulance.count({
     *   where: {
     *     // ... the filter for the Ambulances we want to count
     *   }
     * })
    **/
    count<T extends AmbulanceCountArgs>(
      args?: Subset<T, AmbulanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmbulanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ambulance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmbulanceAggregateArgs>(args: Subset<T, AmbulanceAggregateArgs>): Prisma.PrismaPromise<GetAmbulanceAggregateType<T>>

    /**
     * Group by Ambulance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmbulanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmbulanceGroupByArgs['orderBy'] }
        : { orderBy?: AmbulanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmbulanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmbulanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ambulance model
   */
  readonly fields: AmbulanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ambulance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmbulanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ambulanceServices<T extends Ambulance$ambulanceServicesArgs<ExtArgs> = {}>(args?: Subset<T, Ambulance$ambulanceServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ambulance model
   */
  interface AmbulanceFieldRefs {
    readonly id: FieldRef<"Ambulance", 'Int'>
    readonly vehicleNumber: FieldRef<"Ambulance", 'String'>
    readonly model: FieldRef<"Ambulance", 'String'>
    readonly type: FieldRef<"Ambulance", 'String'>
    readonly capacity: FieldRef<"Ambulance", 'Int'>
    readonly driverName: FieldRef<"Ambulance", 'String'>
    readonly driverContact: FieldRef<"Ambulance", 'String'>
    readonly status: FieldRef<"Ambulance", 'String'>
    readonly lastMaintenanceDate: FieldRef<"Ambulance", 'DateTime'>
    readonly nextMaintenanceDate: FieldRef<"Ambulance", 'DateTime'>
    readonly notes: FieldRef<"Ambulance", 'String'>
    readonly createdAt: FieldRef<"Ambulance", 'DateTime'>
    readonly updatedAt: FieldRef<"Ambulance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ambulance findUnique
   */
  export type AmbulanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * Filter, which Ambulance to fetch.
     */
    where: AmbulanceWhereUniqueInput
  }

  /**
   * Ambulance findUniqueOrThrow
   */
  export type AmbulanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * Filter, which Ambulance to fetch.
     */
    where: AmbulanceWhereUniqueInput
  }

  /**
   * Ambulance findFirst
   */
  export type AmbulanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * Filter, which Ambulance to fetch.
     */
    where?: AmbulanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ambulances to fetch.
     */
    orderBy?: AmbulanceOrderByWithRelationInput | AmbulanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ambulances.
     */
    cursor?: AmbulanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ambulances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ambulances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ambulances.
     */
    distinct?: AmbulanceScalarFieldEnum | AmbulanceScalarFieldEnum[]
  }

  /**
   * Ambulance findFirstOrThrow
   */
  export type AmbulanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * Filter, which Ambulance to fetch.
     */
    where?: AmbulanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ambulances to fetch.
     */
    orderBy?: AmbulanceOrderByWithRelationInput | AmbulanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ambulances.
     */
    cursor?: AmbulanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ambulances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ambulances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ambulances.
     */
    distinct?: AmbulanceScalarFieldEnum | AmbulanceScalarFieldEnum[]
  }

  /**
   * Ambulance findMany
   */
  export type AmbulanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * Filter, which Ambulances to fetch.
     */
    where?: AmbulanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ambulances to fetch.
     */
    orderBy?: AmbulanceOrderByWithRelationInput | AmbulanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ambulances.
     */
    cursor?: AmbulanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ambulances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ambulances.
     */
    skip?: number
    distinct?: AmbulanceScalarFieldEnum | AmbulanceScalarFieldEnum[]
  }

  /**
   * Ambulance create
   */
  export type AmbulanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Ambulance.
     */
    data: XOR<AmbulanceCreateInput, AmbulanceUncheckedCreateInput>
  }

  /**
   * Ambulance createMany
   */
  export type AmbulanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ambulances.
     */
    data: AmbulanceCreateManyInput | AmbulanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ambulance createManyAndReturn
   */
  export type AmbulanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * The data used to create many Ambulances.
     */
    data: AmbulanceCreateManyInput | AmbulanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ambulance update
   */
  export type AmbulanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Ambulance.
     */
    data: XOR<AmbulanceUpdateInput, AmbulanceUncheckedUpdateInput>
    /**
     * Choose, which Ambulance to update.
     */
    where: AmbulanceWhereUniqueInput
  }

  /**
   * Ambulance updateMany
   */
  export type AmbulanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ambulances.
     */
    data: XOR<AmbulanceUpdateManyMutationInput, AmbulanceUncheckedUpdateManyInput>
    /**
     * Filter which Ambulances to update
     */
    where?: AmbulanceWhereInput
    /**
     * Limit how many Ambulances to update.
     */
    limit?: number
  }

  /**
   * Ambulance updateManyAndReturn
   */
  export type AmbulanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * The data used to update Ambulances.
     */
    data: XOR<AmbulanceUpdateManyMutationInput, AmbulanceUncheckedUpdateManyInput>
    /**
     * Filter which Ambulances to update
     */
    where?: AmbulanceWhereInput
    /**
     * Limit how many Ambulances to update.
     */
    limit?: number
  }

  /**
   * Ambulance upsert
   */
  export type AmbulanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Ambulance to update in case it exists.
     */
    where: AmbulanceWhereUniqueInput
    /**
     * In case the Ambulance found by the `where` argument doesn't exist, create a new Ambulance with this data.
     */
    create: XOR<AmbulanceCreateInput, AmbulanceUncheckedCreateInput>
    /**
     * In case the Ambulance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmbulanceUpdateInput, AmbulanceUncheckedUpdateInput>
  }

  /**
   * Ambulance delete
   */
  export type AmbulanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
    /**
     * Filter which Ambulance to delete.
     */
    where: AmbulanceWhereUniqueInput
  }

  /**
   * Ambulance deleteMany
   */
  export type AmbulanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ambulances to delete
     */
    where?: AmbulanceWhereInput
    /**
     * Limit how many Ambulances to delete.
     */
    limit?: number
  }

  /**
   * Ambulance.ambulanceServices
   */
  export type Ambulance$ambulanceServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    where?: AmbulanceServiceWhereInput
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    cursor?: AmbulanceServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * Ambulance without action
   */
  export type AmbulanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ambulance
     */
    select?: AmbulanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ambulance
     */
    omit?: AmbulanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceInclude<ExtArgs> | null
  }


  /**
   * Model AmbulanceService
   */

  export type AggregateAmbulanceService = {
    _count: AmbulanceServiceCountAggregateOutputType | null
    _avg: AmbulanceServiceAvgAggregateOutputType | null
    _sum: AmbulanceServiceSumAggregateOutputType | null
    _min: AmbulanceServiceMinAggregateOutputType | null
    _max: AmbulanceServiceMaxAggregateOutputType | null
  }

  export type AmbulanceServiceAvgAggregateOutputType = {
    id: number | null
    ambulanceId: number | null
    fare: Decimal | null
  }

  export type AmbulanceServiceSumAggregateOutputType = {
    id: number | null
    ambulanceId: number | null
    fare: Decimal | null
  }

  export type AmbulanceServiceMinAggregateOutputType = {
    id: number | null
    ambulanceId: number | null
    patientName: string | null
    patientContact: string | null
    pickupLocation: string | null
    dropLocation: string | null
    serviceDate: Date | null
    status: string | null
    fare: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmbulanceServiceMaxAggregateOutputType = {
    id: number | null
    ambulanceId: number | null
    patientName: string | null
    patientContact: string | null
    pickupLocation: string | null
    dropLocation: string | null
    serviceDate: Date | null
    status: string | null
    fare: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmbulanceServiceCountAggregateOutputType = {
    id: number
    ambulanceId: number
    patientName: number
    patientContact: number
    pickupLocation: number
    dropLocation: number
    serviceDate: number
    status: number
    fare: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmbulanceServiceAvgAggregateInputType = {
    id?: true
    ambulanceId?: true
    fare?: true
  }

  export type AmbulanceServiceSumAggregateInputType = {
    id?: true
    ambulanceId?: true
    fare?: true
  }

  export type AmbulanceServiceMinAggregateInputType = {
    id?: true
    ambulanceId?: true
    patientName?: true
    patientContact?: true
    pickupLocation?: true
    dropLocation?: true
    serviceDate?: true
    status?: true
    fare?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmbulanceServiceMaxAggregateInputType = {
    id?: true
    ambulanceId?: true
    patientName?: true
    patientContact?: true
    pickupLocation?: true
    dropLocation?: true
    serviceDate?: true
    status?: true
    fare?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmbulanceServiceCountAggregateInputType = {
    id?: true
    ambulanceId?: true
    patientName?: true
    patientContact?: true
    pickupLocation?: true
    dropLocation?: true
    serviceDate?: true
    status?: true
    fare?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmbulanceServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmbulanceService to aggregate.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmbulanceServices
    **/
    _count?: true | AmbulanceServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmbulanceServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmbulanceServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmbulanceServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmbulanceServiceMaxAggregateInputType
  }

  export type GetAmbulanceServiceAggregateType<T extends AmbulanceServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateAmbulanceService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmbulanceService[P]>
      : GetScalarType<T[P], AggregateAmbulanceService[P]>
  }




  export type AmbulanceServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmbulanceServiceWhereInput
    orderBy?: AmbulanceServiceOrderByWithAggregationInput | AmbulanceServiceOrderByWithAggregationInput[]
    by: AmbulanceServiceScalarFieldEnum[] | AmbulanceServiceScalarFieldEnum
    having?: AmbulanceServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmbulanceServiceCountAggregateInputType | true
    _avg?: AmbulanceServiceAvgAggregateInputType
    _sum?: AmbulanceServiceSumAggregateInputType
    _min?: AmbulanceServiceMinAggregateInputType
    _max?: AmbulanceServiceMaxAggregateInputType
  }

  export type AmbulanceServiceGroupByOutputType = {
    id: number
    ambulanceId: number
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date
    status: string
    fare: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AmbulanceServiceCountAggregateOutputType | null
    _avg: AmbulanceServiceAvgAggregateOutputType | null
    _sum: AmbulanceServiceSumAggregateOutputType | null
    _min: AmbulanceServiceMinAggregateOutputType | null
    _max: AmbulanceServiceMaxAggregateOutputType | null
  }

  type GetAmbulanceServiceGroupByPayload<T extends AmbulanceServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmbulanceServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmbulanceServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmbulanceServiceGroupByOutputType[P]>
            : GetScalarType<T[P], AmbulanceServiceGroupByOutputType[P]>
        }
      >
    >


  export type AmbulanceServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ambulanceId?: boolean
    patientName?: boolean
    patientContact?: boolean
    pickupLocation?: boolean
    dropLocation?: boolean
    serviceDate?: boolean
    status?: boolean
    fare?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambulance?: boolean | AmbulanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulanceService"]>

  export type AmbulanceServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ambulanceId?: boolean
    patientName?: boolean
    patientContact?: boolean
    pickupLocation?: boolean
    dropLocation?: boolean
    serviceDate?: boolean
    status?: boolean
    fare?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambulance?: boolean | AmbulanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulanceService"]>

  export type AmbulanceServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ambulanceId?: boolean
    patientName?: boolean
    patientContact?: boolean
    pickupLocation?: boolean
    dropLocation?: boolean
    serviceDate?: boolean
    status?: boolean
    fare?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambulance?: boolean | AmbulanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulanceService"]>

  export type AmbulanceServiceSelectScalar = {
    id?: boolean
    ambulanceId?: boolean
    patientName?: boolean
    patientContact?: boolean
    pickupLocation?: boolean
    dropLocation?: boolean
    serviceDate?: boolean
    status?: boolean
    fare?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmbulanceServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ambulanceId" | "patientName" | "patientContact" | "pickupLocation" | "dropLocation" | "serviceDate" | "status" | "fare" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["ambulanceService"]>
  export type AmbulanceServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambulance?: boolean | AmbulanceDefaultArgs<ExtArgs>
  }
  export type AmbulanceServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambulance?: boolean | AmbulanceDefaultArgs<ExtArgs>
  }
  export type AmbulanceServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambulance?: boolean | AmbulanceDefaultArgs<ExtArgs>
  }

  export type $AmbulanceServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmbulanceService"
    objects: {
      ambulance: Prisma.$AmbulancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ambulanceId: number
      patientName: string
      patientContact: string
      pickupLocation: string
      dropLocation: string
      serviceDate: Date
      status: string
      fare: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ambulanceService"]>
    composites: {}
  }

  type AmbulanceServiceGetPayload<S extends boolean | null | undefined | AmbulanceServiceDefaultArgs> = $Result.GetResult<Prisma.$AmbulanceServicePayload, S>

  type AmbulanceServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmbulanceServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmbulanceServiceCountAggregateInputType | true
    }

  export interface AmbulanceServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmbulanceService'], meta: { name: 'AmbulanceService' } }
    /**
     * Find zero or one AmbulanceService that matches the filter.
     * @param {AmbulanceServiceFindUniqueArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmbulanceServiceFindUniqueArgs>(args: SelectSubset<T, AmbulanceServiceFindUniqueArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmbulanceService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmbulanceServiceFindUniqueOrThrowArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmbulanceServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, AmbulanceServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmbulanceService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceFindFirstArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmbulanceServiceFindFirstArgs>(args?: SelectSubset<T, AmbulanceServiceFindFirstArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmbulanceService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceFindFirstOrThrowArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmbulanceServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, AmbulanceServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmbulanceServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmbulanceServices
     * const ambulanceServices = await prisma.ambulanceService.findMany()
     * 
     * // Get first 10 AmbulanceServices
     * const ambulanceServices = await prisma.ambulanceService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ambulanceServiceWithIdOnly = await prisma.ambulanceService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmbulanceServiceFindManyArgs>(args?: SelectSubset<T, AmbulanceServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmbulanceService.
     * @param {AmbulanceServiceCreateArgs} args - Arguments to create a AmbulanceService.
     * @example
     * // Create one AmbulanceService
     * const AmbulanceService = await prisma.ambulanceService.create({
     *   data: {
     *     // ... data to create a AmbulanceService
     *   }
     * })
     * 
     */
    create<T extends AmbulanceServiceCreateArgs>(args: SelectSubset<T, AmbulanceServiceCreateArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmbulanceServices.
     * @param {AmbulanceServiceCreateManyArgs} args - Arguments to create many AmbulanceServices.
     * @example
     * // Create many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmbulanceServiceCreateManyArgs>(args?: SelectSubset<T, AmbulanceServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AmbulanceServices and returns the data saved in the database.
     * @param {AmbulanceServiceCreateManyAndReturnArgs} args - Arguments to create many AmbulanceServices.
     * @example
     * // Create many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AmbulanceServices and only return the `id`
     * const ambulanceServiceWithIdOnly = await prisma.ambulanceService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmbulanceServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, AmbulanceServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AmbulanceService.
     * @param {AmbulanceServiceDeleteArgs} args - Arguments to delete one AmbulanceService.
     * @example
     * // Delete one AmbulanceService
     * const AmbulanceService = await prisma.ambulanceService.delete({
     *   where: {
     *     // ... filter to delete one AmbulanceService
     *   }
     * })
     * 
     */
    delete<T extends AmbulanceServiceDeleteArgs>(args: SelectSubset<T, AmbulanceServiceDeleteArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmbulanceService.
     * @param {AmbulanceServiceUpdateArgs} args - Arguments to update one AmbulanceService.
     * @example
     * // Update one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmbulanceServiceUpdateArgs>(args: SelectSubset<T, AmbulanceServiceUpdateArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmbulanceServices.
     * @param {AmbulanceServiceDeleteManyArgs} args - Arguments to filter AmbulanceServices to delete.
     * @example
     * // Delete a few AmbulanceServices
     * const { count } = await prisma.ambulanceService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmbulanceServiceDeleteManyArgs>(args?: SelectSubset<T, AmbulanceServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmbulanceServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmbulanceServiceUpdateManyArgs>(args: SelectSubset<T, AmbulanceServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmbulanceServices and returns the data updated in the database.
     * @param {AmbulanceServiceUpdateManyAndReturnArgs} args - Arguments to update many AmbulanceServices.
     * @example
     * // Update many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AmbulanceServices and only return the `id`
     * const ambulanceServiceWithIdOnly = await prisma.ambulanceService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmbulanceServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, AmbulanceServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AmbulanceService.
     * @param {AmbulanceServiceUpsertArgs} args - Arguments to update or create a AmbulanceService.
     * @example
     * // Update or create a AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.upsert({
     *   create: {
     *     // ... data to create a AmbulanceService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmbulanceService we want to update
     *   }
     * })
     */
    upsert<T extends AmbulanceServiceUpsertArgs>(args: SelectSubset<T, AmbulanceServiceUpsertArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmbulanceServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceCountArgs} args - Arguments to filter AmbulanceServices to count.
     * @example
     * // Count the number of AmbulanceServices
     * const count = await prisma.ambulanceService.count({
     *   where: {
     *     // ... the filter for the AmbulanceServices we want to count
     *   }
     * })
    **/
    count<T extends AmbulanceServiceCountArgs>(
      args?: Subset<T, AmbulanceServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmbulanceServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmbulanceService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmbulanceServiceAggregateArgs>(args: Subset<T, AmbulanceServiceAggregateArgs>): Prisma.PrismaPromise<GetAmbulanceServiceAggregateType<T>>

    /**
     * Group by AmbulanceService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmbulanceServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmbulanceServiceGroupByArgs['orderBy'] }
        : { orderBy?: AmbulanceServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmbulanceServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmbulanceServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmbulanceService model
   */
  readonly fields: AmbulanceServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmbulanceService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmbulanceServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ambulance<T extends AmbulanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmbulanceDefaultArgs<ExtArgs>>): Prisma__AmbulanceClient<$Result.GetResult<Prisma.$AmbulancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmbulanceService model
   */
  interface AmbulanceServiceFieldRefs {
    readonly id: FieldRef<"AmbulanceService", 'Int'>
    readonly ambulanceId: FieldRef<"AmbulanceService", 'Int'>
    readonly patientName: FieldRef<"AmbulanceService", 'String'>
    readonly patientContact: FieldRef<"AmbulanceService", 'String'>
    readonly pickupLocation: FieldRef<"AmbulanceService", 'String'>
    readonly dropLocation: FieldRef<"AmbulanceService", 'String'>
    readonly serviceDate: FieldRef<"AmbulanceService", 'DateTime'>
    readonly status: FieldRef<"AmbulanceService", 'String'>
    readonly fare: FieldRef<"AmbulanceService", 'Decimal'>
    readonly notes: FieldRef<"AmbulanceService", 'String'>
    readonly createdAt: FieldRef<"AmbulanceService", 'DateTime'>
    readonly updatedAt: FieldRef<"AmbulanceService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmbulanceService findUnique
   */
  export type AmbulanceServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService findUniqueOrThrow
   */
  export type AmbulanceServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService findFirst
   */
  export type AmbulanceServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmbulanceServices.
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmbulanceServices.
     */
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * AmbulanceService findFirstOrThrow
   */
  export type AmbulanceServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmbulanceServices.
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmbulanceServices.
     */
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * AmbulanceService findMany
   */
  export type AmbulanceServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceServices to fetch.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmbulanceServices.
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * AmbulanceService create
   */
  export type AmbulanceServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a AmbulanceService.
     */
    data: XOR<AmbulanceServiceCreateInput, AmbulanceServiceUncheckedCreateInput>
  }

  /**
   * AmbulanceService createMany
   */
  export type AmbulanceServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmbulanceServices.
     */
    data: AmbulanceServiceCreateManyInput | AmbulanceServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmbulanceService createManyAndReturn
   */
  export type AmbulanceServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * The data used to create many AmbulanceServices.
     */
    data: AmbulanceServiceCreateManyInput | AmbulanceServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmbulanceService update
   */
  export type AmbulanceServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a AmbulanceService.
     */
    data: XOR<AmbulanceServiceUpdateInput, AmbulanceServiceUncheckedUpdateInput>
    /**
     * Choose, which AmbulanceService to update.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService updateMany
   */
  export type AmbulanceServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmbulanceServices.
     */
    data: XOR<AmbulanceServiceUpdateManyMutationInput, AmbulanceServiceUncheckedUpdateManyInput>
    /**
     * Filter which AmbulanceServices to update
     */
    where?: AmbulanceServiceWhereInput
    /**
     * Limit how many AmbulanceServices to update.
     */
    limit?: number
  }

  /**
   * AmbulanceService updateManyAndReturn
   */
  export type AmbulanceServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * The data used to update AmbulanceServices.
     */
    data: XOR<AmbulanceServiceUpdateManyMutationInput, AmbulanceServiceUncheckedUpdateManyInput>
    /**
     * Filter which AmbulanceServices to update
     */
    where?: AmbulanceServiceWhereInput
    /**
     * Limit how many AmbulanceServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmbulanceService upsert
   */
  export type AmbulanceServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the AmbulanceService to update in case it exists.
     */
    where: AmbulanceServiceWhereUniqueInput
    /**
     * In case the AmbulanceService found by the `where` argument doesn't exist, create a new AmbulanceService with this data.
     */
    create: XOR<AmbulanceServiceCreateInput, AmbulanceServiceUncheckedCreateInput>
    /**
     * In case the AmbulanceService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmbulanceServiceUpdateInput, AmbulanceServiceUncheckedUpdateInput>
  }

  /**
   * AmbulanceService delete
   */
  export type AmbulanceServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter which AmbulanceService to delete.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService deleteMany
   */
  export type AmbulanceServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmbulanceServices to delete
     */
    where?: AmbulanceServiceWhereInput
    /**
     * Limit how many AmbulanceServices to delete.
     */
    limit?: number
  }

  /**
   * AmbulanceService without action
   */
  export type AmbulanceServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
  }


  /**
   * Model BiometricData
   */

  export type AggregateBiometricData = {
    _count: BiometricDataCountAggregateOutputType | null
    _avg: BiometricDataAvgAggregateOutputType | null
    _sum: BiometricDataSumAggregateOutputType | null
    _min: BiometricDataMinAggregateOutputType | null
    _max: BiometricDataMaxAggregateOutputType | null
  }

  export type BiometricDataAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BiometricDataSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BiometricDataMinAggregateOutputType = {
    id: number | null
    userId: number | null
    biometricId: string | null
    fingerprint: string | null
    faceData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiometricDataMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    biometricId: string | null
    fingerprint: string | null
    faceData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiometricDataCountAggregateOutputType = {
    id: number
    userId: number
    biometricId: number
    fingerprint: number
    faceData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiometricDataAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BiometricDataSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BiometricDataMinAggregateInputType = {
    id?: true
    userId?: true
    biometricId?: true
    fingerprint?: true
    faceData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiometricDataMaxAggregateInputType = {
    id?: true
    userId?: true
    biometricId?: true
    fingerprint?: true
    faceData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiometricDataCountAggregateInputType = {
    id?: true
    userId?: true
    biometricId?: true
    fingerprint?: true
    faceData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiometricDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiometricData to aggregate.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiometricData
    **/
    _count?: true | BiometricDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiometricDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiometricDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiometricDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiometricDataMaxAggregateInputType
  }

  export type GetBiometricDataAggregateType<T extends BiometricDataAggregateArgs> = {
        [P in keyof T & keyof AggregateBiometricData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiometricData[P]>
      : GetScalarType<T[P], AggregateBiometricData[P]>
  }




  export type BiometricDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiometricDataWhereInput
    orderBy?: BiometricDataOrderByWithAggregationInput | BiometricDataOrderByWithAggregationInput[]
    by: BiometricDataScalarFieldEnum[] | BiometricDataScalarFieldEnum
    having?: BiometricDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiometricDataCountAggregateInputType | true
    _avg?: BiometricDataAvgAggregateInputType
    _sum?: BiometricDataSumAggregateInputType
    _min?: BiometricDataMinAggregateInputType
    _max?: BiometricDataMaxAggregateInputType
  }

  export type BiometricDataGroupByOutputType = {
    id: number
    userId: number
    biometricId: string
    fingerprint: string | null
    faceData: string | null
    createdAt: Date
    updatedAt: Date
    _count: BiometricDataCountAggregateOutputType | null
    _avg: BiometricDataAvgAggregateOutputType | null
    _sum: BiometricDataSumAggregateOutputType | null
    _min: BiometricDataMinAggregateOutputType | null
    _max: BiometricDataMaxAggregateOutputType | null
  }

  type GetBiometricDataGroupByPayload<T extends BiometricDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiometricDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiometricDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiometricDataGroupByOutputType[P]>
            : GetScalarType<T[P], BiometricDataGroupByOutputType[P]>
        }
      >
    >


  export type BiometricDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biometricId?: boolean
    fingerprint?: boolean
    faceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biometricId?: boolean
    fingerprint?: boolean
    faceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biometricId?: boolean
    fingerprint?: boolean
    faceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectScalar = {
    id?: boolean
    userId?: boolean
    biometricId?: boolean
    fingerprint?: boolean
    faceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiometricDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "biometricId" | "fingerprint" | "faceData" | "createdAt" | "updatedAt", ExtArgs["result"]["biometricData"]>
  export type BiometricDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BiometricDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BiometricDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BiometricDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiometricData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      biometricId: string
      fingerprint: string | null
      faceData: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biometricData"]>
    composites: {}
  }

  type BiometricDataGetPayload<S extends boolean | null | undefined | BiometricDataDefaultArgs> = $Result.GetResult<Prisma.$BiometricDataPayload, S>

  type BiometricDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BiometricDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BiometricDataCountAggregateInputType | true
    }

  export interface BiometricDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiometricData'], meta: { name: 'BiometricData' } }
    /**
     * Find zero or one BiometricData that matches the filter.
     * @param {BiometricDataFindUniqueArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiometricDataFindUniqueArgs>(args: SelectSubset<T, BiometricDataFindUniqueArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BiometricData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BiometricDataFindUniqueOrThrowArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiometricDataFindUniqueOrThrowArgs>(args: SelectSubset<T, BiometricDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BiometricData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindFirstArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiometricDataFindFirstArgs>(args?: SelectSubset<T, BiometricDataFindFirstArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BiometricData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindFirstOrThrowArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiometricDataFindFirstOrThrowArgs>(args?: SelectSubset<T, BiometricDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BiometricData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiometricData
     * const biometricData = await prisma.biometricData.findMany()
     * 
     * // Get first 10 BiometricData
     * const biometricData = await prisma.biometricData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiometricDataFindManyArgs>(args?: SelectSubset<T, BiometricDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BiometricData.
     * @param {BiometricDataCreateArgs} args - Arguments to create a BiometricData.
     * @example
     * // Create one BiometricData
     * const BiometricData = await prisma.biometricData.create({
     *   data: {
     *     // ... data to create a BiometricData
     *   }
     * })
     * 
     */
    create<T extends BiometricDataCreateArgs>(args: SelectSubset<T, BiometricDataCreateArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BiometricData.
     * @param {BiometricDataCreateManyArgs} args - Arguments to create many BiometricData.
     * @example
     * // Create many BiometricData
     * const biometricData = await prisma.biometricData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiometricDataCreateManyArgs>(args?: SelectSubset<T, BiometricDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiometricData and returns the data saved in the database.
     * @param {BiometricDataCreateManyAndReturnArgs} args - Arguments to create many BiometricData.
     * @example
     * // Create many BiometricData
     * const biometricData = await prisma.biometricData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiometricData and only return the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiometricDataCreateManyAndReturnArgs>(args?: SelectSubset<T, BiometricDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BiometricData.
     * @param {BiometricDataDeleteArgs} args - Arguments to delete one BiometricData.
     * @example
     * // Delete one BiometricData
     * const BiometricData = await prisma.biometricData.delete({
     *   where: {
     *     // ... filter to delete one BiometricData
     *   }
     * })
     * 
     */
    delete<T extends BiometricDataDeleteArgs>(args: SelectSubset<T, BiometricDataDeleteArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BiometricData.
     * @param {BiometricDataUpdateArgs} args - Arguments to update one BiometricData.
     * @example
     * // Update one BiometricData
     * const biometricData = await prisma.biometricData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiometricDataUpdateArgs>(args: SelectSubset<T, BiometricDataUpdateArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BiometricData.
     * @param {BiometricDataDeleteManyArgs} args - Arguments to filter BiometricData to delete.
     * @example
     * // Delete a few BiometricData
     * const { count } = await prisma.biometricData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiometricDataDeleteManyArgs>(args?: SelectSubset<T, BiometricDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiometricData
     * const biometricData = await prisma.biometricData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiometricDataUpdateManyArgs>(args: SelectSubset<T, BiometricDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiometricData and returns the data updated in the database.
     * @param {BiometricDataUpdateManyAndReturnArgs} args - Arguments to update many BiometricData.
     * @example
     * // Update many BiometricData
     * const biometricData = await prisma.biometricData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BiometricData and only return the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BiometricDataUpdateManyAndReturnArgs>(args: SelectSubset<T, BiometricDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BiometricData.
     * @param {BiometricDataUpsertArgs} args - Arguments to update or create a BiometricData.
     * @example
     * // Update or create a BiometricData
     * const biometricData = await prisma.biometricData.upsert({
     *   create: {
     *     // ... data to create a BiometricData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiometricData we want to update
     *   }
     * })
     */
    upsert<T extends BiometricDataUpsertArgs>(args: SelectSubset<T, BiometricDataUpsertArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataCountArgs} args - Arguments to filter BiometricData to count.
     * @example
     * // Count the number of BiometricData
     * const count = await prisma.biometricData.count({
     *   where: {
     *     // ... the filter for the BiometricData we want to count
     *   }
     * })
    **/
    count<T extends BiometricDataCountArgs>(
      args?: Subset<T, BiometricDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiometricDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiometricDataAggregateArgs>(args: Subset<T, BiometricDataAggregateArgs>): Prisma.PrismaPromise<GetBiometricDataAggregateType<T>>

    /**
     * Group by BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiometricDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiometricDataGroupByArgs['orderBy'] }
        : { orderBy?: BiometricDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiometricDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiometricDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiometricData model
   */
  readonly fields: BiometricDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiometricData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiometricDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiometricData model
   */
  interface BiometricDataFieldRefs {
    readonly id: FieldRef<"BiometricData", 'Int'>
    readonly userId: FieldRef<"BiometricData", 'Int'>
    readonly biometricId: FieldRef<"BiometricData", 'String'>
    readonly fingerprint: FieldRef<"BiometricData", 'String'>
    readonly faceData: FieldRef<"BiometricData", 'String'>
    readonly createdAt: FieldRef<"BiometricData", 'DateTime'>
    readonly updatedAt: FieldRef<"BiometricData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BiometricData findUnique
   */
  export type BiometricDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData findUniqueOrThrow
   */
  export type BiometricDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData findFirst
   */
  export type BiometricDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiometricData.
     */
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData findFirstOrThrow
   */
  export type BiometricDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiometricData.
     */
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData findMany
   */
  export type BiometricDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData create
   */
  export type BiometricDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The data needed to create a BiometricData.
     */
    data: XOR<BiometricDataCreateInput, BiometricDataUncheckedCreateInput>
  }

  /**
   * BiometricData createMany
   */
  export type BiometricDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiometricData.
     */
    data: BiometricDataCreateManyInput | BiometricDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiometricData createManyAndReturn
   */
  export type BiometricDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * The data used to create many BiometricData.
     */
    data: BiometricDataCreateManyInput | BiometricDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiometricData update
   */
  export type BiometricDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The data needed to update a BiometricData.
     */
    data: XOR<BiometricDataUpdateInput, BiometricDataUncheckedUpdateInput>
    /**
     * Choose, which BiometricData to update.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData updateMany
   */
  export type BiometricDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiometricData.
     */
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyInput>
    /**
     * Filter which BiometricData to update
     */
    where?: BiometricDataWhereInput
    /**
     * Limit how many BiometricData to update.
     */
    limit?: number
  }

  /**
   * BiometricData updateManyAndReturn
   */
  export type BiometricDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * The data used to update BiometricData.
     */
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyInput>
    /**
     * Filter which BiometricData to update
     */
    where?: BiometricDataWhereInput
    /**
     * Limit how many BiometricData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiometricData upsert
   */
  export type BiometricDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The filter to search for the BiometricData to update in case it exists.
     */
    where: BiometricDataWhereUniqueInput
    /**
     * In case the BiometricData found by the `where` argument doesn't exist, create a new BiometricData with this data.
     */
    create: XOR<BiometricDataCreateInput, BiometricDataUncheckedCreateInput>
    /**
     * In case the BiometricData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiometricDataUpdateInput, BiometricDataUncheckedUpdateInput>
  }

  /**
   * BiometricData delete
   */
  export type BiometricDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter which BiometricData to delete.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData deleteMany
   */
  export type BiometricDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiometricData to delete
     */
    where?: BiometricDataWhereInput
    /**
     * Limit how many BiometricData to delete.
     */
    limit?: number
  }

  /**
   * BiometricData without action
   */
  export type BiometricDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceLog
   */

  export type AggregateAttendanceLog = {
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  export type AttendanceLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AttendanceLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AttendanceLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    checkInTime: Date | null
    checkOutTime: Date | null
    status: string | null
    deviceId: string | null
    verificationMode: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    checkInTime: Date | null
    checkOutTime: Date | null
    status: string | null
    deviceId: string | null
    verificationMode: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceLogCountAggregateOutputType = {
    id: number
    userId: number
    checkInTime: number
    checkOutTime: number
    status: number
    deviceId: number
    verificationMode: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AttendanceLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AttendanceLogMinAggregateInputType = {
    id?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    status?: true
    deviceId?: true
    verificationMode?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceLogMaxAggregateInputType = {
    id?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    status?: true
    deviceId?: true
    verificationMode?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceLogCountAggregateInputType = {
    id?: true
    userId?: true
    checkInTime?: true
    checkOutTime?: true
    status?: true
    deviceId?: true
    verificationMode?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLog to aggregate.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceLogs
    **/
    _count?: true | AttendanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type GetAttendanceLogAggregateType<T extends AttendanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceLog[P]>
      : GetScalarType<T[P], AggregateAttendanceLog[P]>
  }




  export type AttendanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithAggregationInput | AttendanceLogOrderByWithAggregationInput[]
    by: AttendanceLogScalarFieldEnum[] | AttendanceLogScalarFieldEnum
    having?: AttendanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceLogCountAggregateInputType | true
    _avg?: AttendanceLogAvgAggregateInputType
    _sum?: AttendanceLogSumAggregateInputType
    _min?: AttendanceLogMinAggregateInputType
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type AttendanceLogGroupByOutputType = {
    id: number
    userId: number
    checkInTime: Date | null
    checkOutTime: Date | null
    status: string
    deviceId: string | null
    verificationMode: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  type GetAttendanceLogGroupByPayload<T extends AttendanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    deviceId?: boolean
    verificationMode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    deviceId?: boolean
    verificationMode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    deviceId?: boolean
    verificationMode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectScalar = {
    id?: boolean
    userId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    deviceId?: boolean
    verificationMode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "checkInTime" | "checkOutTime" | "status" | "deviceId" | "verificationMode" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceLog"]>
  export type AttendanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      checkInTime: Date | null
      checkOutTime: Date | null
      status: string
      deviceId: string | null
      verificationMode: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceLog"]>
    composites: {}
  }

  type AttendanceLogGetPayload<S extends boolean | null | undefined | AttendanceLogDefaultArgs> = $Result.GetResult<Prisma.$AttendanceLogPayload, S>

  type AttendanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceLogCountAggregateInputType | true
    }

  export interface AttendanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceLog'], meta: { name: 'AttendanceLog' } }
    /**
     * Find zero or one AttendanceLog that matches the filter.
     * @param {AttendanceLogFindUniqueArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceLogFindUniqueArgs>(args: SelectSubset<T, AttendanceLogFindUniqueArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceLogFindUniqueOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceLogFindFirstArgs>(args?: SelectSubset<T, AttendanceLogFindFirstArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany()
     * 
     * // Get first 10 AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceLogFindManyArgs>(args?: SelectSubset<T, AttendanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceLog.
     * @param {AttendanceLogCreateArgs} args - Arguments to create a AttendanceLog.
     * @example
     * // Create one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.create({
     *   data: {
     *     // ... data to create a AttendanceLog
     *   }
     * })
     * 
     */
    create<T extends AttendanceLogCreateArgs>(args: SelectSubset<T, AttendanceLogCreateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceLogs.
     * @param {AttendanceLogCreateManyArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceLogCreateManyArgs>(args?: SelectSubset<T, AttendanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceLogs and returns the data saved in the database.
     * @param {AttendanceLogCreateManyAndReturnArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceLogs and only return the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceLog.
     * @param {AttendanceLogDeleteArgs} args - Arguments to delete one AttendanceLog.
     * @example
     * // Delete one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.delete({
     *   where: {
     *     // ... filter to delete one AttendanceLog
     *   }
     * })
     * 
     */
    delete<T extends AttendanceLogDeleteArgs>(args: SelectSubset<T, AttendanceLogDeleteArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceLog.
     * @param {AttendanceLogUpdateArgs} args - Arguments to update one AttendanceLog.
     * @example
     * // Update one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceLogUpdateArgs>(args: SelectSubset<T, AttendanceLogUpdateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceLogs.
     * @param {AttendanceLogDeleteManyArgs} args - Arguments to filter AttendanceLogs to delete.
     * @example
     * // Delete a few AttendanceLogs
     * const { count } = await prisma.attendanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceLogDeleteManyArgs>(args?: SelectSubset<T, AttendanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceLogUpdateManyArgs>(args: SelectSubset<T, AttendanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceLogs and returns the data updated in the database.
     * @param {AttendanceLogUpdateManyAndReturnArgs} args - Arguments to update many AttendanceLogs.
     * @example
     * // Update many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceLogs and only return the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceLog.
     * @param {AttendanceLogUpsertArgs} args - Arguments to update or create a AttendanceLog.
     * @example
     * // Update or create a AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.upsert({
     *   create: {
     *     // ... data to create a AttendanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceLog we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceLogUpsertArgs>(args: SelectSubset<T, AttendanceLogUpsertArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogCountArgs} args - Arguments to filter AttendanceLogs to count.
     * @example
     * // Count the number of AttendanceLogs
     * const count = await prisma.attendanceLog.count({
     *   where: {
     *     // ... the filter for the AttendanceLogs we want to count
     *   }
     * })
    **/
    count<T extends AttendanceLogCountArgs>(
      args?: Subset<T, AttendanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceLogAggregateArgs>(args: Subset<T, AttendanceLogAggregateArgs>): Prisma.PrismaPromise<GetAttendanceLogAggregateType<T>>

    /**
     * Group by AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceLogGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceLog model
   */
  readonly fields: AttendanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceLog model
   */
  interface AttendanceLogFieldRefs {
    readonly id: FieldRef<"AttendanceLog", 'Int'>
    readonly userId: FieldRef<"AttendanceLog", 'Int'>
    readonly checkInTime: FieldRef<"AttendanceLog", 'DateTime'>
    readonly checkOutTime: FieldRef<"AttendanceLog", 'DateTime'>
    readonly status: FieldRef<"AttendanceLog", 'String'>
    readonly deviceId: FieldRef<"AttendanceLog", 'String'>
    readonly verificationMode: FieldRef<"AttendanceLog", 'String'>
    readonly notes: FieldRef<"AttendanceLog", 'String'>
    readonly createdAt: FieldRef<"AttendanceLog", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceLog findUnique
   */
  export type AttendanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findUniqueOrThrow
   */
  export type AttendanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findFirst
   */
  export type AttendanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findFirstOrThrow
   */
  export type AttendanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findMany
   */
  export type AttendanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLogs to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog create
   */
  export type AttendanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceLog.
     */
    data: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
  }

  /**
   * AttendanceLog createMany
   */
  export type AttendanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceLog createManyAndReturn
   */
  export type AttendanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceLog update
   */
  export type AttendanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceLog.
     */
    data: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
    /**
     * Choose, which AttendanceLog to update.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog updateMany
   */
  export type AttendanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceLogs.
     */
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceLogs to update
     */
    where?: AttendanceLogWhereInput
    /**
     * Limit how many AttendanceLogs to update.
     */
    limit?: number
  }

  /**
   * AttendanceLog updateManyAndReturn
   */
  export type AttendanceLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceLogs.
     */
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceLogs to update
     */
    where?: AttendanceLogWhereInput
    /**
     * Limit how many AttendanceLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceLog upsert
   */
  export type AttendanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceLog to update in case it exists.
     */
    where: AttendanceLogWhereUniqueInput
    /**
     * In case the AttendanceLog found by the `where` argument doesn't exist, create a new AttendanceLog with this data.
     */
    create: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
    /**
     * In case the AttendanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
  }

  /**
   * AttendanceLog delete
   */
  export type AttendanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter which AttendanceLog to delete.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog deleteMany
   */
  export type AttendanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLogs to delete
     */
    where?: AttendanceLogWhereInput
    /**
     * Limit how many AttendanceLogs to delete.
     */
    limit?: number
  }

  /**
   * AttendanceLog without action
   */
  export type AttendanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
  }


  /**
   * Model DutyRoster
   */

  export type AggregateDutyRoster = {
    _count: DutyRosterCountAggregateOutputType | null
    _avg: DutyRosterAvgAggregateOutputType | null
    _sum: DutyRosterSumAggregateOutputType | null
    _min: DutyRosterMinAggregateOutputType | null
    _max: DutyRosterMaxAggregateOutputType | null
  }

  export type DutyRosterAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DutyRosterSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DutyRosterMinAggregateOutputType = {
    id: number | null
    userId: number | null
    startDate: Date | null
    endDate: Date | null
    shiftStart: string | null
    shiftEnd: string | null
    department: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyRosterMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    startDate: Date | null
    endDate: Date | null
    shiftStart: string | null
    shiftEnd: string | null
    department: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyRosterCountAggregateOutputType = {
    id: number
    userId: number
    startDate: number
    endDate: number
    shiftStart: number
    shiftEnd: number
    department: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DutyRosterAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DutyRosterSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DutyRosterMinAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    shiftStart?: true
    shiftEnd?: true
    department?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyRosterMaxAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    shiftStart?: true
    shiftEnd?: true
    department?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyRosterCountAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    shiftStart?: true
    shiftEnd?: true
    department?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DutyRosterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyRoster to aggregate.
     */
    where?: DutyRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRosters to fetch.
     */
    orderBy?: DutyRosterOrderByWithRelationInput | DutyRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DutyRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DutyRosters
    **/
    _count?: true | DutyRosterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DutyRosterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DutyRosterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DutyRosterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DutyRosterMaxAggregateInputType
  }

  export type GetDutyRosterAggregateType<T extends DutyRosterAggregateArgs> = {
        [P in keyof T & keyof AggregateDutyRoster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDutyRoster[P]>
      : GetScalarType<T[P], AggregateDutyRoster[P]>
  }




  export type DutyRosterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyRosterWhereInput
    orderBy?: DutyRosterOrderByWithAggregationInput | DutyRosterOrderByWithAggregationInput[]
    by: DutyRosterScalarFieldEnum[] | DutyRosterScalarFieldEnum
    having?: DutyRosterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DutyRosterCountAggregateInputType | true
    _avg?: DutyRosterAvgAggregateInputType
    _sum?: DutyRosterSumAggregateInputType
    _min?: DutyRosterMinAggregateInputType
    _max?: DutyRosterMaxAggregateInputType
  }

  export type DutyRosterGroupByOutputType = {
    id: number
    userId: number
    startDate: Date
    endDate: Date
    shiftStart: string
    shiftEnd: string
    department: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DutyRosterCountAggregateOutputType | null
    _avg: DutyRosterAvgAggregateOutputType | null
    _sum: DutyRosterSumAggregateOutputType | null
    _min: DutyRosterMinAggregateOutputType | null
    _max: DutyRosterMaxAggregateOutputType | null
  }

  type GetDutyRosterGroupByPayload<T extends DutyRosterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DutyRosterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DutyRosterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DutyRosterGroupByOutputType[P]>
            : GetScalarType<T[P], DutyRosterGroupByOutputType[P]>
        }
      >
    >


  export type DutyRosterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    department?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyRoster"]>

  export type DutyRosterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    department?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyRoster"]>

  export type DutyRosterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    department?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyRoster"]>

  export type DutyRosterSelectScalar = {
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    department?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DutyRosterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startDate" | "endDate" | "shiftStart" | "shiftEnd" | "department" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["dutyRoster"]>
  export type DutyRosterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DutyRosterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DutyRosterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DutyRosterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DutyRoster"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      startDate: Date
      endDate: Date
      shiftStart: string
      shiftEnd: string
      department: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dutyRoster"]>
    composites: {}
  }

  type DutyRosterGetPayload<S extends boolean | null | undefined | DutyRosterDefaultArgs> = $Result.GetResult<Prisma.$DutyRosterPayload, S>

  type DutyRosterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DutyRosterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DutyRosterCountAggregateInputType | true
    }

  export interface DutyRosterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DutyRoster'], meta: { name: 'DutyRoster' } }
    /**
     * Find zero or one DutyRoster that matches the filter.
     * @param {DutyRosterFindUniqueArgs} args - Arguments to find a DutyRoster
     * @example
     * // Get one DutyRoster
     * const dutyRoster = await prisma.dutyRoster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DutyRosterFindUniqueArgs>(args: SelectSubset<T, DutyRosterFindUniqueArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DutyRoster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DutyRosterFindUniqueOrThrowArgs} args - Arguments to find a DutyRoster
     * @example
     * // Get one DutyRoster
     * const dutyRoster = await prisma.dutyRoster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DutyRosterFindUniqueOrThrowArgs>(args: SelectSubset<T, DutyRosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DutyRoster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterFindFirstArgs} args - Arguments to find a DutyRoster
     * @example
     * // Get one DutyRoster
     * const dutyRoster = await prisma.dutyRoster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DutyRosterFindFirstArgs>(args?: SelectSubset<T, DutyRosterFindFirstArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DutyRoster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterFindFirstOrThrowArgs} args - Arguments to find a DutyRoster
     * @example
     * // Get one DutyRoster
     * const dutyRoster = await prisma.dutyRoster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DutyRosterFindFirstOrThrowArgs>(args?: SelectSubset<T, DutyRosterFindFirstOrThrowArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DutyRosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DutyRosters
     * const dutyRosters = await prisma.dutyRoster.findMany()
     * 
     * // Get first 10 DutyRosters
     * const dutyRosters = await prisma.dutyRoster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dutyRosterWithIdOnly = await prisma.dutyRoster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DutyRosterFindManyArgs>(args?: SelectSubset<T, DutyRosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DutyRoster.
     * @param {DutyRosterCreateArgs} args - Arguments to create a DutyRoster.
     * @example
     * // Create one DutyRoster
     * const DutyRoster = await prisma.dutyRoster.create({
     *   data: {
     *     // ... data to create a DutyRoster
     *   }
     * })
     * 
     */
    create<T extends DutyRosterCreateArgs>(args: SelectSubset<T, DutyRosterCreateArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DutyRosters.
     * @param {DutyRosterCreateManyArgs} args - Arguments to create many DutyRosters.
     * @example
     * // Create many DutyRosters
     * const dutyRoster = await prisma.dutyRoster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DutyRosterCreateManyArgs>(args?: SelectSubset<T, DutyRosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DutyRosters and returns the data saved in the database.
     * @param {DutyRosterCreateManyAndReturnArgs} args - Arguments to create many DutyRosters.
     * @example
     * // Create many DutyRosters
     * const dutyRoster = await prisma.dutyRoster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DutyRosters and only return the `id`
     * const dutyRosterWithIdOnly = await prisma.dutyRoster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DutyRosterCreateManyAndReturnArgs>(args?: SelectSubset<T, DutyRosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DutyRoster.
     * @param {DutyRosterDeleteArgs} args - Arguments to delete one DutyRoster.
     * @example
     * // Delete one DutyRoster
     * const DutyRoster = await prisma.dutyRoster.delete({
     *   where: {
     *     // ... filter to delete one DutyRoster
     *   }
     * })
     * 
     */
    delete<T extends DutyRosterDeleteArgs>(args: SelectSubset<T, DutyRosterDeleteArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DutyRoster.
     * @param {DutyRosterUpdateArgs} args - Arguments to update one DutyRoster.
     * @example
     * // Update one DutyRoster
     * const dutyRoster = await prisma.dutyRoster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DutyRosterUpdateArgs>(args: SelectSubset<T, DutyRosterUpdateArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DutyRosters.
     * @param {DutyRosterDeleteManyArgs} args - Arguments to filter DutyRosters to delete.
     * @example
     * // Delete a few DutyRosters
     * const { count } = await prisma.dutyRoster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DutyRosterDeleteManyArgs>(args?: SelectSubset<T, DutyRosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DutyRosters
     * const dutyRoster = await prisma.dutyRoster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DutyRosterUpdateManyArgs>(args: SelectSubset<T, DutyRosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyRosters and returns the data updated in the database.
     * @param {DutyRosterUpdateManyAndReturnArgs} args - Arguments to update many DutyRosters.
     * @example
     * // Update many DutyRosters
     * const dutyRoster = await prisma.dutyRoster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DutyRosters and only return the `id`
     * const dutyRosterWithIdOnly = await prisma.dutyRoster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DutyRosterUpdateManyAndReturnArgs>(args: SelectSubset<T, DutyRosterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DutyRoster.
     * @param {DutyRosterUpsertArgs} args - Arguments to update or create a DutyRoster.
     * @example
     * // Update or create a DutyRoster
     * const dutyRoster = await prisma.dutyRoster.upsert({
     *   create: {
     *     // ... data to create a DutyRoster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DutyRoster we want to update
     *   }
     * })
     */
    upsert<T extends DutyRosterUpsertArgs>(args: SelectSubset<T, DutyRosterUpsertArgs<ExtArgs>>): Prisma__DutyRosterClient<$Result.GetResult<Prisma.$DutyRosterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DutyRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterCountArgs} args - Arguments to filter DutyRosters to count.
     * @example
     * // Count the number of DutyRosters
     * const count = await prisma.dutyRoster.count({
     *   where: {
     *     // ... the filter for the DutyRosters we want to count
     *   }
     * })
    **/
    count<T extends DutyRosterCountArgs>(
      args?: Subset<T, DutyRosterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DutyRosterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DutyRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DutyRosterAggregateArgs>(args: Subset<T, DutyRosterAggregateArgs>): Prisma.PrismaPromise<GetDutyRosterAggregateType<T>>

    /**
     * Group by DutyRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyRosterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DutyRosterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DutyRosterGroupByArgs['orderBy'] }
        : { orderBy?: DutyRosterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DutyRosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDutyRosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DutyRoster model
   */
  readonly fields: DutyRosterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DutyRoster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DutyRosterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DutyRoster model
   */
  interface DutyRosterFieldRefs {
    readonly id: FieldRef<"DutyRoster", 'Int'>
    readonly userId: FieldRef<"DutyRoster", 'Int'>
    readonly startDate: FieldRef<"DutyRoster", 'DateTime'>
    readonly endDate: FieldRef<"DutyRoster", 'DateTime'>
    readonly shiftStart: FieldRef<"DutyRoster", 'String'>
    readonly shiftEnd: FieldRef<"DutyRoster", 'String'>
    readonly department: FieldRef<"DutyRoster", 'String'>
    readonly notes: FieldRef<"DutyRoster", 'String'>
    readonly createdAt: FieldRef<"DutyRoster", 'DateTime'>
    readonly updatedAt: FieldRef<"DutyRoster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DutyRoster findUnique
   */
  export type DutyRosterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * Filter, which DutyRoster to fetch.
     */
    where: DutyRosterWhereUniqueInput
  }

  /**
   * DutyRoster findUniqueOrThrow
   */
  export type DutyRosterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * Filter, which DutyRoster to fetch.
     */
    where: DutyRosterWhereUniqueInput
  }

  /**
   * DutyRoster findFirst
   */
  export type DutyRosterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * Filter, which DutyRoster to fetch.
     */
    where?: DutyRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRosters to fetch.
     */
    orderBy?: DutyRosterOrderByWithRelationInput | DutyRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyRosters.
     */
    cursor?: DutyRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyRosters.
     */
    distinct?: DutyRosterScalarFieldEnum | DutyRosterScalarFieldEnum[]
  }

  /**
   * DutyRoster findFirstOrThrow
   */
  export type DutyRosterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * Filter, which DutyRoster to fetch.
     */
    where?: DutyRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRosters to fetch.
     */
    orderBy?: DutyRosterOrderByWithRelationInput | DutyRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyRosters.
     */
    cursor?: DutyRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyRosters.
     */
    distinct?: DutyRosterScalarFieldEnum | DutyRosterScalarFieldEnum[]
  }

  /**
   * DutyRoster findMany
   */
  export type DutyRosterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * Filter, which DutyRosters to fetch.
     */
    where?: DutyRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyRosters to fetch.
     */
    orderBy?: DutyRosterOrderByWithRelationInput | DutyRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DutyRosters.
     */
    cursor?: DutyRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyRosters.
     */
    skip?: number
    distinct?: DutyRosterScalarFieldEnum | DutyRosterScalarFieldEnum[]
  }

  /**
   * DutyRoster create
   */
  export type DutyRosterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * The data needed to create a DutyRoster.
     */
    data: XOR<DutyRosterCreateInput, DutyRosterUncheckedCreateInput>
  }

  /**
   * DutyRoster createMany
   */
  export type DutyRosterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DutyRosters.
     */
    data: DutyRosterCreateManyInput | DutyRosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DutyRoster createManyAndReturn
   */
  export type DutyRosterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * The data used to create many DutyRosters.
     */
    data: DutyRosterCreateManyInput | DutyRosterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DutyRoster update
   */
  export type DutyRosterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * The data needed to update a DutyRoster.
     */
    data: XOR<DutyRosterUpdateInput, DutyRosterUncheckedUpdateInput>
    /**
     * Choose, which DutyRoster to update.
     */
    where: DutyRosterWhereUniqueInput
  }

  /**
   * DutyRoster updateMany
   */
  export type DutyRosterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DutyRosters.
     */
    data: XOR<DutyRosterUpdateManyMutationInput, DutyRosterUncheckedUpdateManyInput>
    /**
     * Filter which DutyRosters to update
     */
    where?: DutyRosterWhereInput
    /**
     * Limit how many DutyRosters to update.
     */
    limit?: number
  }

  /**
   * DutyRoster updateManyAndReturn
   */
  export type DutyRosterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * The data used to update DutyRosters.
     */
    data: XOR<DutyRosterUpdateManyMutationInput, DutyRosterUncheckedUpdateManyInput>
    /**
     * Filter which DutyRosters to update
     */
    where?: DutyRosterWhereInput
    /**
     * Limit how many DutyRosters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DutyRoster upsert
   */
  export type DutyRosterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * The filter to search for the DutyRoster to update in case it exists.
     */
    where: DutyRosterWhereUniqueInput
    /**
     * In case the DutyRoster found by the `where` argument doesn't exist, create a new DutyRoster with this data.
     */
    create: XOR<DutyRosterCreateInput, DutyRosterUncheckedCreateInput>
    /**
     * In case the DutyRoster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DutyRosterUpdateInput, DutyRosterUncheckedUpdateInput>
  }

  /**
   * DutyRoster delete
   */
  export type DutyRosterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
    /**
     * Filter which DutyRoster to delete.
     */
    where: DutyRosterWhereUniqueInput
  }

  /**
   * DutyRoster deleteMany
   */
  export type DutyRosterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyRosters to delete
     */
    where?: DutyRosterWhereInput
    /**
     * Limit how many DutyRosters to delete.
     */
    limit?: number
  }

  /**
   * DutyRoster without action
   */
  export type DutyRosterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyRoster
     */
    select?: DutyRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DutyRoster
     */
    omit?: DutyRosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyRosterInclude<ExtArgs> | null
  }


  /**
   * Model TPA
   */

  export type AggregateTPA = {
    _count: TPACountAggregateOutputType | null
    _avg: TPAAvgAggregateOutputType | null
    _sum: TPASumAggregateOutputType | null
    _min: TPAMinAggregateOutputType | null
    _max: TPAMaxAggregateOutputType | null
  }

  export type TPAAvgAggregateOutputType = {
    id: number | null
  }

  export type TPASumAggregateOutputType = {
    id: number | null
  }

  export type TPAMinAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    contactNumber: string | null
    email: string | null
    address: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TPAMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    contactNumber: string | null
    email: string | null
    address: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TPACountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    contactNumber: number
    email: number
    address: number
    contractStartDate: number
    contractEndDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TPAAvgAggregateInputType = {
    id?: true
  }

  export type TPASumAggregateInputType = {
    id?: true
  }

  export type TPAMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    contactNumber?: true
    email?: true
    address?: true
    contractStartDate?: true
    contractEndDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TPAMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    contactNumber?: true
    email?: true
    address?: true
    contractStartDate?: true
    contractEndDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TPACountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    contactNumber?: true
    email?: true
    address?: true
    contractStartDate?: true
    contractEndDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TPAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TPA to aggregate.
     */
    where?: TPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TPAS to fetch.
     */
    orderBy?: TPAOrderByWithRelationInput | TPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TPAS
    **/
    _count?: true | TPACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TPAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TPASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TPAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TPAMaxAggregateInputType
  }

  export type GetTPAAggregateType<T extends TPAAggregateArgs> = {
        [P in keyof T & keyof AggregateTPA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTPA[P]>
      : GetScalarType<T[P], AggregateTPA[P]>
  }




  export type TPAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TPAWhereInput
    orderBy?: TPAOrderByWithAggregationInput | TPAOrderByWithAggregationInput[]
    by: TPAScalarFieldEnum[] | TPAScalarFieldEnum
    having?: TPAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TPACountAggregateInputType | true
    _avg?: TPAAvgAggregateInputType
    _sum?: TPASumAggregateInputType
    _min?: TPAMinAggregateInputType
    _max?: TPAMaxAggregateInputType
  }

  export type TPAGroupByOutputType = {
    id: number
    name: string
    contactPerson: string | null
    contactNumber: string | null
    email: string | null
    address: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TPACountAggregateOutputType | null
    _avg: TPAAvgAggregateOutputType | null
    _sum: TPASumAggregateOutputType | null
    _min: TPAMinAggregateOutputType | null
    _max: TPAMaxAggregateOutputType | null
  }

  type GetTPAGroupByPayload<T extends TPAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TPAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TPAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TPAGroupByOutputType[P]>
            : GetScalarType<T[P], TPAGroupByOutputType[P]>
        }
      >
    >


  export type TPASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    contactNumber?: boolean
    email?: boolean
    address?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patients?: boolean | TPA$patientsArgs<ExtArgs>
    _count?: boolean | TPACountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tPA"]>

  export type TPASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    contactNumber?: boolean
    email?: boolean
    address?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tPA"]>

  export type TPASelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    contactNumber?: boolean
    email?: boolean
    address?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tPA"]>

  export type TPASelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    contactNumber?: boolean
    email?: boolean
    address?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TPAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contactPerson" | "contactNumber" | "email" | "address" | "contractStartDate" | "contractEndDate" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["tPA"]>
  export type TPAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | TPA$patientsArgs<ExtArgs>
    _count?: boolean | TPACountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TPAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TPAIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TPAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TPA"
    objects: {
      patients: Prisma.$PatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contactPerson: string | null
      contactNumber: string | null
      email: string | null
      address: string | null
      contractStartDate: Date | null
      contractEndDate: Date | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tPA"]>
    composites: {}
  }

  type TPAGetPayload<S extends boolean | null | undefined | TPADefaultArgs> = $Result.GetResult<Prisma.$TPAPayload, S>

  type TPACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TPAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TPACountAggregateInputType | true
    }

  export interface TPADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TPA'], meta: { name: 'TPA' } }
    /**
     * Find zero or one TPA that matches the filter.
     * @param {TPAFindUniqueArgs} args - Arguments to find a TPA
     * @example
     * // Get one TPA
     * const tPA = await prisma.tPA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TPAFindUniqueArgs>(args: SelectSubset<T, TPAFindUniqueArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TPA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TPAFindUniqueOrThrowArgs} args - Arguments to find a TPA
     * @example
     * // Get one TPA
     * const tPA = await prisma.tPA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TPAFindUniqueOrThrowArgs>(args: SelectSubset<T, TPAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TPA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPAFindFirstArgs} args - Arguments to find a TPA
     * @example
     * // Get one TPA
     * const tPA = await prisma.tPA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TPAFindFirstArgs>(args?: SelectSubset<T, TPAFindFirstArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TPA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPAFindFirstOrThrowArgs} args - Arguments to find a TPA
     * @example
     * // Get one TPA
     * const tPA = await prisma.tPA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TPAFindFirstOrThrowArgs>(args?: SelectSubset<T, TPAFindFirstOrThrowArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TPAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TPAS
     * const tPAS = await prisma.tPA.findMany()
     * 
     * // Get first 10 TPAS
     * const tPAS = await prisma.tPA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tPAWithIdOnly = await prisma.tPA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TPAFindManyArgs>(args?: SelectSubset<T, TPAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TPA.
     * @param {TPACreateArgs} args - Arguments to create a TPA.
     * @example
     * // Create one TPA
     * const TPA = await prisma.tPA.create({
     *   data: {
     *     // ... data to create a TPA
     *   }
     * })
     * 
     */
    create<T extends TPACreateArgs>(args: SelectSubset<T, TPACreateArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TPAS.
     * @param {TPACreateManyArgs} args - Arguments to create many TPAS.
     * @example
     * // Create many TPAS
     * const tPA = await prisma.tPA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TPACreateManyArgs>(args?: SelectSubset<T, TPACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TPAS and returns the data saved in the database.
     * @param {TPACreateManyAndReturnArgs} args - Arguments to create many TPAS.
     * @example
     * // Create many TPAS
     * const tPA = await prisma.tPA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TPAS and only return the `id`
     * const tPAWithIdOnly = await prisma.tPA.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TPACreateManyAndReturnArgs>(args?: SelectSubset<T, TPACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TPA.
     * @param {TPADeleteArgs} args - Arguments to delete one TPA.
     * @example
     * // Delete one TPA
     * const TPA = await prisma.tPA.delete({
     *   where: {
     *     // ... filter to delete one TPA
     *   }
     * })
     * 
     */
    delete<T extends TPADeleteArgs>(args: SelectSubset<T, TPADeleteArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TPA.
     * @param {TPAUpdateArgs} args - Arguments to update one TPA.
     * @example
     * // Update one TPA
     * const tPA = await prisma.tPA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TPAUpdateArgs>(args: SelectSubset<T, TPAUpdateArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TPAS.
     * @param {TPADeleteManyArgs} args - Arguments to filter TPAS to delete.
     * @example
     * // Delete a few TPAS
     * const { count } = await prisma.tPA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TPADeleteManyArgs>(args?: SelectSubset<T, TPADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TPAS
     * const tPA = await prisma.tPA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TPAUpdateManyArgs>(args: SelectSubset<T, TPAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TPAS and returns the data updated in the database.
     * @param {TPAUpdateManyAndReturnArgs} args - Arguments to update many TPAS.
     * @example
     * // Update many TPAS
     * const tPA = await prisma.tPA.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TPAS and only return the `id`
     * const tPAWithIdOnly = await prisma.tPA.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TPAUpdateManyAndReturnArgs>(args: SelectSubset<T, TPAUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TPA.
     * @param {TPAUpsertArgs} args - Arguments to update or create a TPA.
     * @example
     * // Update or create a TPA
     * const tPA = await prisma.tPA.upsert({
     *   create: {
     *     // ... data to create a TPA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TPA we want to update
     *   }
     * })
     */
    upsert<T extends TPAUpsertArgs>(args: SelectSubset<T, TPAUpsertArgs<ExtArgs>>): Prisma__TPAClient<$Result.GetResult<Prisma.$TPAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPACountArgs} args - Arguments to filter TPAS to count.
     * @example
     * // Count the number of TPAS
     * const count = await prisma.tPA.count({
     *   where: {
     *     // ... the filter for the TPAS we want to count
     *   }
     * })
    **/
    count<T extends TPACountArgs>(
      args?: Subset<T, TPACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TPACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TPAAggregateArgs>(args: Subset<T, TPAAggregateArgs>): Prisma.PrismaPromise<GetTPAAggregateType<T>>

    /**
     * Group by TPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TPAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TPAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TPAGroupByArgs['orderBy'] }
        : { orderBy?: TPAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TPAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTPAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TPA model
   */
  readonly fields: TPAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TPA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TPAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends TPA$patientsArgs<ExtArgs> = {}>(args?: Subset<T, TPA$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TPA model
   */
  interface TPAFieldRefs {
    readonly id: FieldRef<"TPA", 'Int'>
    readonly name: FieldRef<"TPA", 'String'>
    readonly contactPerson: FieldRef<"TPA", 'String'>
    readonly contactNumber: FieldRef<"TPA", 'String'>
    readonly email: FieldRef<"TPA", 'String'>
    readonly address: FieldRef<"TPA", 'String'>
    readonly contractStartDate: FieldRef<"TPA", 'DateTime'>
    readonly contractEndDate: FieldRef<"TPA", 'DateTime'>
    readonly status: FieldRef<"TPA", 'String'>
    readonly notes: FieldRef<"TPA", 'String'>
    readonly createdAt: FieldRef<"TPA", 'DateTime'>
    readonly updatedAt: FieldRef<"TPA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TPA findUnique
   */
  export type TPAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * Filter, which TPA to fetch.
     */
    where: TPAWhereUniqueInput
  }

  /**
   * TPA findUniqueOrThrow
   */
  export type TPAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * Filter, which TPA to fetch.
     */
    where: TPAWhereUniqueInput
  }

  /**
   * TPA findFirst
   */
  export type TPAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * Filter, which TPA to fetch.
     */
    where?: TPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TPAS to fetch.
     */
    orderBy?: TPAOrderByWithRelationInput | TPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TPAS.
     */
    cursor?: TPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TPAS.
     */
    distinct?: TPAScalarFieldEnum | TPAScalarFieldEnum[]
  }

  /**
   * TPA findFirstOrThrow
   */
  export type TPAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * Filter, which TPA to fetch.
     */
    where?: TPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TPAS to fetch.
     */
    orderBy?: TPAOrderByWithRelationInput | TPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TPAS.
     */
    cursor?: TPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TPAS.
     */
    distinct?: TPAScalarFieldEnum | TPAScalarFieldEnum[]
  }

  /**
   * TPA findMany
   */
  export type TPAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * Filter, which TPAS to fetch.
     */
    where?: TPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TPAS to fetch.
     */
    orderBy?: TPAOrderByWithRelationInput | TPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TPAS.
     */
    cursor?: TPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TPAS.
     */
    skip?: number
    distinct?: TPAScalarFieldEnum | TPAScalarFieldEnum[]
  }

  /**
   * TPA create
   */
  export type TPACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * The data needed to create a TPA.
     */
    data: XOR<TPACreateInput, TPAUncheckedCreateInput>
  }

  /**
   * TPA createMany
   */
  export type TPACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TPAS.
     */
    data: TPACreateManyInput | TPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TPA createManyAndReturn
   */
  export type TPACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * The data used to create many TPAS.
     */
    data: TPACreateManyInput | TPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TPA update
   */
  export type TPAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * The data needed to update a TPA.
     */
    data: XOR<TPAUpdateInput, TPAUncheckedUpdateInput>
    /**
     * Choose, which TPA to update.
     */
    where: TPAWhereUniqueInput
  }

  /**
   * TPA updateMany
   */
  export type TPAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TPAS.
     */
    data: XOR<TPAUpdateManyMutationInput, TPAUncheckedUpdateManyInput>
    /**
     * Filter which TPAS to update
     */
    where?: TPAWhereInput
    /**
     * Limit how many TPAS to update.
     */
    limit?: number
  }

  /**
   * TPA updateManyAndReturn
   */
  export type TPAUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * The data used to update TPAS.
     */
    data: XOR<TPAUpdateManyMutationInput, TPAUncheckedUpdateManyInput>
    /**
     * Filter which TPAS to update
     */
    where?: TPAWhereInput
    /**
     * Limit how many TPAS to update.
     */
    limit?: number
  }

  /**
   * TPA upsert
   */
  export type TPAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * The filter to search for the TPA to update in case it exists.
     */
    where: TPAWhereUniqueInput
    /**
     * In case the TPA found by the `where` argument doesn't exist, create a new TPA with this data.
     */
    create: XOR<TPACreateInput, TPAUncheckedCreateInput>
    /**
     * In case the TPA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TPAUpdateInput, TPAUncheckedUpdateInput>
  }

  /**
   * TPA delete
   */
  export type TPADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
    /**
     * Filter which TPA to delete.
     */
    where: TPAWhereUniqueInput
  }

  /**
   * TPA deleteMany
   */
  export type TPADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TPAS to delete
     */
    where?: TPAWhereInput
    /**
     * Limit how many TPAS to delete.
     */
    limit?: number
  }

  /**
   * TPA.patients
   */
  export type TPA$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * TPA without action
   */
  export type TPADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TPA
     */
    select?: TPASelect<ExtArgs> | null
    /**
     * Omit specific fields from the TPA
     */
    omit?: TPAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TPAInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    salary: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    salary: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    employeeId: string | null
    department: string | null
    position: string | null
    joiningDate: Date | null
    contractType: string | null
    contractEndDate: Date | null
    salary: Decimal | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    panNumber: string | null
    emergencyContact: string | null
    emergencyName: string | null
    emergencyRelation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    employeeId: string | null
    department: string | null
    position: string | null
    joiningDate: Date | null
    contractType: string | null
    contractEndDate: Date | null
    salary: Decimal | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    panNumber: string | null
    emergencyContact: string | null
    emergencyName: string | null
    emergencyRelation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    userId: number
    employeeId: number
    department: number
    position: number
    joiningDate: number
    contractType: number
    contractEndDate: number
    salary: number
    bankName: number
    accountNumber: number
    ifscCode: number
    panNumber: number
    emergencyContact: number
    emergencyName: number
    emergencyRelation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    userId?: true
    salary?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    userId?: true
    salary?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    department?: true
    position?: true
    joiningDate?: true
    contractType?: true
    contractEndDate?: true
    salary?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    panNumber?: true
    emergencyContact?: true
    emergencyName?: true
    emergencyRelation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    department?: true
    position?: true
    joiningDate?: true
    contractType?: true
    contractEndDate?: true
    salary?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    panNumber?: true
    emergencyContact?: true
    emergencyName?: true
    emergencyRelation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    department?: true
    position?: true
    joiningDate?: true
    contractType?: true
    contractEndDate?: true
    salary?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    panNumber?: true
    emergencyContact?: true
    emergencyName?: true
    emergencyRelation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date
    contractType: string
    contractEndDate: Date | null
    salary: Decimal
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    panNumber: string | null
    emergencyContact: string | null
    emergencyName: string | null
    emergencyRelation: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    joiningDate?: boolean
    contractType?: boolean
    contractEndDate?: boolean
    salary?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    salaryPayments?: boolean | Employee$salaryPaymentsArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    performanceReviews?: boolean | Employee$performanceReviewsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    joiningDate?: boolean
    contractType?: boolean
    contractEndDate?: boolean
    salary?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    joiningDate?: boolean
    contractType?: boolean
    contractEndDate?: boolean
    salary?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    joiningDate?: boolean
    contractType?: boolean
    contractEndDate?: boolean
    salary?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    emergencyContact?: boolean
    emergencyName?: boolean
    emergencyRelation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employeeId" | "department" | "position" | "joiningDate" | "contractType" | "contractEndDate" | "salary" | "bankName" | "accountNumber" | "ifscCode" | "panNumber" | "emergencyContact" | "emergencyName" | "emergencyRelation" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    salaryPayments?: boolean | Employee$salaryPaymentsArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    performanceReviews?: boolean | Employee$performanceReviewsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      salaryPayments: Prisma.$SalaryPaymentPayload<ExtArgs>[]
      documents: Prisma.$EmployeeDocumentPayload<ExtArgs>[]
      performanceReviews: Prisma.$PerformanceReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      employeeId: string
      department: string
      position: string
      joiningDate: Date
      contractType: string
      contractEndDate: Date | null
      salary: Prisma.Decimal
      bankName: string | null
      accountNumber: string | null
      ifscCode: string | null
      panNumber: string | null
      emergencyContact: string | null
      emergencyName: string | null
      emergencyRelation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryPayments<T extends Employee$salaryPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$salaryPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Employee$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceReviews<T extends Employee$performanceReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$performanceReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly userId: FieldRef<"Employee", 'Int'>
    readonly employeeId: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly joiningDate: FieldRef<"Employee", 'DateTime'>
    readonly contractType: FieldRef<"Employee", 'String'>
    readonly contractEndDate: FieldRef<"Employee", 'DateTime'>
    readonly salary: FieldRef<"Employee", 'Decimal'>
    readonly bankName: FieldRef<"Employee", 'String'>
    readonly accountNumber: FieldRef<"Employee", 'String'>
    readonly ifscCode: FieldRef<"Employee", 'String'>
    readonly panNumber: FieldRef<"Employee", 'String'>
    readonly emergencyContact: FieldRef<"Employee", 'String'>
    readonly emergencyName: FieldRef<"Employee", 'String'>
    readonly emergencyRelation: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Employee.salaryPayments
   */
  export type Employee$salaryPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    cursor?: SalaryPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * Employee.documents
   */
  export type Employee$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    where?: EmployeeDocumentWhereInput
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    cursor?: EmployeeDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * Employee.performanceReviews
   */
  export type Employee$performanceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    cursor?: PerformanceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    totalDays: number | null
    approvedBy: number | null
  }

  export type LeaveSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    totalDays: number | null
    approvedBy: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    totalDays: number | null
    reason: string | null
    status: string | null
    approvedBy: number | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    totalDays: number | null
    reason: string | null
    status: string | null
    approvedBy: number | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    startDate: number
    endDate: number
    totalDays: number
    reason: number
    status: number
    approvedBy: number
    approvedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    id?: true
    employeeId?: true
    totalDays?: true
    approvedBy?: true
  }

  export type LeaveSumAggregateInputType = {
    id?: true
    employeeId?: true
    totalDays?: true
    approvedBy?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: number
    employeeId: number
    leaveType: string
    startDate: Date
    endDate: Date
    totalDays: number
    reason: string | null
    status: string
    approvedBy: number | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "leaveType" | "startDate" | "endDate" | "totalDays" | "reason" | "status" | "approvedBy" | "approvedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      leaveType: string
      startDate: Date
      endDate: Date
      totalDays: number
      reason: string | null
      status: string
      approvedBy: number | null
      approvedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaves and returns the data saved in the database.
     * @param {LeaveCreateManyAndReturnArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves and returns the data updated in the database.
     * @param {LeaveUpdateManyAndReturnArgs} args - Arguments to update many Leaves.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'Int'>
    readonly employeeId: FieldRef<"Leave", 'Int'>
    readonly leaveType: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly totalDays: FieldRef<"Leave", 'Int'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly status: FieldRef<"Leave", 'String'>
    readonly approvedBy: FieldRef<"Leave", 'Int'>
    readonly approvedAt: FieldRef<"Leave", 'DateTime'>
    readonly notes: FieldRef<"Leave", 'String'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave createManyAndReturn
   */
  export type LeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave updateManyAndReturn
   */
  export type LeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPayment
   */

  export type AggregateSalaryPayment = {
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  export type SalaryPaymentAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    basicSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    taxDeducted: Decimal | null
    netSalary: Decimal | null
  }

  export type SalaryPaymentSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    basicSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    taxDeducted: Decimal | null
    netSalary: Decimal | null
  }

  export type SalaryPaymentMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    paymentDate: Date | null
    salaryMonth: string | null
    basicSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    taxDeducted: Decimal | null
    netSalary: Decimal | null
    paymentMethod: string | null
    transactionId: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryPaymentMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    paymentDate: Date | null
    salaryMonth: string | null
    basicSalary: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    taxDeducted: Decimal | null
    netSalary: Decimal | null
    paymentMethod: string | null
    transactionId: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryPaymentCountAggregateOutputType = {
    id: number
    employeeId: number
    paymentDate: number
    salaryMonth: number
    basicSalary: number
    allowances: number
    deductions: number
    taxDeducted: number
    netSalary: number
    paymentMethod: number
    transactionId: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryPaymentAvgAggregateInputType = {
    id?: true
    employeeId?: true
    basicSalary?: true
    allowances?: true
    deductions?: true
    taxDeducted?: true
    netSalary?: true
  }

  export type SalaryPaymentSumAggregateInputType = {
    id?: true
    employeeId?: true
    basicSalary?: true
    allowances?: true
    deductions?: true
    taxDeducted?: true
    netSalary?: true
  }

  export type SalaryPaymentMinAggregateInputType = {
    id?: true
    employeeId?: true
    paymentDate?: true
    salaryMonth?: true
    basicSalary?: true
    allowances?: true
    deductions?: true
    taxDeducted?: true
    netSalary?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryPaymentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    paymentDate?: true
    salaryMonth?: true
    basicSalary?: true
    allowances?: true
    deductions?: true
    taxDeducted?: true
    netSalary?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryPaymentCountAggregateInputType = {
    id?: true
    employeeId?: true
    paymentDate?: true
    salaryMonth?: true
    basicSalary?: true
    allowances?: true
    deductions?: true
    taxDeducted?: true
    netSalary?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayment to aggregate.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPayments
    **/
    _count?: true | SalaryPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type GetSalaryPaymentAggregateType<T extends SalaryPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPayment[P]>
      : GetScalarType<T[P], AggregateSalaryPayment[P]>
  }




  export type SalaryPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithAggregationInput | SalaryPaymentOrderByWithAggregationInput[]
    by: SalaryPaymentScalarFieldEnum[] | SalaryPaymentScalarFieldEnum
    having?: SalaryPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPaymentCountAggregateInputType | true
    _avg?: SalaryPaymentAvgAggregateInputType
    _sum?: SalaryPaymentSumAggregateInputType
    _min?: SalaryPaymentMinAggregateInputType
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type SalaryPaymentGroupByOutputType = {
    id: number
    employeeId: number
    paymentDate: Date
    salaryMonth: string
    basicSalary: Decimal
    allowances: Decimal
    deductions: Decimal
    taxDeducted: Decimal
    netSalary: Decimal
    paymentMethod: string
    transactionId: string | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  type GetSalaryPaymentGroupByPayload<T extends SalaryPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    salaryMonth?: boolean
    basicSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    taxDeducted?: boolean
    netSalary?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    salaryMonth?: boolean
    basicSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    taxDeducted?: boolean
    netSalary?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    salaryMonth?: boolean
    basicSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    taxDeducted?: boolean
    netSalary?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    salaryMonth?: boolean
    basicSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    taxDeducted?: boolean
    netSalary?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "paymentDate" | "salaryMonth" | "basicSalary" | "allowances" | "deductions" | "taxDeducted" | "netSalary" | "paymentMethod" | "transactionId" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["salaryPayment"]>
  export type SalaryPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $SalaryPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPayment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      paymentDate: Date
      salaryMonth: string
      basicSalary: Prisma.Decimal
      allowances: Prisma.Decimal
      deductions: Prisma.Decimal
      taxDeducted: Prisma.Decimal
      netSalary: Prisma.Decimal
      paymentMethod: string
      transactionId: string | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salaryPayment"]>
    composites: {}
  }

  type SalaryPaymentGetPayload<S extends boolean | null | undefined | SalaryPaymentDefaultArgs> = $Result.GetResult<Prisma.$SalaryPaymentPayload, S>

  type SalaryPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryPaymentCountAggregateInputType | true
    }

  export interface SalaryPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPayment'], meta: { name: 'SalaryPayment' } }
    /**
     * Find zero or one SalaryPayment that matches the filter.
     * @param {SalaryPaymentFindUniqueArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPaymentFindUniqueArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryPaymentFindUniqueOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPaymentFindFirstArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany()
     * 
     * // Get first 10 SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryPaymentFindManyArgs>(args?: SelectSubset<T, SalaryPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryPayment.
     * @param {SalaryPaymentCreateArgs} args - Arguments to create a SalaryPayment.
     * @example
     * // Create one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.create({
     *   data: {
     *     // ... data to create a SalaryPayment
     *   }
     * })
     * 
     */
    create<T extends SalaryPaymentCreateArgs>(args: SelectSubset<T, SalaryPaymentCreateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryPayments.
     * @param {SalaryPaymentCreateManyArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPaymentCreateManyArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPayments and returns the data saved in the database.
     * @param {SalaryPaymentCreateManyAndReturnArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPayments and only return the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryPayment.
     * @param {SalaryPaymentDeleteArgs} args - Arguments to delete one SalaryPayment.
     * @example
     * // Delete one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.delete({
     *   where: {
     *     // ... filter to delete one SalaryPayment
     *   }
     * })
     * 
     */
    delete<T extends SalaryPaymentDeleteArgs>(args: SelectSubset<T, SalaryPaymentDeleteArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryPayment.
     * @param {SalaryPaymentUpdateArgs} args - Arguments to update one SalaryPayment.
     * @example
     * // Update one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPaymentUpdateArgs>(args: SelectSubset<T, SalaryPaymentUpdateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryPayments.
     * @param {SalaryPaymentDeleteManyArgs} args - Arguments to filter SalaryPayments to delete.
     * @example
     * // Delete a few SalaryPayments
     * const { count } = await prisma.salaryPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPaymentDeleteManyArgs>(args?: SelectSubset<T, SalaryPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPaymentUpdateManyArgs>(args: SelectSubset<T, SalaryPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments and returns the data updated in the database.
     * @param {SalaryPaymentUpdateManyAndReturnArgs} args - Arguments to update many SalaryPayments.
     * @example
     * // Update many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryPayments and only return the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryPayment.
     * @param {SalaryPaymentUpsertArgs} args - Arguments to update or create a SalaryPayment.
     * @example
     * // Update or create a SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.upsert({
     *   create: {
     *     // ... data to create a SalaryPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPayment we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPaymentUpsertArgs>(args: SelectSubset<T, SalaryPaymentUpsertArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentCountArgs} args - Arguments to filter SalaryPayments to count.
     * @example
     * // Count the number of SalaryPayments
     * const count = await prisma.salaryPayment.count({
     *   where: {
     *     // ... the filter for the SalaryPayments we want to count
     *   }
     * })
    **/
    count<T extends SalaryPaymentCountArgs>(
      args?: Subset<T, SalaryPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPaymentAggregateArgs>(args: Subset<T, SalaryPaymentAggregateArgs>): Prisma.PrismaPromise<GetSalaryPaymentAggregateType<T>>

    /**
     * Group by SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPayment model
   */
  readonly fields: SalaryPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPayment model
   */
  interface SalaryPaymentFieldRefs {
    readonly id: FieldRef<"SalaryPayment", 'Int'>
    readonly employeeId: FieldRef<"SalaryPayment", 'Int'>
    readonly paymentDate: FieldRef<"SalaryPayment", 'DateTime'>
    readonly salaryMonth: FieldRef<"SalaryPayment", 'String'>
    readonly basicSalary: FieldRef<"SalaryPayment", 'Decimal'>
    readonly allowances: FieldRef<"SalaryPayment", 'Decimal'>
    readonly deductions: FieldRef<"SalaryPayment", 'Decimal'>
    readonly taxDeducted: FieldRef<"SalaryPayment", 'Decimal'>
    readonly netSalary: FieldRef<"SalaryPayment", 'Decimal'>
    readonly paymentMethod: FieldRef<"SalaryPayment", 'String'>
    readonly transactionId: FieldRef<"SalaryPayment", 'String'>
    readonly status: FieldRef<"SalaryPayment", 'String'>
    readonly notes: FieldRef<"SalaryPayment", 'String'>
    readonly createdAt: FieldRef<"SalaryPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPayment findUnique
   */
  export type SalaryPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findUniqueOrThrow
   */
  export type SalaryPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findFirst
   */
  export type SalaryPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findFirstOrThrow
   */
  export type SalaryPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findMany
   */
  export type SalaryPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment create
   */
  export type SalaryPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPayment.
     */
    data: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
  }

  /**
   * SalaryPayment createMany
   */
  export type SalaryPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryPayment createManyAndReturn
   */
  export type SalaryPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayment update
   */
  export type SalaryPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPayment.
     */
    data: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
    /**
     * Choose, which SalaryPayment to update.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment updateMany
   */
  export type SalaryPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
  }

  /**
   * SalaryPayment updateManyAndReturn
   */
  export type SalaryPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayment upsert
   */
  export type SalaryPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPayment to update in case it exists.
     */
    where: SalaryPaymentWhereUniqueInput
    /**
     * In case the SalaryPayment found by the `where` argument doesn't exist, create a new SalaryPayment with this data.
     */
    create: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
    /**
     * In case the SalaryPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
  }

  /**
   * SalaryPayment delete
   */
  export type SalaryPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter which SalaryPayment to delete.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment deleteMany
   */
  export type SalaryPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to delete
     */
    where?: SalaryPaymentWhereInput
    /**
     * Limit how many SalaryPayments to delete.
     */
    limit?: number
  }

  /**
   * SalaryPayment without action
   */
  export type SalaryPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayment
     */
    omit?: SalaryPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeDocument
   */

  export type AggregateEmployeeDocument = {
    _count: EmployeeDocumentCountAggregateOutputType | null
    _avg: EmployeeDocumentAvgAggregateOutputType | null
    _sum: EmployeeDocumentSumAggregateOutputType | null
    _min: EmployeeDocumentMinAggregateOutputType | null
    _max: EmployeeDocumentMaxAggregateOutputType | null
  }

  export type EmployeeDocumentAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    verifiedBy: number | null
  }

  export type EmployeeDocumentSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    verifiedBy: number | null
  }

  export type EmployeeDocumentMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    documentType: string | null
    documentName: string | null
    documentUrl: string | null
    isVerified: boolean | null
    verifiedBy: number | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeDocumentMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    documentType: string | null
    documentName: string | null
    documentUrl: string | null
    isVerified: boolean | null
    verifiedBy: number | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeDocumentCountAggregateOutputType = {
    id: number
    employeeId: number
    documentType: number
    documentName: number
    documentUrl: number
    isVerified: number
    verifiedBy: number
    verifiedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeDocumentAvgAggregateInputType = {
    id?: true
    employeeId?: true
    verifiedBy?: true
  }

  export type EmployeeDocumentSumAggregateInputType = {
    id?: true
    employeeId?: true
    verifiedBy?: true
  }

  export type EmployeeDocumentMinAggregateInputType = {
    id?: true
    employeeId?: true
    documentType?: true
    documentName?: true
    documentUrl?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeDocumentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    documentType?: true
    documentName?: true
    documentUrl?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeDocumentCountAggregateInputType = {
    id?: true
    employeeId?: true
    documentType?: true
    documentName?: true
    documentUrl?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeDocument to aggregate.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeDocuments
    **/
    _count?: true | EmployeeDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeDocumentMaxAggregateInputType
  }

  export type GetEmployeeDocumentAggregateType<T extends EmployeeDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeDocument[P]>
      : GetScalarType<T[P], AggregateEmployeeDocument[P]>
  }




  export type EmployeeDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeDocumentWhereInput
    orderBy?: EmployeeDocumentOrderByWithAggregationInput | EmployeeDocumentOrderByWithAggregationInput[]
    by: EmployeeDocumentScalarFieldEnum[] | EmployeeDocumentScalarFieldEnum
    having?: EmployeeDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeDocumentCountAggregateInputType | true
    _avg?: EmployeeDocumentAvgAggregateInputType
    _sum?: EmployeeDocumentSumAggregateInputType
    _min?: EmployeeDocumentMinAggregateInputType
    _max?: EmployeeDocumentMaxAggregateInputType
  }

  export type EmployeeDocumentGroupByOutputType = {
    id: number
    employeeId: number
    documentType: string
    documentName: string
    documentUrl: string
    isVerified: boolean
    verifiedBy: number | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeDocumentCountAggregateOutputType | null
    _avg: EmployeeDocumentAvgAggregateOutputType | null
    _sum: EmployeeDocumentSumAggregateOutputType | null
    _min: EmployeeDocumentMinAggregateOutputType | null
    _max: EmployeeDocumentMaxAggregateOutputType | null
  }

  type GetEmployeeDocumentGroupByPayload<T extends EmployeeDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeDocumentGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    documentType?: boolean
    documentName?: boolean
    documentUrl?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDocument"]>

  export type EmployeeDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    documentType?: boolean
    documentName?: boolean
    documentUrl?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDocument"]>

  export type EmployeeDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    documentType?: boolean
    documentName?: boolean
    documentUrl?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDocument"]>

  export type EmployeeDocumentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    documentType?: boolean
    documentName?: boolean
    documentUrl?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "documentType" | "documentName" | "documentUrl" | "isVerified" | "verifiedBy" | "verifiedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeDocument"]>
  export type EmployeeDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EmployeeDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeDocument"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      documentType: string
      documentName: string
      documentUrl: string
      isVerified: boolean
      verifiedBy: number | null
      verifiedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeDocument"]>
    composites: {}
  }

  type EmployeeDocumentGetPayload<S extends boolean | null | undefined | EmployeeDocumentDefaultArgs> = $Result.GetResult<Prisma.$EmployeeDocumentPayload, S>

  type EmployeeDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeDocumentCountAggregateInputType | true
    }

  export interface EmployeeDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeDocument'], meta: { name: 'EmployeeDocument' } }
    /**
     * Find zero or one EmployeeDocument that matches the filter.
     * @param {EmployeeDocumentFindUniqueArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeDocumentFindUniqueArgs>(args: SelectSubset<T, EmployeeDocumentFindUniqueArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeDocumentFindUniqueOrThrowArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentFindFirstArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeDocumentFindFirstArgs>(args?: SelectSubset<T, EmployeeDocumentFindFirstArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentFindFirstOrThrowArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeDocuments
     * const employeeDocuments = await prisma.employeeDocument.findMany()
     * 
     * // Get first 10 EmployeeDocuments
     * const employeeDocuments = await prisma.employeeDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeDocumentWithIdOnly = await prisma.employeeDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeDocumentFindManyArgs>(args?: SelectSubset<T, EmployeeDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeDocument.
     * @param {EmployeeDocumentCreateArgs} args - Arguments to create a EmployeeDocument.
     * @example
     * // Create one EmployeeDocument
     * const EmployeeDocument = await prisma.employeeDocument.create({
     *   data: {
     *     // ... data to create a EmployeeDocument
     *   }
     * })
     * 
     */
    create<T extends EmployeeDocumentCreateArgs>(args: SelectSubset<T, EmployeeDocumentCreateArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeDocuments.
     * @param {EmployeeDocumentCreateManyArgs} args - Arguments to create many EmployeeDocuments.
     * @example
     * // Create many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeDocumentCreateManyArgs>(args?: SelectSubset<T, EmployeeDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeDocuments and returns the data saved in the database.
     * @param {EmployeeDocumentCreateManyAndReturnArgs} args - Arguments to create many EmployeeDocuments.
     * @example
     * // Create many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeDocuments and only return the `id`
     * const employeeDocumentWithIdOnly = await prisma.employeeDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeDocument.
     * @param {EmployeeDocumentDeleteArgs} args - Arguments to delete one EmployeeDocument.
     * @example
     * // Delete one EmployeeDocument
     * const EmployeeDocument = await prisma.employeeDocument.delete({
     *   where: {
     *     // ... filter to delete one EmployeeDocument
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDocumentDeleteArgs>(args: SelectSubset<T, EmployeeDocumentDeleteArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeDocument.
     * @param {EmployeeDocumentUpdateArgs} args - Arguments to update one EmployeeDocument.
     * @example
     * // Update one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeDocumentUpdateArgs>(args: SelectSubset<T, EmployeeDocumentUpdateArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeDocuments.
     * @param {EmployeeDocumentDeleteManyArgs} args - Arguments to filter EmployeeDocuments to delete.
     * @example
     * // Delete a few EmployeeDocuments
     * const { count } = await prisma.employeeDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDocumentDeleteManyArgs>(args?: SelectSubset<T, EmployeeDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeDocumentUpdateManyArgs>(args: SelectSubset<T, EmployeeDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeDocuments and returns the data updated in the database.
     * @param {EmployeeDocumentUpdateManyAndReturnArgs} args - Arguments to update many EmployeeDocuments.
     * @example
     * // Update many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeDocuments and only return the `id`
     * const employeeDocumentWithIdOnly = await prisma.employeeDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeDocument.
     * @param {EmployeeDocumentUpsertArgs} args - Arguments to update or create a EmployeeDocument.
     * @example
     * // Update or create a EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.upsert({
     *   create: {
     *     // ... data to create a EmployeeDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeDocument we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeDocumentUpsertArgs>(args: SelectSubset<T, EmployeeDocumentUpsertArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentCountArgs} args - Arguments to filter EmployeeDocuments to count.
     * @example
     * // Count the number of EmployeeDocuments
     * const count = await prisma.employeeDocument.count({
     *   where: {
     *     // ... the filter for the EmployeeDocuments we want to count
     *   }
     * })
    **/
    count<T extends EmployeeDocumentCountArgs>(
      args?: Subset<T, EmployeeDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeDocumentAggregateArgs>(args: Subset<T, EmployeeDocumentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeDocumentAggregateType<T>>

    /**
     * Group by EmployeeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeDocumentGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeDocument model
   */
  readonly fields: EmployeeDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeDocument model
   */
  interface EmployeeDocumentFieldRefs {
    readonly id: FieldRef<"EmployeeDocument", 'Int'>
    readonly employeeId: FieldRef<"EmployeeDocument", 'Int'>
    readonly documentType: FieldRef<"EmployeeDocument", 'String'>
    readonly documentName: FieldRef<"EmployeeDocument", 'String'>
    readonly documentUrl: FieldRef<"EmployeeDocument", 'String'>
    readonly isVerified: FieldRef<"EmployeeDocument", 'Boolean'>
    readonly verifiedBy: FieldRef<"EmployeeDocument", 'Int'>
    readonly verifiedAt: FieldRef<"EmployeeDocument", 'DateTime'>
    readonly notes: FieldRef<"EmployeeDocument", 'String'>
    readonly createdAt: FieldRef<"EmployeeDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeDocument findUnique
   */
  export type EmployeeDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument findUniqueOrThrow
   */
  export type EmployeeDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument findFirst
   */
  export type EmployeeDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeDocuments.
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeDocuments.
     */
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * EmployeeDocument findFirstOrThrow
   */
  export type EmployeeDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeDocuments.
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeDocuments.
     */
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * EmployeeDocument findMany
   */
  export type EmployeeDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocuments to fetch.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeDocuments.
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * EmployeeDocument create
   */
  export type EmployeeDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeDocument.
     */
    data: XOR<EmployeeDocumentCreateInput, EmployeeDocumentUncheckedCreateInput>
  }

  /**
   * EmployeeDocument createMany
   */
  export type EmployeeDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeDocuments.
     */
    data: EmployeeDocumentCreateManyInput | EmployeeDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeDocument createManyAndReturn
   */
  export type EmployeeDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeDocuments.
     */
    data: EmployeeDocumentCreateManyInput | EmployeeDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeDocument update
   */
  export type EmployeeDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeDocument.
     */
    data: XOR<EmployeeDocumentUpdateInput, EmployeeDocumentUncheckedUpdateInput>
    /**
     * Choose, which EmployeeDocument to update.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument updateMany
   */
  export type EmployeeDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeDocuments.
     */
    data: XOR<EmployeeDocumentUpdateManyMutationInput, EmployeeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeDocuments to update
     */
    where?: EmployeeDocumentWhereInput
    /**
     * Limit how many EmployeeDocuments to update.
     */
    limit?: number
  }

  /**
   * EmployeeDocument updateManyAndReturn
   */
  export type EmployeeDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeDocuments.
     */
    data: XOR<EmployeeDocumentUpdateManyMutationInput, EmployeeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeDocuments to update
     */
    where?: EmployeeDocumentWhereInput
    /**
     * Limit how many EmployeeDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeDocument upsert
   */
  export type EmployeeDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeDocument to update in case it exists.
     */
    where: EmployeeDocumentWhereUniqueInput
    /**
     * In case the EmployeeDocument found by the `where` argument doesn't exist, create a new EmployeeDocument with this data.
     */
    create: XOR<EmployeeDocumentCreateInput, EmployeeDocumentUncheckedCreateInput>
    /**
     * In case the EmployeeDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeDocumentUpdateInput, EmployeeDocumentUncheckedUpdateInput>
  }

  /**
   * EmployeeDocument delete
   */
  export type EmployeeDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter which EmployeeDocument to delete.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument deleteMany
   */
  export type EmployeeDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeDocuments to delete
     */
    where?: EmployeeDocumentWhereInput
    /**
     * Limit how many EmployeeDocuments to delete.
     */
    limit?: number
  }

  /**
   * EmployeeDocument without action
   */
  export type EmployeeDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceReview
   */

  export type AggregatePerformanceReview = {
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  export type PerformanceReviewAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewedBy: number | null
    rating: number | null
  }

  export type PerformanceReviewSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewedBy: number | null
    rating: number | null
  }

  export type PerformanceReviewMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewDate: Date | null
    reviewPeriodStart: Date | null
    reviewPeriodEnd: Date | null
    reviewedBy: number | null
    rating: number | null
    strengths: string | null
    areasOfImprovement: string | null
    goals: string | null
    comments: string | null
    employeeComments: string | null
    status: string | null
    acknowledgedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceReviewMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewDate: Date | null
    reviewPeriodStart: Date | null
    reviewPeriodEnd: Date | null
    reviewedBy: number | null
    rating: number | null
    strengths: string | null
    areasOfImprovement: string | null
    goals: string | null
    comments: string | null
    employeeComments: string | null
    status: string | null
    acknowledgedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceReviewCountAggregateOutputType = {
    id: number
    employeeId: number
    reviewDate: number
    reviewPeriodStart: number
    reviewPeriodEnd: number
    reviewedBy: number
    rating: number
    strengths: number
    areasOfImprovement: number
    goals: number
    comments: number
    employeeComments: number
    status: number
    acknowledgedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceReviewAvgAggregateInputType = {
    id?: true
    employeeId?: true
    reviewedBy?: true
    rating?: true
  }

  export type PerformanceReviewSumAggregateInputType = {
    id?: true
    employeeId?: true
    reviewedBy?: true
    rating?: true
  }

  export type PerformanceReviewMinAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewPeriodStart?: true
    reviewPeriodEnd?: true
    reviewedBy?: true
    rating?: true
    strengths?: true
    areasOfImprovement?: true
    goals?: true
    comments?: true
    employeeComments?: true
    status?: true
    acknowledgedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceReviewMaxAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewPeriodStart?: true
    reviewPeriodEnd?: true
    reviewedBy?: true
    rating?: true
    strengths?: true
    areasOfImprovement?: true
    goals?: true
    comments?: true
    employeeComments?: true
    status?: true
    acknowledgedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceReviewCountAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewPeriodStart?: true
    reviewPeriodEnd?: true
    reviewedBy?: true
    rating?: true
    strengths?: true
    areasOfImprovement?: true
    goals?: true
    comments?: true
    employeeComments?: true
    status?: true
    acknowledgedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReview to aggregate.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceReviews
    **/
    _count?: true | PerformanceReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type GetPerformanceReviewAggregateType<T extends PerformanceReviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceReview[P]>
      : GetScalarType<T[P], AggregatePerformanceReview[P]>
  }




  export type PerformanceReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithAggregationInput | PerformanceReviewOrderByWithAggregationInput[]
    by: PerformanceReviewScalarFieldEnum[] | PerformanceReviewScalarFieldEnum
    having?: PerformanceReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceReviewCountAggregateInputType | true
    _avg?: PerformanceReviewAvgAggregateInputType
    _sum?: PerformanceReviewSumAggregateInputType
    _min?: PerformanceReviewMinAggregateInputType
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type PerformanceReviewGroupByOutputType = {
    id: number
    employeeId: number
    reviewDate: Date
    reviewPeriodStart: Date
    reviewPeriodEnd: Date
    reviewedBy: number
    rating: number
    strengths: string | null
    areasOfImprovement: string | null
    goals: string | null
    comments: string | null
    employeeComments: string | null
    status: string
    acknowledgedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  type GetPerformanceReviewGroupByPayload<T extends PerformanceReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    reviewedBy?: boolean
    rating?: boolean
    strengths?: boolean
    areasOfImprovement?: boolean
    goals?: boolean
    comments?: boolean
    employeeComments?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>

  export type PerformanceReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    reviewedBy?: boolean
    rating?: boolean
    strengths?: boolean
    areasOfImprovement?: boolean
    goals?: boolean
    comments?: boolean
    employeeComments?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>

  export type PerformanceReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    reviewedBy?: boolean
    rating?: boolean
    strengths?: boolean
    areasOfImprovement?: boolean
    goals?: boolean
    comments?: boolean
    employeeComments?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>

  export type PerformanceReviewSelectScalar = {
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    reviewedBy?: boolean
    rating?: boolean
    strengths?: boolean
    areasOfImprovement?: boolean
    goals?: boolean
    comments?: boolean
    employeeComments?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "reviewDate" | "reviewPeriodStart" | "reviewPeriodEnd" | "reviewedBy" | "rating" | "strengths" | "areasOfImprovement" | "goals" | "comments" | "employeeComments" | "status" | "acknowledgedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["performanceReview"]>
  export type PerformanceReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PerformanceReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PerformanceReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PerformanceReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceReview"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      reviewDate: Date
      reviewPeriodStart: Date
      reviewPeriodEnd: Date
      reviewedBy: number
      rating: number
      strengths: string | null
      areasOfImprovement: string | null
      goals: string | null
      comments: string | null
      employeeComments: string | null
      status: string
      acknowledgedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performanceReview"]>
    composites: {}
  }

  type PerformanceReviewGetPayload<S extends boolean | null | undefined | PerformanceReviewDefaultArgs> = $Result.GetResult<Prisma.$PerformanceReviewPayload, S>

  type PerformanceReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceReviewCountAggregateInputType | true
    }

  export interface PerformanceReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceReview'], meta: { name: 'PerformanceReview' } }
    /**
     * Find zero or one PerformanceReview that matches the filter.
     * @param {PerformanceReviewFindUniqueArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceReviewFindUniqueArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceReviewFindUniqueOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceReviewFindFirstArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany()
     * 
     * // Get first 10 PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceReviewFindManyArgs>(args?: SelectSubset<T, PerformanceReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceReview.
     * @param {PerformanceReviewCreateArgs} args - Arguments to create a PerformanceReview.
     * @example
     * // Create one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.create({
     *   data: {
     *     // ... data to create a PerformanceReview
     *   }
     * })
     * 
     */
    create<T extends PerformanceReviewCreateArgs>(args: SelectSubset<T, PerformanceReviewCreateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceReviews.
     * @param {PerformanceReviewCreateManyArgs} args - Arguments to create many PerformanceReviews.
     * @example
     * // Create many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceReviewCreateManyArgs>(args?: SelectSubset<T, PerformanceReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceReviews and returns the data saved in the database.
     * @param {PerformanceReviewCreateManyAndReturnArgs} args - Arguments to create many PerformanceReviews.
     * @example
     * // Create many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceReviews and only return the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceReview.
     * @param {PerformanceReviewDeleteArgs} args - Arguments to delete one PerformanceReview.
     * @example
     * // Delete one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.delete({
     *   where: {
     *     // ... filter to delete one PerformanceReview
     *   }
     * })
     * 
     */
    delete<T extends PerformanceReviewDeleteArgs>(args: SelectSubset<T, PerformanceReviewDeleteArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceReview.
     * @param {PerformanceReviewUpdateArgs} args - Arguments to update one PerformanceReview.
     * @example
     * // Update one PerformanceReview
     * const performanceReview = await prisma.performanceReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceReviewUpdateArgs>(args: SelectSubset<T, PerformanceReviewUpdateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceReviews.
     * @param {PerformanceReviewDeleteManyArgs} args - Arguments to filter PerformanceReviews to delete.
     * @example
     * // Delete a few PerformanceReviews
     * const { count } = await prisma.performanceReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceReviewDeleteManyArgs>(args?: SelectSubset<T, PerformanceReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceReviewUpdateManyArgs>(args: SelectSubset<T, PerformanceReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReviews and returns the data updated in the database.
     * @param {PerformanceReviewUpdateManyAndReturnArgs} args - Arguments to update many PerformanceReviews.
     * @example
     * // Update many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceReviews and only return the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceReview.
     * @param {PerformanceReviewUpsertArgs} args - Arguments to update or create a PerformanceReview.
     * @example
     * // Update or create a PerformanceReview
     * const performanceReview = await prisma.performanceReview.upsert({
     *   create: {
     *     // ... data to create a PerformanceReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceReview we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceReviewUpsertArgs>(args: SelectSubset<T, PerformanceReviewUpsertArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewCountArgs} args - Arguments to filter PerformanceReviews to count.
     * @example
     * // Count the number of PerformanceReviews
     * const count = await prisma.performanceReview.count({
     *   where: {
     *     // ... the filter for the PerformanceReviews we want to count
     *   }
     * })
    **/
    count<T extends PerformanceReviewCountArgs>(
      args?: Subset<T, PerformanceReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceReviewAggregateArgs>(args: Subset<T, PerformanceReviewAggregateArgs>): Prisma.PrismaPromise<GetPerformanceReviewAggregateType<T>>

    /**
     * Group by PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceReviewGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceReview model
   */
  readonly fields: PerformanceReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceReview model
   */
  interface PerformanceReviewFieldRefs {
    readonly id: FieldRef<"PerformanceReview", 'Int'>
    readonly employeeId: FieldRef<"PerformanceReview", 'Int'>
    readonly reviewDate: FieldRef<"PerformanceReview", 'DateTime'>
    readonly reviewPeriodStart: FieldRef<"PerformanceReview", 'DateTime'>
    readonly reviewPeriodEnd: FieldRef<"PerformanceReview", 'DateTime'>
    readonly reviewedBy: FieldRef<"PerformanceReview", 'Int'>
    readonly rating: FieldRef<"PerformanceReview", 'Int'>
    readonly strengths: FieldRef<"PerformanceReview", 'String'>
    readonly areasOfImprovement: FieldRef<"PerformanceReview", 'String'>
    readonly goals: FieldRef<"PerformanceReview", 'String'>
    readonly comments: FieldRef<"PerformanceReview", 'String'>
    readonly employeeComments: FieldRef<"PerformanceReview", 'String'>
    readonly status: FieldRef<"PerformanceReview", 'String'>
    readonly acknowledgedAt: FieldRef<"PerformanceReview", 'DateTime'>
    readonly createdAt: FieldRef<"PerformanceReview", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceReview findUnique
   */
  export type PerformanceReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findUniqueOrThrow
   */
  export type PerformanceReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findFirst
   */
  export type PerformanceReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findFirstOrThrow
   */
  export type PerformanceReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findMany
   */
  export type PerformanceReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReviews to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview create
   */
  export type PerformanceReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceReview.
     */
    data: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
  }

  /**
   * PerformanceReview createMany
   */
  export type PerformanceReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceReviews.
     */
    data: PerformanceReviewCreateManyInput | PerformanceReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceReview createManyAndReturn
   */
  export type PerformanceReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceReviews.
     */
    data: PerformanceReviewCreateManyInput | PerformanceReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceReview update
   */
  export type PerformanceReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceReview.
     */
    data: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
    /**
     * Choose, which PerformanceReview to update.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview updateMany
   */
  export type PerformanceReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceReviews.
     */
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReviews to update
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to update.
     */
    limit?: number
  }

  /**
   * PerformanceReview updateManyAndReturn
   */
  export type PerformanceReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceReviews.
     */
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReviews to update
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceReview upsert
   */
  export type PerformanceReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceReview to update in case it exists.
     */
    where: PerformanceReviewWhereUniqueInput
    /**
     * In case the PerformanceReview found by the `where` argument doesn't exist, create a new PerformanceReview with this data.
     */
    create: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
    /**
     * In case the PerformanceReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
  }

  /**
   * PerformanceReview delete
   */
  export type PerformanceReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter which PerformanceReview to delete.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview deleteMany
   */
  export type PerformanceReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReviews to delete
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to delete.
     */
    limit?: number
  }

  /**
   * PerformanceReview without action
   */
  export type PerformanceReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
  }


  /**
   * Model SubsidyScheme
   */

  export type AggregateSubsidyScheme = {
    _count: SubsidySchemeCountAggregateOutputType | null
    _avg: SubsidySchemeAvgAggregateOutputType | null
    _sum: SubsidySchemeSumAggregateOutputType | null
    _min: SubsidySchemeMinAggregateOutputType | null
    _max: SubsidySchemeMaxAggregateOutputType | null
  }

  export type SubsidySchemeAvgAggregateOutputType = {
    id: number | null
    percentageValue: number | null
    fixedAmount: Decimal | null
    maxCoverageAmount: Decimal | null
    maxCoveragePerTreatment: Decimal | null
  }

  export type SubsidySchemeSumAggregateOutputType = {
    id: number | null
    percentageValue: number | null
    fixedAmount: Decimal | null
    maxCoverageAmount: Decimal | null
    maxCoveragePerTreatment: Decimal | null
  }

  export type SubsidySchemeMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    issuingAuthority: string | null
    startDate: Date | null
    endDate: Date | null
    eligibilityCriteria: string | null
    subsidyType: string | null
    percentageValue: number | null
    fixedAmount: Decimal | null
    maxCoverageAmount: Decimal | null
    maxCoveragePerTreatment: Decimal | null
    applicableServices: string | null
    documentationRequired: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubsidySchemeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    issuingAuthority: string | null
    startDate: Date | null
    endDate: Date | null
    eligibilityCriteria: string | null
    subsidyType: string | null
    percentageValue: number | null
    fixedAmount: Decimal | null
    maxCoverageAmount: Decimal | null
    maxCoveragePerTreatment: Decimal | null
    applicableServices: string | null
    documentationRequired: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubsidySchemeCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    issuingAuthority: number
    startDate: number
    endDate: number
    eligibilityCriteria: number
    subsidyType: number
    percentageValue: number
    fixedAmount: number
    maxCoverageAmount: number
    maxCoveragePerTreatment: number
    applicableServices: number
    documentationRequired: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubsidySchemeAvgAggregateInputType = {
    id?: true
    percentageValue?: true
    fixedAmount?: true
    maxCoverageAmount?: true
    maxCoveragePerTreatment?: true
  }

  export type SubsidySchemeSumAggregateInputType = {
    id?: true
    percentageValue?: true
    fixedAmount?: true
    maxCoverageAmount?: true
    maxCoveragePerTreatment?: true
  }

  export type SubsidySchemeMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    issuingAuthority?: true
    startDate?: true
    endDate?: true
    eligibilityCriteria?: true
    subsidyType?: true
    percentageValue?: true
    fixedAmount?: true
    maxCoverageAmount?: true
    maxCoveragePerTreatment?: true
    applicableServices?: true
    documentationRequired?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubsidySchemeMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    issuingAuthority?: true
    startDate?: true
    endDate?: true
    eligibilityCriteria?: true
    subsidyType?: true
    percentageValue?: true
    fixedAmount?: true
    maxCoverageAmount?: true
    maxCoveragePerTreatment?: true
    applicableServices?: true
    documentationRequired?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubsidySchemeCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    issuingAuthority?: true
    startDate?: true
    endDate?: true
    eligibilityCriteria?: true
    subsidyType?: true
    percentageValue?: true
    fixedAmount?: true
    maxCoverageAmount?: true
    maxCoveragePerTreatment?: true
    applicableServices?: true
    documentationRequired?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubsidySchemeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubsidyScheme to aggregate.
     */
    where?: SubsidySchemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidySchemes to fetch.
     */
    orderBy?: SubsidySchemeOrderByWithRelationInput | SubsidySchemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubsidySchemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidySchemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidySchemes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubsidySchemes
    **/
    _count?: true | SubsidySchemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubsidySchemeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubsidySchemeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubsidySchemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubsidySchemeMaxAggregateInputType
  }

  export type GetSubsidySchemeAggregateType<T extends SubsidySchemeAggregateArgs> = {
        [P in keyof T & keyof AggregateSubsidyScheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubsidyScheme[P]>
      : GetScalarType<T[P], AggregateSubsidyScheme[P]>
  }




  export type SubsidySchemeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubsidySchemeWhereInput
    orderBy?: SubsidySchemeOrderByWithAggregationInput | SubsidySchemeOrderByWithAggregationInput[]
    by: SubsidySchemeScalarFieldEnum[] | SubsidySchemeScalarFieldEnum
    having?: SubsidySchemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubsidySchemeCountAggregateInputType | true
    _avg?: SubsidySchemeAvgAggregateInputType
    _sum?: SubsidySchemeSumAggregateInputType
    _min?: SubsidySchemeMinAggregateInputType
    _max?: SubsidySchemeMaxAggregateInputType
  }

  export type SubsidySchemeGroupByOutputType = {
    id: number
    name: string
    code: string
    description: string | null
    issuingAuthority: string
    startDate: Date
    endDate: Date | null
    eligibilityCriteria: string | null
    subsidyType: string
    percentageValue: number | null
    fixedAmount: Decimal | null
    maxCoverageAmount: Decimal | null
    maxCoveragePerTreatment: Decimal | null
    applicableServices: string | null
    documentationRequired: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SubsidySchemeCountAggregateOutputType | null
    _avg: SubsidySchemeAvgAggregateOutputType | null
    _sum: SubsidySchemeSumAggregateOutputType | null
    _min: SubsidySchemeMinAggregateOutputType | null
    _max: SubsidySchemeMaxAggregateOutputType | null
  }

  type GetSubsidySchemeGroupByPayload<T extends SubsidySchemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubsidySchemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubsidySchemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubsidySchemeGroupByOutputType[P]>
            : GetScalarType<T[P], SubsidySchemeGroupByOutputType[P]>
        }
      >
    >


  export type SubsidySchemeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    issuingAuthority?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    subsidyType?: boolean
    percentageValue?: boolean
    fixedAmount?: boolean
    maxCoverageAmount?: boolean
    maxCoveragePerTreatment?: boolean
    applicableServices?: boolean
    documentationRequired?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientSubsidies?: boolean | SubsidyScheme$patientSubsidiesArgs<ExtArgs>
    subsidyClaims?: boolean | SubsidyScheme$subsidyClaimsArgs<ExtArgs>
    _count?: boolean | SubsidySchemeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subsidyScheme"]>

  export type SubsidySchemeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    issuingAuthority?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    subsidyType?: boolean
    percentageValue?: boolean
    fixedAmount?: boolean
    maxCoverageAmount?: boolean
    maxCoveragePerTreatment?: boolean
    applicableServices?: boolean
    documentationRequired?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subsidyScheme"]>

  export type SubsidySchemeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    issuingAuthority?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    subsidyType?: boolean
    percentageValue?: boolean
    fixedAmount?: boolean
    maxCoverageAmount?: boolean
    maxCoveragePerTreatment?: boolean
    applicableServices?: boolean
    documentationRequired?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subsidyScheme"]>

  export type SubsidySchemeSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    issuingAuthority?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    subsidyType?: boolean
    percentageValue?: boolean
    fixedAmount?: boolean
    maxCoverageAmount?: boolean
    maxCoveragePerTreatment?: boolean
    applicableServices?: boolean
    documentationRequired?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubsidySchemeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "issuingAuthority" | "startDate" | "endDate" | "eligibilityCriteria" | "subsidyType" | "percentageValue" | "fixedAmount" | "maxCoverageAmount" | "maxCoveragePerTreatment" | "applicableServices" | "documentationRequired" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["subsidyScheme"]>
  export type SubsidySchemeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientSubsidies?: boolean | SubsidyScheme$patientSubsidiesArgs<ExtArgs>
    subsidyClaims?: boolean | SubsidyScheme$subsidyClaimsArgs<ExtArgs>
    _count?: boolean | SubsidySchemeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubsidySchemeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubsidySchemeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubsidySchemePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubsidyScheme"
    objects: {
      patientSubsidies: Prisma.$PatientSubsidyPayload<ExtArgs>[]
      subsidyClaims: Prisma.$SubsidyClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      description: string | null
      issuingAuthority: string
      startDate: Date
      endDate: Date | null
      eligibilityCriteria: string | null
      subsidyType: string
      percentageValue: number | null
      fixedAmount: Prisma.Decimal | null
      maxCoverageAmount: Prisma.Decimal | null
      maxCoveragePerTreatment: Prisma.Decimal | null
      applicableServices: string | null
      documentationRequired: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subsidyScheme"]>
    composites: {}
  }

  type SubsidySchemeGetPayload<S extends boolean | null | undefined | SubsidySchemeDefaultArgs> = $Result.GetResult<Prisma.$SubsidySchemePayload, S>

  type SubsidySchemeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubsidySchemeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubsidySchemeCountAggregateInputType | true
    }

  export interface SubsidySchemeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubsidyScheme'], meta: { name: 'SubsidyScheme' } }
    /**
     * Find zero or one SubsidyScheme that matches the filter.
     * @param {SubsidySchemeFindUniqueArgs} args - Arguments to find a SubsidyScheme
     * @example
     * // Get one SubsidyScheme
     * const subsidyScheme = await prisma.subsidyScheme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubsidySchemeFindUniqueArgs>(args: SelectSubset<T, SubsidySchemeFindUniqueArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubsidyScheme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubsidySchemeFindUniqueOrThrowArgs} args - Arguments to find a SubsidyScheme
     * @example
     * // Get one SubsidyScheme
     * const subsidyScheme = await prisma.subsidyScheme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubsidySchemeFindUniqueOrThrowArgs>(args: SelectSubset<T, SubsidySchemeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubsidyScheme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeFindFirstArgs} args - Arguments to find a SubsidyScheme
     * @example
     * // Get one SubsidyScheme
     * const subsidyScheme = await prisma.subsidyScheme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubsidySchemeFindFirstArgs>(args?: SelectSubset<T, SubsidySchemeFindFirstArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubsidyScheme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeFindFirstOrThrowArgs} args - Arguments to find a SubsidyScheme
     * @example
     * // Get one SubsidyScheme
     * const subsidyScheme = await prisma.subsidyScheme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubsidySchemeFindFirstOrThrowArgs>(args?: SelectSubset<T, SubsidySchemeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubsidySchemes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubsidySchemes
     * const subsidySchemes = await prisma.subsidyScheme.findMany()
     * 
     * // Get first 10 SubsidySchemes
     * const subsidySchemes = await prisma.subsidyScheme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subsidySchemeWithIdOnly = await prisma.subsidyScheme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubsidySchemeFindManyArgs>(args?: SelectSubset<T, SubsidySchemeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubsidyScheme.
     * @param {SubsidySchemeCreateArgs} args - Arguments to create a SubsidyScheme.
     * @example
     * // Create one SubsidyScheme
     * const SubsidyScheme = await prisma.subsidyScheme.create({
     *   data: {
     *     // ... data to create a SubsidyScheme
     *   }
     * })
     * 
     */
    create<T extends SubsidySchemeCreateArgs>(args: SelectSubset<T, SubsidySchemeCreateArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubsidySchemes.
     * @param {SubsidySchemeCreateManyArgs} args - Arguments to create many SubsidySchemes.
     * @example
     * // Create many SubsidySchemes
     * const subsidyScheme = await prisma.subsidyScheme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubsidySchemeCreateManyArgs>(args?: SelectSubset<T, SubsidySchemeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubsidySchemes and returns the data saved in the database.
     * @param {SubsidySchemeCreateManyAndReturnArgs} args - Arguments to create many SubsidySchemes.
     * @example
     * // Create many SubsidySchemes
     * const subsidyScheme = await prisma.subsidyScheme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubsidySchemes and only return the `id`
     * const subsidySchemeWithIdOnly = await prisma.subsidyScheme.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubsidySchemeCreateManyAndReturnArgs>(args?: SelectSubset<T, SubsidySchemeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubsidyScheme.
     * @param {SubsidySchemeDeleteArgs} args - Arguments to delete one SubsidyScheme.
     * @example
     * // Delete one SubsidyScheme
     * const SubsidyScheme = await prisma.subsidyScheme.delete({
     *   where: {
     *     // ... filter to delete one SubsidyScheme
     *   }
     * })
     * 
     */
    delete<T extends SubsidySchemeDeleteArgs>(args: SelectSubset<T, SubsidySchemeDeleteArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubsidyScheme.
     * @param {SubsidySchemeUpdateArgs} args - Arguments to update one SubsidyScheme.
     * @example
     * // Update one SubsidyScheme
     * const subsidyScheme = await prisma.subsidyScheme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubsidySchemeUpdateArgs>(args: SelectSubset<T, SubsidySchemeUpdateArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubsidySchemes.
     * @param {SubsidySchemeDeleteManyArgs} args - Arguments to filter SubsidySchemes to delete.
     * @example
     * // Delete a few SubsidySchemes
     * const { count } = await prisma.subsidyScheme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubsidySchemeDeleteManyArgs>(args?: SelectSubset<T, SubsidySchemeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubsidySchemes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubsidySchemes
     * const subsidyScheme = await prisma.subsidyScheme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubsidySchemeUpdateManyArgs>(args: SelectSubset<T, SubsidySchemeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubsidySchemes and returns the data updated in the database.
     * @param {SubsidySchemeUpdateManyAndReturnArgs} args - Arguments to update many SubsidySchemes.
     * @example
     * // Update many SubsidySchemes
     * const subsidyScheme = await prisma.subsidyScheme.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubsidySchemes and only return the `id`
     * const subsidySchemeWithIdOnly = await prisma.subsidyScheme.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubsidySchemeUpdateManyAndReturnArgs>(args: SelectSubset<T, SubsidySchemeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubsidyScheme.
     * @param {SubsidySchemeUpsertArgs} args - Arguments to update or create a SubsidyScheme.
     * @example
     * // Update or create a SubsidyScheme
     * const subsidyScheme = await prisma.subsidyScheme.upsert({
     *   create: {
     *     // ... data to create a SubsidyScheme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubsidyScheme we want to update
     *   }
     * })
     */
    upsert<T extends SubsidySchemeUpsertArgs>(args: SelectSubset<T, SubsidySchemeUpsertArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubsidySchemes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeCountArgs} args - Arguments to filter SubsidySchemes to count.
     * @example
     * // Count the number of SubsidySchemes
     * const count = await prisma.subsidyScheme.count({
     *   where: {
     *     // ... the filter for the SubsidySchemes we want to count
     *   }
     * })
    **/
    count<T extends SubsidySchemeCountArgs>(
      args?: Subset<T, SubsidySchemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubsidySchemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubsidyScheme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubsidySchemeAggregateArgs>(args: Subset<T, SubsidySchemeAggregateArgs>): Prisma.PrismaPromise<GetSubsidySchemeAggregateType<T>>

    /**
     * Group by SubsidyScheme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidySchemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubsidySchemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubsidySchemeGroupByArgs['orderBy'] }
        : { orderBy?: SubsidySchemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubsidySchemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubsidySchemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubsidyScheme model
   */
  readonly fields: SubsidySchemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubsidyScheme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubsidySchemeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientSubsidies<T extends SubsidyScheme$patientSubsidiesArgs<ExtArgs> = {}>(args?: Subset<T, SubsidyScheme$patientSubsidiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subsidyClaims<T extends SubsidyScheme$subsidyClaimsArgs<ExtArgs> = {}>(args?: Subset<T, SubsidyScheme$subsidyClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubsidyScheme model
   */
  interface SubsidySchemeFieldRefs {
    readonly id: FieldRef<"SubsidyScheme", 'Int'>
    readonly name: FieldRef<"SubsidyScheme", 'String'>
    readonly code: FieldRef<"SubsidyScheme", 'String'>
    readonly description: FieldRef<"SubsidyScheme", 'String'>
    readonly issuingAuthority: FieldRef<"SubsidyScheme", 'String'>
    readonly startDate: FieldRef<"SubsidyScheme", 'DateTime'>
    readonly endDate: FieldRef<"SubsidyScheme", 'DateTime'>
    readonly eligibilityCriteria: FieldRef<"SubsidyScheme", 'String'>
    readonly subsidyType: FieldRef<"SubsidyScheme", 'String'>
    readonly percentageValue: FieldRef<"SubsidyScheme", 'Float'>
    readonly fixedAmount: FieldRef<"SubsidyScheme", 'Decimal'>
    readonly maxCoverageAmount: FieldRef<"SubsidyScheme", 'Decimal'>
    readonly maxCoveragePerTreatment: FieldRef<"SubsidyScheme", 'Decimal'>
    readonly applicableServices: FieldRef<"SubsidyScheme", 'String'>
    readonly documentationRequired: FieldRef<"SubsidyScheme", 'String'>
    readonly status: FieldRef<"SubsidyScheme", 'String'>
    readonly createdAt: FieldRef<"SubsidyScheme", 'DateTime'>
    readonly updatedAt: FieldRef<"SubsidyScheme", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubsidyScheme findUnique
   */
  export type SubsidySchemeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyScheme to fetch.
     */
    where: SubsidySchemeWhereUniqueInput
  }

  /**
   * SubsidyScheme findUniqueOrThrow
   */
  export type SubsidySchemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyScheme to fetch.
     */
    where: SubsidySchemeWhereUniqueInput
  }

  /**
   * SubsidyScheme findFirst
   */
  export type SubsidySchemeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyScheme to fetch.
     */
    where?: SubsidySchemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidySchemes to fetch.
     */
    orderBy?: SubsidySchemeOrderByWithRelationInput | SubsidySchemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubsidySchemes.
     */
    cursor?: SubsidySchemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidySchemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidySchemes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubsidySchemes.
     */
    distinct?: SubsidySchemeScalarFieldEnum | SubsidySchemeScalarFieldEnum[]
  }

  /**
   * SubsidyScheme findFirstOrThrow
   */
  export type SubsidySchemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyScheme to fetch.
     */
    where?: SubsidySchemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidySchemes to fetch.
     */
    orderBy?: SubsidySchemeOrderByWithRelationInput | SubsidySchemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubsidySchemes.
     */
    cursor?: SubsidySchemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidySchemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidySchemes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubsidySchemes.
     */
    distinct?: SubsidySchemeScalarFieldEnum | SubsidySchemeScalarFieldEnum[]
  }

  /**
   * SubsidyScheme findMany
   */
  export type SubsidySchemeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * Filter, which SubsidySchemes to fetch.
     */
    where?: SubsidySchemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidySchemes to fetch.
     */
    orderBy?: SubsidySchemeOrderByWithRelationInput | SubsidySchemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubsidySchemes.
     */
    cursor?: SubsidySchemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidySchemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidySchemes.
     */
    skip?: number
    distinct?: SubsidySchemeScalarFieldEnum | SubsidySchemeScalarFieldEnum[]
  }

  /**
   * SubsidyScheme create
   */
  export type SubsidySchemeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * The data needed to create a SubsidyScheme.
     */
    data: XOR<SubsidySchemeCreateInput, SubsidySchemeUncheckedCreateInput>
  }

  /**
   * SubsidyScheme createMany
   */
  export type SubsidySchemeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubsidySchemes.
     */
    data: SubsidySchemeCreateManyInput | SubsidySchemeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubsidyScheme createManyAndReturn
   */
  export type SubsidySchemeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * The data used to create many SubsidySchemes.
     */
    data: SubsidySchemeCreateManyInput | SubsidySchemeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubsidyScheme update
   */
  export type SubsidySchemeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * The data needed to update a SubsidyScheme.
     */
    data: XOR<SubsidySchemeUpdateInput, SubsidySchemeUncheckedUpdateInput>
    /**
     * Choose, which SubsidyScheme to update.
     */
    where: SubsidySchemeWhereUniqueInput
  }

  /**
   * SubsidyScheme updateMany
   */
  export type SubsidySchemeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubsidySchemes.
     */
    data: XOR<SubsidySchemeUpdateManyMutationInput, SubsidySchemeUncheckedUpdateManyInput>
    /**
     * Filter which SubsidySchemes to update
     */
    where?: SubsidySchemeWhereInput
    /**
     * Limit how many SubsidySchemes to update.
     */
    limit?: number
  }

  /**
   * SubsidyScheme updateManyAndReturn
   */
  export type SubsidySchemeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * The data used to update SubsidySchemes.
     */
    data: XOR<SubsidySchemeUpdateManyMutationInput, SubsidySchemeUncheckedUpdateManyInput>
    /**
     * Filter which SubsidySchemes to update
     */
    where?: SubsidySchemeWhereInput
    /**
     * Limit how many SubsidySchemes to update.
     */
    limit?: number
  }

  /**
   * SubsidyScheme upsert
   */
  export type SubsidySchemeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * The filter to search for the SubsidyScheme to update in case it exists.
     */
    where: SubsidySchemeWhereUniqueInput
    /**
     * In case the SubsidyScheme found by the `where` argument doesn't exist, create a new SubsidyScheme with this data.
     */
    create: XOR<SubsidySchemeCreateInput, SubsidySchemeUncheckedCreateInput>
    /**
     * In case the SubsidyScheme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubsidySchemeUpdateInput, SubsidySchemeUncheckedUpdateInput>
  }

  /**
   * SubsidyScheme delete
   */
  export type SubsidySchemeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
    /**
     * Filter which SubsidyScheme to delete.
     */
    where: SubsidySchemeWhereUniqueInput
  }

  /**
   * SubsidyScheme deleteMany
   */
  export type SubsidySchemeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubsidySchemes to delete
     */
    where?: SubsidySchemeWhereInput
    /**
     * Limit how many SubsidySchemes to delete.
     */
    limit?: number
  }

  /**
   * SubsidyScheme.patientSubsidies
   */
  export type SubsidyScheme$patientSubsidiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    where?: PatientSubsidyWhereInput
    orderBy?: PatientSubsidyOrderByWithRelationInput | PatientSubsidyOrderByWithRelationInput[]
    cursor?: PatientSubsidyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientSubsidyScalarFieldEnum | PatientSubsidyScalarFieldEnum[]
  }

  /**
   * SubsidyScheme.subsidyClaims
   */
  export type SubsidyScheme$subsidyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    where?: SubsidyClaimWhereInput
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    cursor?: SubsidyClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubsidyClaimScalarFieldEnum | SubsidyClaimScalarFieldEnum[]
  }

  /**
   * SubsidyScheme without action
   */
  export type SubsidySchemeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyScheme
     */
    select?: SubsidySchemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyScheme
     */
    omit?: SubsidySchemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidySchemeInclude<ExtArgs> | null
  }


  /**
   * Model PatientSubsidy
   */

  export type AggregatePatientSubsidy = {
    _count: PatientSubsidyCountAggregateOutputType | null
    _avg: PatientSubsidyAvgAggregateOutputType | null
    _sum: PatientSubsidySumAggregateOutputType | null
    _min: PatientSubsidyMinAggregateOutputType | null
    _max: PatientSubsidyMaxAggregateOutputType | null
  }

  export type PatientSubsidyAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    schemeId: number | null
    remainingBalance: Decimal | null
    verifiedBy: number | null
  }

  export type PatientSubsidySumAggregateOutputType = {
    id: number | null
    patientId: number | null
    schemeId: number | null
    remainingBalance: Decimal | null
    verifiedBy: number | null
  }

  export type PatientSubsidyMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    schemeId: number | null
    enrollmentDate: Date | null
    enrollmentNumber: string | null
    cardNumber: string | null
    validFrom: Date | null
    validUntil: Date | null
    remainingBalance: Decimal | null
    status: string | null
    verificationStatus: string | null
    verifiedBy: number | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientSubsidyMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    schemeId: number | null
    enrollmentDate: Date | null
    enrollmentNumber: string | null
    cardNumber: string | null
    validFrom: Date | null
    validUntil: Date | null
    remainingBalance: Decimal | null
    status: string | null
    verificationStatus: string | null
    verifiedBy: number | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientSubsidyCountAggregateOutputType = {
    id: number
    patientId: number
    schemeId: number
    enrollmentDate: number
    enrollmentNumber: number
    cardNumber: number
    validFrom: number
    validUntil: number
    remainingBalance: number
    status: number
    verificationStatus: number
    verifiedBy: number
    verifiedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientSubsidyAvgAggregateInputType = {
    id?: true
    patientId?: true
    schemeId?: true
    remainingBalance?: true
    verifiedBy?: true
  }

  export type PatientSubsidySumAggregateInputType = {
    id?: true
    patientId?: true
    schemeId?: true
    remainingBalance?: true
    verifiedBy?: true
  }

  export type PatientSubsidyMinAggregateInputType = {
    id?: true
    patientId?: true
    schemeId?: true
    enrollmentDate?: true
    enrollmentNumber?: true
    cardNumber?: true
    validFrom?: true
    validUntil?: true
    remainingBalance?: true
    status?: true
    verificationStatus?: true
    verifiedBy?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientSubsidyMaxAggregateInputType = {
    id?: true
    patientId?: true
    schemeId?: true
    enrollmentDate?: true
    enrollmentNumber?: true
    cardNumber?: true
    validFrom?: true
    validUntil?: true
    remainingBalance?: true
    status?: true
    verificationStatus?: true
    verifiedBy?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientSubsidyCountAggregateInputType = {
    id?: true
    patientId?: true
    schemeId?: true
    enrollmentDate?: true
    enrollmentNumber?: true
    cardNumber?: true
    validFrom?: true
    validUntil?: true
    remainingBalance?: true
    status?: true
    verificationStatus?: true
    verifiedBy?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientSubsidyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientSubsidy to aggregate.
     */
    where?: PatientSubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSubsidies to fetch.
     */
    orderBy?: PatientSubsidyOrderByWithRelationInput | PatientSubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientSubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSubsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSubsidies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientSubsidies
    **/
    _count?: true | PatientSubsidyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientSubsidyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSubsidySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientSubsidyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientSubsidyMaxAggregateInputType
  }

  export type GetPatientSubsidyAggregateType<T extends PatientSubsidyAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientSubsidy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientSubsidy[P]>
      : GetScalarType<T[P], AggregatePatientSubsidy[P]>
  }




  export type PatientSubsidyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientSubsidyWhereInput
    orderBy?: PatientSubsidyOrderByWithAggregationInput | PatientSubsidyOrderByWithAggregationInput[]
    by: PatientSubsidyScalarFieldEnum[] | PatientSubsidyScalarFieldEnum
    having?: PatientSubsidyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientSubsidyCountAggregateInputType | true
    _avg?: PatientSubsidyAvgAggregateInputType
    _sum?: PatientSubsidySumAggregateInputType
    _min?: PatientSubsidyMinAggregateInputType
    _max?: PatientSubsidyMaxAggregateInputType
  }

  export type PatientSubsidyGroupByOutputType = {
    id: number
    patientId: number
    schemeId: number
    enrollmentDate: Date
    enrollmentNumber: string
    cardNumber: string | null
    validFrom: Date
    validUntil: Date | null
    remainingBalance: Decimal | null
    status: string
    verificationStatus: string
    verifiedBy: number | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientSubsidyCountAggregateOutputType | null
    _avg: PatientSubsidyAvgAggregateOutputType | null
    _sum: PatientSubsidySumAggregateOutputType | null
    _min: PatientSubsidyMinAggregateOutputType | null
    _max: PatientSubsidyMaxAggregateOutputType | null
  }

  type GetPatientSubsidyGroupByPayload<T extends PatientSubsidyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientSubsidyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientSubsidyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientSubsidyGroupByOutputType[P]>
            : GetScalarType<T[P], PatientSubsidyGroupByOutputType[P]>
        }
      >
    >


  export type PatientSubsidySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    schemeId?: boolean
    enrollmentDate?: boolean
    enrollmentNumber?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validUntil?: boolean
    remainingBalance?: boolean
    status?: boolean
    verificationStatus?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    subsidyClaims?: boolean | PatientSubsidy$subsidyClaimsArgs<ExtArgs>
    _count?: boolean | PatientSubsidyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientSubsidy"]>

  export type PatientSubsidySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    schemeId?: boolean
    enrollmentDate?: boolean
    enrollmentNumber?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validUntil?: boolean
    remainingBalance?: boolean
    status?: boolean
    verificationStatus?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientSubsidy"]>

  export type PatientSubsidySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    schemeId?: boolean
    enrollmentDate?: boolean
    enrollmentNumber?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validUntil?: boolean
    remainingBalance?: boolean
    status?: boolean
    verificationStatus?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientSubsidy"]>

  export type PatientSubsidySelectScalar = {
    id?: boolean
    patientId?: boolean
    schemeId?: boolean
    enrollmentDate?: boolean
    enrollmentNumber?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validUntil?: boolean
    remainingBalance?: boolean
    status?: boolean
    verificationStatus?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientSubsidyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "schemeId" | "enrollmentDate" | "enrollmentNumber" | "cardNumber" | "validFrom" | "validUntil" | "remainingBalance" | "status" | "verificationStatus" | "verifiedBy" | "verifiedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["patientSubsidy"]>
  export type PatientSubsidyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    subsidyClaims?: boolean | PatientSubsidy$subsidyClaimsArgs<ExtArgs>
    _count?: boolean | PatientSubsidyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientSubsidyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
  }
  export type PatientSubsidyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
  }

  export type $PatientSubsidyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientSubsidy"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      scheme: Prisma.$SubsidySchemePayload<ExtArgs>
      subsidyClaims: Prisma.$SubsidyClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      schemeId: number
      enrollmentDate: Date
      enrollmentNumber: string
      cardNumber: string | null
      validFrom: Date
      validUntil: Date | null
      remainingBalance: Prisma.Decimal | null
      status: string
      verificationStatus: string
      verifiedBy: number | null
      verifiedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patientSubsidy"]>
    composites: {}
  }

  type PatientSubsidyGetPayload<S extends boolean | null | undefined | PatientSubsidyDefaultArgs> = $Result.GetResult<Prisma.$PatientSubsidyPayload, S>

  type PatientSubsidyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientSubsidyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientSubsidyCountAggregateInputType | true
    }

  export interface PatientSubsidyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientSubsidy'], meta: { name: 'PatientSubsidy' } }
    /**
     * Find zero or one PatientSubsidy that matches the filter.
     * @param {PatientSubsidyFindUniqueArgs} args - Arguments to find a PatientSubsidy
     * @example
     * // Get one PatientSubsidy
     * const patientSubsidy = await prisma.patientSubsidy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientSubsidyFindUniqueArgs>(args: SelectSubset<T, PatientSubsidyFindUniqueArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientSubsidy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientSubsidyFindUniqueOrThrowArgs} args - Arguments to find a PatientSubsidy
     * @example
     * // Get one PatientSubsidy
     * const patientSubsidy = await prisma.patientSubsidy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientSubsidyFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientSubsidyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientSubsidy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyFindFirstArgs} args - Arguments to find a PatientSubsidy
     * @example
     * // Get one PatientSubsidy
     * const patientSubsidy = await prisma.patientSubsidy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientSubsidyFindFirstArgs>(args?: SelectSubset<T, PatientSubsidyFindFirstArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientSubsidy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyFindFirstOrThrowArgs} args - Arguments to find a PatientSubsidy
     * @example
     * // Get one PatientSubsidy
     * const patientSubsidy = await prisma.patientSubsidy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientSubsidyFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientSubsidyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientSubsidies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientSubsidies
     * const patientSubsidies = await prisma.patientSubsidy.findMany()
     * 
     * // Get first 10 PatientSubsidies
     * const patientSubsidies = await prisma.patientSubsidy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientSubsidyWithIdOnly = await prisma.patientSubsidy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientSubsidyFindManyArgs>(args?: SelectSubset<T, PatientSubsidyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientSubsidy.
     * @param {PatientSubsidyCreateArgs} args - Arguments to create a PatientSubsidy.
     * @example
     * // Create one PatientSubsidy
     * const PatientSubsidy = await prisma.patientSubsidy.create({
     *   data: {
     *     // ... data to create a PatientSubsidy
     *   }
     * })
     * 
     */
    create<T extends PatientSubsidyCreateArgs>(args: SelectSubset<T, PatientSubsidyCreateArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientSubsidies.
     * @param {PatientSubsidyCreateManyArgs} args - Arguments to create many PatientSubsidies.
     * @example
     * // Create many PatientSubsidies
     * const patientSubsidy = await prisma.patientSubsidy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientSubsidyCreateManyArgs>(args?: SelectSubset<T, PatientSubsidyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientSubsidies and returns the data saved in the database.
     * @param {PatientSubsidyCreateManyAndReturnArgs} args - Arguments to create many PatientSubsidies.
     * @example
     * // Create many PatientSubsidies
     * const patientSubsidy = await prisma.patientSubsidy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientSubsidies and only return the `id`
     * const patientSubsidyWithIdOnly = await prisma.patientSubsidy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientSubsidyCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientSubsidyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientSubsidy.
     * @param {PatientSubsidyDeleteArgs} args - Arguments to delete one PatientSubsidy.
     * @example
     * // Delete one PatientSubsidy
     * const PatientSubsidy = await prisma.patientSubsidy.delete({
     *   where: {
     *     // ... filter to delete one PatientSubsidy
     *   }
     * })
     * 
     */
    delete<T extends PatientSubsidyDeleteArgs>(args: SelectSubset<T, PatientSubsidyDeleteArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientSubsidy.
     * @param {PatientSubsidyUpdateArgs} args - Arguments to update one PatientSubsidy.
     * @example
     * // Update one PatientSubsidy
     * const patientSubsidy = await prisma.patientSubsidy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientSubsidyUpdateArgs>(args: SelectSubset<T, PatientSubsidyUpdateArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientSubsidies.
     * @param {PatientSubsidyDeleteManyArgs} args - Arguments to filter PatientSubsidies to delete.
     * @example
     * // Delete a few PatientSubsidies
     * const { count } = await prisma.patientSubsidy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientSubsidyDeleteManyArgs>(args?: SelectSubset<T, PatientSubsidyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientSubsidies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientSubsidies
     * const patientSubsidy = await prisma.patientSubsidy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientSubsidyUpdateManyArgs>(args: SelectSubset<T, PatientSubsidyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientSubsidies and returns the data updated in the database.
     * @param {PatientSubsidyUpdateManyAndReturnArgs} args - Arguments to update many PatientSubsidies.
     * @example
     * // Update many PatientSubsidies
     * const patientSubsidy = await prisma.patientSubsidy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientSubsidies and only return the `id`
     * const patientSubsidyWithIdOnly = await prisma.patientSubsidy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientSubsidyUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientSubsidyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientSubsidy.
     * @param {PatientSubsidyUpsertArgs} args - Arguments to update or create a PatientSubsidy.
     * @example
     * // Update or create a PatientSubsidy
     * const patientSubsidy = await prisma.patientSubsidy.upsert({
     *   create: {
     *     // ... data to create a PatientSubsidy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientSubsidy we want to update
     *   }
     * })
     */
    upsert<T extends PatientSubsidyUpsertArgs>(args: SelectSubset<T, PatientSubsidyUpsertArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientSubsidies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyCountArgs} args - Arguments to filter PatientSubsidies to count.
     * @example
     * // Count the number of PatientSubsidies
     * const count = await prisma.patientSubsidy.count({
     *   where: {
     *     // ... the filter for the PatientSubsidies we want to count
     *   }
     * })
    **/
    count<T extends PatientSubsidyCountArgs>(
      args?: Subset<T, PatientSubsidyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientSubsidyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientSubsidy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientSubsidyAggregateArgs>(args: Subset<T, PatientSubsidyAggregateArgs>): Prisma.PrismaPromise<GetPatientSubsidyAggregateType<T>>

    /**
     * Group by PatientSubsidy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSubsidyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientSubsidyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientSubsidyGroupByArgs['orderBy'] }
        : { orderBy?: PatientSubsidyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientSubsidyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientSubsidyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientSubsidy model
   */
  readonly fields: PatientSubsidyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientSubsidy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientSubsidyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scheme<T extends SubsidySchemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubsidySchemeDefaultArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subsidyClaims<T extends PatientSubsidy$subsidyClaimsArgs<ExtArgs> = {}>(args?: Subset<T, PatientSubsidy$subsidyClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientSubsidy model
   */
  interface PatientSubsidyFieldRefs {
    readonly id: FieldRef<"PatientSubsidy", 'Int'>
    readonly patientId: FieldRef<"PatientSubsidy", 'Int'>
    readonly schemeId: FieldRef<"PatientSubsidy", 'Int'>
    readonly enrollmentDate: FieldRef<"PatientSubsidy", 'DateTime'>
    readonly enrollmentNumber: FieldRef<"PatientSubsidy", 'String'>
    readonly cardNumber: FieldRef<"PatientSubsidy", 'String'>
    readonly validFrom: FieldRef<"PatientSubsidy", 'DateTime'>
    readonly validUntil: FieldRef<"PatientSubsidy", 'DateTime'>
    readonly remainingBalance: FieldRef<"PatientSubsidy", 'Decimal'>
    readonly status: FieldRef<"PatientSubsidy", 'String'>
    readonly verificationStatus: FieldRef<"PatientSubsidy", 'String'>
    readonly verifiedBy: FieldRef<"PatientSubsidy", 'Int'>
    readonly verifiedAt: FieldRef<"PatientSubsidy", 'DateTime'>
    readonly notes: FieldRef<"PatientSubsidy", 'String'>
    readonly createdAt: FieldRef<"PatientSubsidy", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientSubsidy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientSubsidy findUnique
   */
  export type PatientSubsidyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * Filter, which PatientSubsidy to fetch.
     */
    where: PatientSubsidyWhereUniqueInput
  }

  /**
   * PatientSubsidy findUniqueOrThrow
   */
  export type PatientSubsidyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * Filter, which PatientSubsidy to fetch.
     */
    where: PatientSubsidyWhereUniqueInput
  }

  /**
   * PatientSubsidy findFirst
   */
  export type PatientSubsidyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * Filter, which PatientSubsidy to fetch.
     */
    where?: PatientSubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSubsidies to fetch.
     */
    orderBy?: PatientSubsidyOrderByWithRelationInput | PatientSubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientSubsidies.
     */
    cursor?: PatientSubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSubsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSubsidies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientSubsidies.
     */
    distinct?: PatientSubsidyScalarFieldEnum | PatientSubsidyScalarFieldEnum[]
  }

  /**
   * PatientSubsidy findFirstOrThrow
   */
  export type PatientSubsidyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * Filter, which PatientSubsidy to fetch.
     */
    where?: PatientSubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSubsidies to fetch.
     */
    orderBy?: PatientSubsidyOrderByWithRelationInput | PatientSubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientSubsidies.
     */
    cursor?: PatientSubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSubsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSubsidies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientSubsidies.
     */
    distinct?: PatientSubsidyScalarFieldEnum | PatientSubsidyScalarFieldEnum[]
  }

  /**
   * PatientSubsidy findMany
   */
  export type PatientSubsidyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * Filter, which PatientSubsidies to fetch.
     */
    where?: PatientSubsidyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSubsidies to fetch.
     */
    orderBy?: PatientSubsidyOrderByWithRelationInput | PatientSubsidyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientSubsidies.
     */
    cursor?: PatientSubsidyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSubsidies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSubsidies.
     */
    skip?: number
    distinct?: PatientSubsidyScalarFieldEnum | PatientSubsidyScalarFieldEnum[]
  }

  /**
   * PatientSubsidy create
   */
  export type PatientSubsidyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientSubsidy.
     */
    data: XOR<PatientSubsidyCreateInput, PatientSubsidyUncheckedCreateInput>
  }

  /**
   * PatientSubsidy createMany
   */
  export type PatientSubsidyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientSubsidies.
     */
    data: PatientSubsidyCreateManyInput | PatientSubsidyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientSubsidy createManyAndReturn
   */
  export type PatientSubsidyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * The data used to create many PatientSubsidies.
     */
    data: PatientSubsidyCreateManyInput | PatientSubsidyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientSubsidy update
   */
  export type PatientSubsidyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientSubsidy.
     */
    data: XOR<PatientSubsidyUpdateInput, PatientSubsidyUncheckedUpdateInput>
    /**
     * Choose, which PatientSubsidy to update.
     */
    where: PatientSubsidyWhereUniqueInput
  }

  /**
   * PatientSubsidy updateMany
   */
  export type PatientSubsidyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientSubsidies.
     */
    data: XOR<PatientSubsidyUpdateManyMutationInput, PatientSubsidyUncheckedUpdateManyInput>
    /**
     * Filter which PatientSubsidies to update
     */
    where?: PatientSubsidyWhereInput
    /**
     * Limit how many PatientSubsidies to update.
     */
    limit?: number
  }

  /**
   * PatientSubsidy updateManyAndReturn
   */
  export type PatientSubsidyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * The data used to update PatientSubsidies.
     */
    data: XOR<PatientSubsidyUpdateManyMutationInput, PatientSubsidyUncheckedUpdateManyInput>
    /**
     * Filter which PatientSubsidies to update
     */
    where?: PatientSubsidyWhereInput
    /**
     * Limit how many PatientSubsidies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientSubsidy upsert
   */
  export type PatientSubsidyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientSubsidy to update in case it exists.
     */
    where: PatientSubsidyWhereUniqueInput
    /**
     * In case the PatientSubsidy found by the `where` argument doesn't exist, create a new PatientSubsidy with this data.
     */
    create: XOR<PatientSubsidyCreateInput, PatientSubsidyUncheckedCreateInput>
    /**
     * In case the PatientSubsidy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientSubsidyUpdateInput, PatientSubsidyUncheckedUpdateInput>
  }

  /**
   * PatientSubsidy delete
   */
  export type PatientSubsidyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
    /**
     * Filter which PatientSubsidy to delete.
     */
    where: PatientSubsidyWhereUniqueInput
  }

  /**
   * PatientSubsidy deleteMany
   */
  export type PatientSubsidyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientSubsidies to delete
     */
    where?: PatientSubsidyWhereInput
    /**
     * Limit how many PatientSubsidies to delete.
     */
    limit?: number
  }

  /**
   * PatientSubsidy.subsidyClaims
   */
  export type PatientSubsidy$subsidyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    where?: SubsidyClaimWhereInput
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    cursor?: SubsidyClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubsidyClaimScalarFieldEnum | SubsidyClaimScalarFieldEnum[]
  }

  /**
   * PatientSubsidy without action
   */
  export type PatientSubsidyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSubsidy
     */
    select?: PatientSubsidySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientSubsidy
     */
    omit?: PatientSubsidyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSubsidyInclude<ExtArgs> | null
  }


  /**
   * Model SubsidyClaim
   */

  export type AggregateSubsidyClaim = {
    _count: SubsidyClaimCountAggregateOutputType | null
    _avg: SubsidyClaimAvgAggregateOutputType | null
    _sum: SubsidyClaimSumAggregateOutputType | null
    _min: SubsidyClaimMinAggregateOutputType | null
    _max: SubsidyClaimMaxAggregateOutputType | null
  }

  export type SubsidyClaimAvgAggregateOutputType = {
    id: number | null
    patientSubsidyId: number | null
    schemeId: number | null
    invoiceId: number | null
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
    processedBy: number | null
  }

  export type SubsidyClaimSumAggregateOutputType = {
    id: number | null
    patientSubsidyId: number | null
    schemeId: number | null
    invoiceId: number | null
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
    processedBy: number | null
  }

  export type SubsidyClaimMinAggregateOutputType = {
    id: number | null
    patientSubsidyId: number | null
    schemeId: number | null
    invoiceId: number | null
    claimDate: Date | null
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
    rejectionReason: string | null
    claimStatus: string | null
    processedBy: number | null
    processedAt: Date | null
    reimbursementDate: Date | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubsidyClaimMaxAggregateOutputType = {
    id: number | null
    patientSubsidyId: number | null
    schemeId: number | null
    invoiceId: number | null
    claimDate: Date | null
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
    rejectionReason: string | null
    claimStatus: string | null
    processedBy: number | null
    processedAt: Date | null
    reimbursementDate: Date | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubsidyClaimCountAggregateOutputType = {
    id: number
    patientSubsidyId: number
    schemeId: number
    invoiceId: number
    claimDate: number
    claimAmount: number
    approvedAmount: number
    rejectionReason: number
    claimStatus: number
    processedBy: number
    processedAt: number
    reimbursementDate: number
    transactionId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubsidyClaimAvgAggregateInputType = {
    id?: true
    patientSubsidyId?: true
    schemeId?: true
    invoiceId?: true
    claimAmount?: true
    approvedAmount?: true
    processedBy?: true
  }

  export type SubsidyClaimSumAggregateInputType = {
    id?: true
    patientSubsidyId?: true
    schemeId?: true
    invoiceId?: true
    claimAmount?: true
    approvedAmount?: true
    processedBy?: true
  }

  export type SubsidyClaimMinAggregateInputType = {
    id?: true
    patientSubsidyId?: true
    schemeId?: true
    invoiceId?: true
    claimDate?: true
    claimAmount?: true
    approvedAmount?: true
    rejectionReason?: true
    claimStatus?: true
    processedBy?: true
    processedAt?: true
    reimbursementDate?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubsidyClaimMaxAggregateInputType = {
    id?: true
    patientSubsidyId?: true
    schemeId?: true
    invoiceId?: true
    claimDate?: true
    claimAmount?: true
    approvedAmount?: true
    rejectionReason?: true
    claimStatus?: true
    processedBy?: true
    processedAt?: true
    reimbursementDate?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubsidyClaimCountAggregateInputType = {
    id?: true
    patientSubsidyId?: true
    schemeId?: true
    invoiceId?: true
    claimDate?: true
    claimAmount?: true
    approvedAmount?: true
    rejectionReason?: true
    claimStatus?: true
    processedBy?: true
    processedAt?: true
    reimbursementDate?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubsidyClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubsidyClaim to aggregate.
     */
    where?: SubsidyClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidyClaims to fetch.
     */
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubsidyClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidyClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidyClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubsidyClaims
    **/
    _count?: true | SubsidyClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubsidyClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubsidyClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubsidyClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubsidyClaimMaxAggregateInputType
  }

  export type GetSubsidyClaimAggregateType<T extends SubsidyClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateSubsidyClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubsidyClaim[P]>
      : GetScalarType<T[P], AggregateSubsidyClaim[P]>
  }




  export type SubsidyClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubsidyClaimWhereInput
    orderBy?: SubsidyClaimOrderByWithAggregationInput | SubsidyClaimOrderByWithAggregationInput[]
    by: SubsidyClaimScalarFieldEnum[] | SubsidyClaimScalarFieldEnum
    having?: SubsidyClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubsidyClaimCountAggregateInputType | true
    _avg?: SubsidyClaimAvgAggregateInputType
    _sum?: SubsidyClaimSumAggregateInputType
    _min?: SubsidyClaimMinAggregateInputType
    _max?: SubsidyClaimMaxAggregateInputType
  }

  export type SubsidyClaimGroupByOutputType = {
    id: number
    patientSubsidyId: number
    schemeId: number
    invoiceId: number | null
    claimDate: Date
    claimAmount: Decimal
    approvedAmount: Decimal | null
    rejectionReason: string | null
    claimStatus: string
    processedBy: number | null
    processedAt: Date | null
    reimbursementDate: Date | null
    transactionId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubsidyClaimCountAggregateOutputType | null
    _avg: SubsidyClaimAvgAggregateOutputType | null
    _sum: SubsidyClaimSumAggregateOutputType | null
    _min: SubsidyClaimMinAggregateOutputType | null
    _max: SubsidyClaimMaxAggregateOutputType | null
  }

  type GetSubsidyClaimGroupByPayload<T extends SubsidyClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubsidyClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubsidyClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubsidyClaimGroupByOutputType[P]>
            : GetScalarType<T[P], SubsidyClaimGroupByOutputType[P]>
        }
      >
    >


  export type SubsidyClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientSubsidyId?: boolean
    schemeId?: boolean
    invoiceId?: boolean
    claimDate?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    rejectionReason?: boolean
    claimStatus?: boolean
    processedBy?: boolean
    processedAt?: boolean
    reimbursementDate?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientSubsidy?: boolean | PatientSubsidyDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    invoice?: boolean | SubsidyClaim$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["subsidyClaim"]>

  export type SubsidyClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientSubsidyId?: boolean
    schemeId?: boolean
    invoiceId?: boolean
    claimDate?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    rejectionReason?: boolean
    claimStatus?: boolean
    processedBy?: boolean
    processedAt?: boolean
    reimbursementDate?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientSubsidy?: boolean | PatientSubsidyDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    invoice?: boolean | SubsidyClaim$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["subsidyClaim"]>

  export type SubsidyClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientSubsidyId?: boolean
    schemeId?: boolean
    invoiceId?: boolean
    claimDate?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    rejectionReason?: boolean
    claimStatus?: boolean
    processedBy?: boolean
    processedAt?: boolean
    reimbursementDate?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientSubsidy?: boolean | PatientSubsidyDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    invoice?: boolean | SubsidyClaim$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["subsidyClaim"]>

  export type SubsidyClaimSelectScalar = {
    id?: boolean
    patientSubsidyId?: boolean
    schemeId?: boolean
    invoiceId?: boolean
    claimDate?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    rejectionReason?: boolean
    claimStatus?: boolean
    processedBy?: boolean
    processedAt?: boolean
    reimbursementDate?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubsidyClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientSubsidyId" | "schemeId" | "invoiceId" | "claimDate" | "claimAmount" | "approvedAmount" | "rejectionReason" | "claimStatus" | "processedBy" | "processedAt" | "reimbursementDate" | "transactionId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["subsidyClaim"]>
  export type SubsidyClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientSubsidy?: boolean | PatientSubsidyDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    invoice?: boolean | SubsidyClaim$invoiceArgs<ExtArgs>
  }
  export type SubsidyClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientSubsidy?: boolean | PatientSubsidyDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    invoice?: boolean | SubsidyClaim$invoiceArgs<ExtArgs>
  }
  export type SubsidyClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientSubsidy?: boolean | PatientSubsidyDefaultArgs<ExtArgs>
    scheme?: boolean | SubsidySchemeDefaultArgs<ExtArgs>
    invoice?: boolean | SubsidyClaim$invoiceArgs<ExtArgs>
  }

  export type $SubsidyClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubsidyClaim"
    objects: {
      patientSubsidy: Prisma.$PatientSubsidyPayload<ExtArgs>
      scheme: Prisma.$SubsidySchemePayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientSubsidyId: number
      schemeId: number
      invoiceId: number | null
      claimDate: Date
      claimAmount: Prisma.Decimal
      approvedAmount: Prisma.Decimal | null
      rejectionReason: string | null
      claimStatus: string
      processedBy: number | null
      processedAt: Date | null
      reimbursementDate: Date | null
      transactionId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subsidyClaim"]>
    composites: {}
  }

  type SubsidyClaimGetPayload<S extends boolean | null | undefined | SubsidyClaimDefaultArgs> = $Result.GetResult<Prisma.$SubsidyClaimPayload, S>

  type SubsidyClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubsidyClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubsidyClaimCountAggregateInputType | true
    }

  export interface SubsidyClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubsidyClaim'], meta: { name: 'SubsidyClaim' } }
    /**
     * Find zero or one SubsidyClaim that matches the filter.
     * @param {SubsidyClaimFindUniqueArgs} args - Arguments to find a SubsidyClaim
     * @example
     * // Get one SubsidyClaim
     * const subsidyClaim = await prisma.subsidyClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubsidyClaimFindUniqueArgs>(args: SelectSubset<T, SubsidyClaimFindUniqueArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubsidyClaim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubsidyClaimFindUniqueOrThrowArgs} args - Arguments to find a SubsidyClaim
     * @example
     * // Get one SubsidyClaim
     * const subsidyClaim = await prisma.subsidyClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubsidyClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, SubsidyClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubsidyClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimFindFirstArgs} args - Arguments to find a SubsidyClaim
     * @example
     * // Get one SubsidyClaim
     * const subsidyClaim = await prisma.subsidyClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubsidyClaimFindFirstArgs>(args?: SelectSubset<T, SubsidyClaimFindFirstArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubsidyClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimFindFirstOrThrowArgs} args - Arguments to find a SubsidyClaim
     * @example
     * // Get one SubsidyClaim
     * const subsidyClaim = await prisma.subsidyClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubsidyClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, SubsidyClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubsidyClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubsidyClaims
     * const subsidyClaims = await prisma.subsidyClaim.findMany()
     * 
     * // Get first 10 SubsidyClaims
     * const subsidyClaims = await prisma.subsidyClaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subsidyClaimWithIdOnly = await prisma.subsidyClaim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubsidyClaimFindManyArgs>(args?: SelectSubset<T, SubsidyClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubsidyClaim.
     * @param {SubsidyClaimCreateArgs} args - Arguments to create a SubsidyClaim.
     * @example
     * // Create one SubsidyClaim
     * const SubsidyClaim = await prisma.subsidyClaim.create({
     *   data: {
     *     // ... data to create a SubsidyClaim
     *   }
     * })
     * 
     */
    create<T extends SubsidyClaimCreateArgs>(args: SelectSubset<T, SubsidyClaimCreateArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubsidyClaims.
     * @param {SubsidyClaimCreateManyArgs} args - Arguments to create many SubsidyClaims.
     * @example
     * // Create many SubsidyClaims
     * const subsidyClaim = await prisma.subsidyClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubsidyClaimCreateManyArgs>(args?: SelectSubset<T, SubsidyClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubsidyClaims and returns the data saved in the database.
     * @param {SubsidyClaimCreateManyAndReturnArgs} args - Arguments to create many SubsidyClaims.
     * @example
     * // Create many SubsidyClaims
     * const subsidyClaim = await prisma.subsidyClaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubsidyClaims and only return the `id`
     * const subsidyClaimWithIdOnly = await prisma.subsidyClaim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubsidyClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, SubsidyClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubsidyClaim.
     * @param {SubsidyClaimDeleteArgs} args - Arguments to delete one SubsidyClaim.
     * @example
     * // Delete one SubsidyClaim
     * const SubsidyClaim = await prisma.subsidyClaim.delete({
     *   where: {
     *     // ... filter to delete one SubsidyClaim
     *   }
     * })
     * 
     */
    delete<T extends SubsidyClaimDeleteArgs>(args: SelectSubset<T, SubsidyClaimDeleteArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubsidyClaim.
     * @param {SubsidyClaimUpdateArgs} args - Arguments to update one SubsidyClaim.
     * @example
     * // Update one SubsidyClaim
     * const subsidyClaim = await prisma.subsidyClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubsidyClaimUpdateArgs>(args: SelectSubset<T, SubsidyClaimUpdateArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubsidyClaims.
     * @param {SubsidyClaimDeleteManyArgs} args - Arguments to filter SubsidyClaims to delete.
     * @example
     * // Delete a few SubsidyClaims
     * const { count } = await prisma.subsidyClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubsidyClaimDeleteManyArgs>(args?: SelectSubset<T, SubsidyClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubsidyClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubsidyClaims
     * const subsidyClaim = await prisma.subsidyClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubsidyClaimUpdateManyArgs>(args: SelectSubset<T, SubsidyClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubsidyClaims and returns the data updated in the database.
     * @param {SubsidyClaimUpdateManyAndReturnArgs} args - Arguments to update many SubsidyClaims.
     * @example
     * // Update many SubsidyClaims
     * const subsidyClaim = await prisma.subsidyClaim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubsidyClaims and only return the `id`
     * const subsidyClaimWithIdOnly = await prisma.subsidyClaim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubsidyClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, SubsidyClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubsidyClaim.
     * @param {SubsidyClaimUpsertArgs} args - Arguments to update or create a SubsidyClaim.
     * @example
     * // Update or create a SubsidyClaim
     * const subsidyClaim = await prisma.subsidyClaim.upsert({
     *   create: {
     *     // ... data to create a SubsidyClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubsidyClaim we want to update
     *   }
     * })
     */
    upsert<T extends SubsidyClaimUpsertArgs>(args: SelectSubset<T, SubsidyClaimUpsertArgs<ExtArgs>>): Prisma__SubsidyClaimClient<$Result.GetResult<Prisma.$SubsidyClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubsidyClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimCountArgs} args - Arguments to filter SubsidyClaims to count.
     * @example
     * // Count the number of SubsidyClaims
     * const count = await prisma.subsidyClaim.count({
     *   where: {
     *     // ... the filter for the SubsidyClaims we want to count
     *   }
     * })
    **/
    count<T extends SubsidyClaimCountArgs>(
      args?: Subset<T, SubsidyClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubsidyClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubsidyClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubsidyClaimAggregateArgs>(args: Subset<T, SubsidyClaimAggregateArgs>): Prisma.PrismaPromise<GetSubsidyClaimAggregateType<T>>

    /**
     * Group by SubsidyClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubsidyClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubsidyClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubsidyClaimGroupByArgs['orderBy'] }
        : { orderBy?: SubsidyClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubsidyClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubsidyClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubsidyClaim model
   */
  readonly fields: SubsidyClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubsidyClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubsidyClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientSubsidy<T extends PatientSubsidyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientSubsidyDefaultArgs<ExtArgs>>): Prisma__PatientSubsidyClient<$Result.GetResult<Prisma.$PatientSubsidyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scheme<T extends SubsidySchemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubsidySchemeDefaultArgs<ExtArgs>>): Prisma__SubsidySchemeClient<$Result.GetResult<Prisma.$SubsidySchemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends SubsidyClaim$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, SubsidyClaim$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubsidyClaim model
   */
  interface SubsidyClaimFieldRefs {
    readonly id: FieldRef<"SubsidyClaim", 'Int'>
    readonly patientSubsidyId: FieldRef<"SubsidyClaim", 'Int'>
    readonly schemeId: FieldRef<"SubsidyClaim", 'Int'>
    readonly invoiceId: FieldRef<"SubsidyClaim", 'Int'>
    readonly claimDate: FieldRef<"SubsidyClaim", 'DateTime'>
    readonly claimAmount: FieldRef<"SubsidyClaim", 'Decimal'>
    readonly approvedAmount: FieldRef<"SubsidyClaim", 'Decimal'>
    readonly rejectionReason: FieldRef<"SubsidyClaim", 'String'>
    readonly claimStatus: FieldRef<"SubsidyClaim", 'String'>
    readonly processedBy: FieldRef<"SubsidyClaim", 'Int'>
    readonly processedAt: FieldRef<"SubsidyClaim", 'DateTime'>
    readonly reimbursementDate: FieldRef<"SubsidyClaim", 'DateTime'>
    readonly transactionId: FieldRef<"SubsidyClaim", 'String'>
    readonly notes: FieldRef<"SubsidyClaim", 'String'>
    readonly createdAt: FieldRef<"SubsidyClaim", 'DateTime'>
    readonly updatedAt: FieldRef<"SubsidyClaim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubsidyClaim findUnique
   */
  export type SubsidyClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyClaim to fetch.
     */
    where: SubsidyClaimWhereUniqueInput
  }

  /**
   * SubsidyClaim findUniqueOrThrow
   */
  export type SubsidyClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyClaim to fetch.
     */
    where: SubsidyClaimWhereUniqueInput
  }

  /**
   * SubsidyClaim findFirst
   */
  export type SubsidyClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyClaim to fetch.
     */
    where?: SubsidyClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidyClaims to fetch.
     */
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubsidyClaims.
     */
    cursor?: SubsidyClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidyClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidyClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubsidyClaims.
     */
    distinct?: SubsidyClaimScalarFieldEnum | SubsidyClaimScalarFieldEnum[]
  }

  /**
   * SubsidyClaim findFirstOrThrow
   */
  export type SubsidyClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyClaim to fetch.
     */
    where?: SubsidyClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidyClaims to fetch.
     */
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubsidyClaims.
     */
    cursor?: SubsidyClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidyClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidyClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubsidyClaims.
     */
    distinct?: SubsidyClaimScalarFieldEnum | SubsidyClaimScalarFieldEnum[]
  }

  /**
   * SubsidyClaim findMany
   */
  export type SubsidyClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * Filter, which SubsidyClaims to fetch.
     */
    where?: SubsidyClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubsidyClaims to fetch.
     */
    orderBy?: SubsidyClaimOrderByWithRelationInput | SubsidyClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubsidyClaims.
     */
    cursor?: SubsidyClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubsidyClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubsidyClaims.
     */
    skip?: number
    distinct?: SubsidyClaimScalarFieldEnum | SubsidyClaimScalarFieldEnum[]
  }

  /**
   * SubsidyClaim create
   */
  export type SubsidyClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a SubsidyClaim.
     */
    data: XOR<SubsidyClaimCreateInput, SubsidyClaimUncheckedCreateInput>
  }

  /**
   * SubsidyClaim createMany
   */
  export type SubsidyClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubsidyClaims.
     */
    data: SubsidyClaimCreateManyInput | SubsidyClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubsidyClaim createManyAndReturn
   */
  export type SubsidyClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * The data used to create many SubsidyClaims.
     */
    data: SubsidyClaimCreateManyInput | SubsidyClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubsidyClaim update
   */
  export type SubsidyClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a SubsidyClaim.
     */
    data: XOR<SubsidyClaimUpdateInput, SubsidyClaimUncheckedUpdateInput>
    /**
     * Choose, which SubsidyClaim to update.
     */
    where: SubsidyClaimWhereUniqueInput
  }

  /**
   * SubsidyClaim updateMany
   */
  export type SubsidyClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubsidyClaims.
     */
    data: XOR<SubsidyClaimUpdateManyMutationInput, SubsidyClaimUncheckedUpdateManyInput>
    /**
     * Filter which SubsidyClaims to update
     */
    where?: SubsidyClaimWhereInput
    /**
     * Limit how many SubsidyClaims to update.
     */
    limit?: number
  }

  /**
   * SubsidyClaim updateManyAndReturn
   */
  export type SubsidyClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * The data used to update SubsidyClaims.
     */
    data: XOR<SubsidyClaimUpdateManyMutationInput, SubsidyClaimUncheckedUpdateManyInput>
    /**
     * Filter which SubsidyClaims to update
     */
    where?: SubsidyClaimWhereInput
    /**
     * Limit how many SubsidyClaims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubsidyClaim upsert
   */
  export type SubsidyClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the SubsidyClaim to update in case it exists.
     */
    where: SubsidyClaimWhereUniqueInput
    /**
     * In case the SubsidyClaim found by the `where` argument doesn't exist, create a new SubsidyClaim with this data.
     */
    create: XOR<SubsidyClaimCreateInput, SubsidyClaimUncheckedCreateInput>
    /**
     * In case the SubsidyClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubsidyClaimUpdateInput, SubsidyClaimUncheckedUpdateInput>
  }

  /**
   * SubsidyClaim delete
   */
  export type SubsidyClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
    /**
     * Filter which SubsidyClaim to delete.
     */
    where: SubsidyClaimWhereUniqueInput
  }

  /**
   * SubsidyClaim deleteMany
   */
  export type SubsidyClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubsidyClaims to delete
     */
    where?: SubsidyClaimWhereInput
    /**
     * Limit how many SubsidyClaims to delete.
     */
    limit?: number
  }

  /**
   * SubsidyClaim.invoice
   */
  export type SubsidyClaim$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * SubsidyClaim without action
   */
  export type SubsidyClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubsidyClaim
     */
    select?: SubsidyClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubsidyClaim
     */
    omit?: SubsidyClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubsidyClaimInclude<ExtArgs> | null
  }


  /**
   * Model HousekeepingArea
   */

  export type AggregateHousekeepingArea = {
    _count: HousekeepingAreaCountAggregateOutputType | null
    _avg: HousekeepingAreaAvgAggregateOutputType | null
    _sum: HousekeepingAreaSumAggregateOutputType | null
    _min: HousekeepingAreaMinAggregateOutputType | null
    _max: HousekeepingAreaMaxAggregateOutputType | null
  }

  export type HousekeepingAreaAvgAggregateOutputType = {
    id: number | null
  }

  export type HousekeepingAreaSumAggregateOutputType = {
    id: number | null
  }

  export type HousekeepingAreaMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    floor: string | null
    buildingSection: string | null
    priority: string | null
    cleaningFrequency: string | null
    specialInstructions: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HousekeepingAreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    floor: string | null
    buildingSection: string | null
    priority: string | null
    cleaningFrequency: string | null
    specialInstructions: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HousekeepingAreaCountAggregateOutputType = {
    id: number
    name: number
    description: number
    floor: number
    buildingSection: number
    priority: number
    cleaningFrequency: number
    specialInstructions: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HousekeepingAreaAvgAggregateInputType = {
    id?: true
  }

  export type HousekeepingAreaSumAggregateInputType = {
    id?: true
  }

  export type HousekeepingAreaMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    floor?: true
    buildingSection?: true
    priority?: true
    cleaningFrequency?: true
    specialInstructions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HousekeepingAreaMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    floor?: true
    buildingSection?: true
    priority?: true
    cleaningFrequency?: true
    specialInstructions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HousekeepingAreaCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    floor?: true
    buildingSection?: true
    priority?: true
    cleaningFrequency?: true
    specialInstructions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HousekeepingAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HousekeepingArea to aggregate.
     */
    where?: HousekeepingAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingAreas to fetch.
     */
    orderBy?: HousekeepingAreaOrderByWithRelationInput | HousekeepingAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HousekeepingAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HousekeepingAreas
    **/
    _count?: true | HousekeepingAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HousekeepingAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HousekeepingAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HousekeepingAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HousekeepingAreaMaxAggregateInputType
  }

  export type GetHousekeepingAreaAggregateType<T extends HousekeepingAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateHousekeepingArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHousekeepingArea[P]>
      : GetScalarType<T[P], AggregateHousekeepingArea[P]>
  }




  export type HousekeepingAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HousekeepingAreaWhereInput
    orderBy?: HousekeepingAreaOrderByWithAggregationInput | HousekeepingAreaOrderByWithAggregationInput[]
    by: HousekeepingAreaScalarFieldEnum[] | HousekeepingAreaScalarFieldEnum
    having?: HousekeepingAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HousekeepingAreaCountAggregateInputType | true
    _avg?: HousekeepingAreaAvgAggregateInputType
    _sum?: HousekeepingAreaSumAggregateInputType
    _min?: HousekeepingAreaMinAggregateInputType
    _max?: HousekeepingAreaMaxAggregateInputType
  }

  export type HousekeepingAreaGroupByOutputType = {
    id: number
    name: string
    description: string | null
    floor: string | null
    buildingSection: string | null
    priority: string
    cleaningFrequency: string
    specialInstructions: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: HousekeepingAreaCountAggregateOutputType | null
    _avg: HousekeepingAreaAvgAggregateOutputType | null
    _sum: HousekeepingAreaSumAggregateOutputType | null
    _min: HousekeepingAreaMinAggregateOutputType | null
    _max: HousekeepingAreaMaxAggregateOutputType | null
  }

  type GetHousekeepingAreaGroupByPayload<T extends HousekeepingAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HousekeepingAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HousekeepingAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HousekeepingAreaGroupByOutputType[P]>
            : GetScalarType<T[P], HousekeepingAreaGroupByOutputType[P]>
        }
      >
    >


  export type HousekeepingAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    floor?: boolean
    buildingSection?: boolean
    priority?: boolean
    cleaningFrequency?: boolean
    specialInstructions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningTasks?: boolean | HousekeepingArea$cleaningTasksArgs<ExtArgs>
    _count?: boolean | HousekeepingAreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingArea"]>

  export type HousekeepingAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    floor?: boolean
    buildingSection?: boolean
    priority?: boolean
    cleaningFrequency?: boolean
    specialInstructions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["housekeepingArea"]>

  export type HousekeepingAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    floor?: boolean
    buildingSection?: boolean
    priority?: boolean
    cleaningFrequency?: boolean
    specialInstructions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["housekeepingArea"]>

  export type HousekeepingAreaSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    floor?: boolean
    buildingSection?: boolean
    priority?: boolean
    cleaningFrequency?: boolean
    specialInstructions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HousekeepingAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "floor" | "buildingSection" | "priority" | "cleaningFrequency" | "specialInstructions" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["housekeepingArea"]>
  export type HousekeepingAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningTasks?: boolean | HousekeepingArea$cleaningTasksArgs<ExtArgs>
    _count?: boolean | HousekeepingAreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HousekeepingAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HousekeepingAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HousekeepingAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HousekeepingArea"
    objects: {
      cleaningTasks: Prisma.$CleaningTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      floor: string | null
      buildingSection: string | null
      priority: string
      cleaningFrequency: string
      specialInstructions: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["housekeepingArea"]>
    composites: {}
  }

  type HousekeepingAreaGetPayload<S extends boolean | null | undefined | HousekeepingAreaDefaultArgs> = $Result.GetResult<Prisma.$HousekeepingAreaPayload, S>

  type HousekeepingAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HousekeepingAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HousekeepingAreaCountAggregateInputType | true
    }

  export interface HousekeepingAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HousekeepingArea'], meta: { name: 'HousekeepingArea' } }
    /**
     * Find zero or one HousekeepingArea that matches the filter.
     * @param {HousekeepingAreaFindUniqueArgs} args - Arguments to find a HousekeepingArea
     * @example
     * // Get one HousekeepingArea
     * const housekeepingArea = await prisma.housekeepingArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HousekeepingAreaFindUniqueArgs>(args: SelectSubset<T, HousekeepingAreaFindUniqueArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HousekeepingArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HousekeepingAreaFindUniqueOrThrowArgs} args - Arguments to find a HousekeepingArea
     * @example
     * // Get one HousekeepingArea
     * const housekeepingArea = await prisma.housekeepingArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HousekeepingAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, HousekeepingAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HousekeepingArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaFindFirstArgs} args - Arguments to find a HousekeepingArea
     * @example
     * // Get one HousekeepingArea
     * const housekeepingArea = await prisma.housekeepingArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HousekeepingAreaFindFirstArgs>(args?: SelectSubset<T, HousekeepingAreaFindFirstArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HousekeepingArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaFindFirstOrThrowArgs} args - Arguments to find a HousekeepingArea
     * @example
     * // Get one HousekeepingArea
     * const housekeepingArea = await prisma.housekeepingArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HousekeepingAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, HousekeepingAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HousekeepingAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HousekeepingAreas
     * const housekeepingAreas = await prisma.housekeepingArea.findMany()
     * 
     * // Get first 10 HousekeepingAreas
     * const housekeepingAreas = await prisma.housekeepingArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const housekeepingAreaWithIdOnly = await prisma.housekeepingArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HousekeepingAreaFindManyArgs>(args?: SelectSubset<T, HousekeepingAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HousekeepingArea.
     * @param {HousekeepingAreaCreateArgs} args - Arguments to create a HousekeepingArea.
     * @example
     * // Create one HousekeepingArea
     * const HousekeepingArea = await prisma.housekeepingArea.create({
     *   data: {
     *     // ... data to create a HousekeepingArea
     *   }
     * })
     * 
     */
    create<T extends HousekeepingAreaCreateArgs>(args: SelectSubset<T, HousekeepingAreaCreateArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HousekeepingAreas.
     * @param {HousekeepingAreaCreateManyArgs} args - Arguments to create many HousekeepingAreas.
     * @example
     * // Create many HousekeepingAreas
     * const housekeepingArea = await prisma.housekeepingArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HousekeepingAreaCreateManyArgs>(args?: SelectSubset<T, HousekeepingAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HousekeepingAreas and returns the data saved in the database.
     * @param {HousekeepingAreaCreateManyAndReturnArgs} args - Arguments to create many HousekeepingAreas.
     * @example
     * // Create many HousekeepingAreas
     * const housekeepingArea = await prisma.housekeepingArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HousekeepingAreas and only return the `id`
     * const housekeepingAreaWithIdOnly = await prisma.housekeepingArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HousekeepingAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, HousekeepingAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HousekeepingArea.
     * @param {HousekeepingAreaDeleteArgs} args - Arguments to delete one HousekeepingArea.
     * @example
     * // Delete one HousekeepingArea
     * const HousekeepingArea = await prisma.housekeepingArea.delete({
     *   where: {
     *     // ... filter to delete one HousekeepingArea
     *   }
     * })
     * 
     */
    delete<T extends HousekeepingAreaDeleteArgs>(args: SelectSubset<T, HousekeepingAreaDeleteArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HousekeepingArea.
     * @param {HousekeepingAreaUpdateArgs} args - Arguments to update one HousekeepingArea.
     * @example
     * // Update one HousekeepingArea
     * const housekeepingArea = await prisma.housekeepingArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HousekeepingAreaUpdateArgs>(args: SelectSubset<T, HousekeepingAreaUpdateArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HousekeepingAreas.
     * @param {HousekeepingAreaDeleteManyArgs} args - Arguments to filter HousekeepingAreas to delete.
     * @example
     * // Delete a few HousekeepingAreas
     * const { count } = await prisma.housekeepingArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HousekeepingAreaDeleteManyArgs>(args?: SelectSubset<T, HousekeepingAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HousekeepingAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HousekeepingAreas
     * const housekeepingArea = await prisma.housekeepingArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HousekeepingAreaUpdateManyArgs>(args: SelectSubset<T, HousekeepingAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HousekeepingAreas and returns the data updated in the database.
     * @param {HousekeepingAreaUpdateManyAndReturnArgs} args - Arguments to update many HousekeepingAreas.
     * @example
     * // Update many HousekeepingAreas
     * const housekeepingArea = await prisma.housekeepingArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HousekeepingAreas and only return the `id`
     * const housekeepingAreaWithIdOnly = await prisma.housekeepingArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HousekeepingAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, HousekeepingAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HousekeepingArea.
     * @param {HousekeepingAreaUpsertArgs} args - Arguments to update or create a HousekeepingArea.
     * @example
     * // Update or create a HousekeepingArea
     * const housekeepingArea = await prisma.housekeepingArea.upsert({
     *   create: {
     *     // ... data to create a HousekeepingArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HousekeepingArea we want to update
     *   }
     * })
     */
    upsert<T extends HousekeepingAreaUpsertArgs>(args: SelectSubset<T, HousekeepingAreaUpsertArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HousekeepingAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaCountArgs} args - Arguments to filter HousekeepingAreas to count.
     * @example
     * // Count the number of HousekeepingAreas
     * const count = await prisma.housekeepingArea.count({
     *   where: {
     *     // ... the filter for the HousekeepingAreas we want to count
     *   }
     * })
    **/
    count<T extends HousekeepingAreaCountArgs>(
      args?: Subset<T, HousekeepingAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HousekeepingAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HousekeepingArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HousekeepingAreaAggregateArgs>(args: Subset<T, HousekeepingAreaAggregateArgs>): Prisma.PrismaPromise<GetHousekeepingAreaAggregateType<T>>

    /**
     * Group by HousekeepingArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HousekeepingAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HousekeepingAreaGroupByArgs['orderBy'] }
        : { orderBy?: HousekeepingAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HousekeepingAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHousekeepingAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HousekeepingArea model
   */
  readonly fields: HousekeepingAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HousekeepingArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HousekeepingAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningTasks<T extends HousekeepingArea$cleaningTasksArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingArea$cleaningTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HousekeepingArea model
   */
  interface HousekeepingAreaFieldRefs {
    readonly id: FieldRef<"HousekeepingArea", 'Int'>
    readonly name: FieldRef<"HousekeepingArea", 'String'>
    readonly description: FieldRef<"HousekeepingArea", 'String'>
    readonly floor: FieldRef<"HousekeepingArea", 'String'>
    readonly buildingSection: FieldRef<"HousekeepingArea", 'String'>
    readonly priority: FieldRef<"HousekeepingArea", 'String'>
    readonly cleaningFrequency: FieldRef<"HousekeepingArea", 'String'>
    readonly specialInstructions: FieldRef<"HousekeepingArea", 'String'>
    readonly status: FieldRef<"HousekeepingArea", 'String'>
    readonly createdAt: FieldRef<"HousekeepingArea", 'DateTime'>
    readonly updatedAt: FieldRef<"HousekeepingArea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HousekeepingArea findUnique
   */
  export type HousekeepingAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingArea to fetch.
     */
    where: HousekeepingAreaWhereUniqueInput
  }

  /**
   * HousekeepingArea findUniqueOrThrow
   */
  export type HousekeepingAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingArea to fetch.
     */
    where: HousekeepingAreaWhereUniqueInput
  }

  /**
   * HousekeepingArea findFirst
   */
  export type HousekeepingAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingArea to fetch.
     */
    where?: HousekeepingAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingAreas to fetch.
     */
    orderBy?: HousekeepingAreaOrderByWithRelationInput | HousekeepingAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HousekeepingAreas.
     */
    cursor?: HousekeepingAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HousekeepingAreas.
     */
    distinct?: HousekeepingAreaScalarFieldEnum | HousekeepingAreaScalarFieldEnum[]
  }

  /**
   * HousekeepingArea findFirstOrThrow
   */
  export type HousekeepingAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingArea to fetch.
     */
    where?: HousekeepingAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingAreas to fetch.
     */
    orderBy?: HousekeepingAreaOrderByWithRelationInput | HousekeepingAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HousekeepingAreas.
     */
    cursor?: HousekeepingAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HousekeepingAreas.
     */
    distinct?: HousekeepingAreaScalarFieldEnum | HousekeepingAreaScalarFieldEnum[]
  }

  /**
   * HousekeepingArea findMany
   */
  export type HousekeepingAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingAreas to fetch.
     */
    where?: HousekeepingAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingAreas to fetch.
     */
    orderBy?: HousekeepingAreaOrderByWithRelationInput | HousekeepingAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HousekeepingAreas.
     */
    cursor?: HousekeepingAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingAreas.
     */
    skip?: number
    distinct?: HousekeepingAreaScalarFieldEnum | HousekeepingAreaScalarFieldEnum[]
  }

  /**
   * HousekeepingArea create
   */
  export type HousekeepingAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a HousekeepingArea.
     */
    data: XOR<HousekeepingAreaCreateInput, HousekeepingAreaUncheckedCreateInput>
  }

  /**
   * HousekeepingArea createMany
   */
  export type HousekeepingAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HousekeepingAreas.
     */
    data: HousekeepingAreaCreateManyInput | HousekeepingAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HousekeepingArea createManyAndReturn
   */
  export type HousekeepingAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * The data used to create many HousekeepingAreas.
     */
    data: HousekeepingAreaCreateManyInput | HousekeepingAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HousekeepingArea update
   */
  export type HousekeepingAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a HousekeepingArea.
     */
    data: XOR<HousekeepingAreaUpdateInput, HousekeepingAreaUncheckedUpdateInput>
    /**
     * Choose, which HousekeepingArea to update.
     */
    where: HousekeepingAreaWhereUniqueInput
  }

  /**
   * HousekeepingArea updateMany
   */
  export type HousekeepingAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HousekeepingAreas.
     */
    data: XOR<HousekeepingAreaUpdateManyMutationInput, HousekeepingAreaUncheckedUpdateManyInput>
    /**
     * Filter which HousekeepingAreas to update
     */
    where?: HousekeepingAreaWhereInput
    /**
     * Limit how many HousekeepingAreas to update.
     */
    limit?: number
  }

  /**
   * HousekeepingArea updateManyAndReturn
   */
  export type HousekeepingAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * The data used to update HousekeepingAreas.
     */
    data: XOR<HousekeepingAreaUpdateManyMutationInput, HousekeepingAreaUncheckedUpdateManyInput>
    /**
     * Filter which HousekeepingAreas to update
     */
    where?: HousekeepingAreaWhereInput
    /**
     * Limit how many HousekeepingAreas to update.
     */
    limit?: number
  }

  /**
   * HousekeepingArea upsert
   */
  export type HousekeepingAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the HousekeepingArea to update in case it exists.
     */
    where: HousekeepingAreaWhereUniqueInput
    /**
     * In case the HousekeepingArea found by the `where` argument doesn't exist, create a new HousekeepingArea with this data.
     */
    create: XOR<HousekeepingAreaCreateInput, HousekeepingAreaUncheckedCreateInput>
    /**
     * In case the HousekeepingArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HousekeepingAreaUpdateInput, HousekeepingAreaUncheckedUpdateInput>
  }

  /**
   * HousekeepingArea delete
   */
  export type HousekeepingAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
    /**
     * Filter which HousekeepingArea to delete.
     */
    where: HousekeepingAreaWhereUniqueInput
  }

  /**
   * HousekeepingArea deleteMany
   */
  export type HousekeepingAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HousekeepingAreas to delete
     */
    where?: HousekeepingAreaWhereInput
    /**
     * Limit how many HousekeepingAreas to delete.
     */
    limit?: number
  }

  /**
   * HousekeepingArea.cleaningTasks
   */
  export type HousekeepingArea$cleaningTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    where?: CleaningTaskWhereInput
    orderBy?: CleaningTaskOrderByWithRelationInput | CleaningTaskOrderByWithRelationInput[]
    cursor?: CleaningTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningTaskScalarFieldEnum | CleaningTaskScalarFieldEnum[]
  }

  /**
   * HousekeepingArea without action
   */
  export type HousekeepingAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingArea
     */
    select?: HousekeepingAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingArea
     */
    omit?: HousekeepingAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingAreaInclude<ExtArgs> | null
  }


  /**
   * Model HousekeepingStaff
   */

  export type AggregateHousekeepingStaff = {
    _count: HousekeepingStaffCountAggregateOutputType | null
    _avg: HousekeepingStaffAvgAggregateOutputType | null
    _sum: HousekeepingStaffSumAggregateOutputType | null
    _min: HousekeepingStaffMinAggregateOutputType | null
    _max: HousekeepingStaffMaxAggregateOutputType | null
  }

  export type HousekeepingStaffAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type HousekeepingStaffSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type HousekeepingStaffMinAggregateOutputType = {
    id: number | null
    userId: number | null
    staffId: string | null
    supervisor: boolean | null
    specializedAreas: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HousekeepingStaffMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    staffId: string | null
    supervisor: boolean | null
    specializedAreas: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HousekeepingStaffCountAggregateOutputType = {
    id: number
    userId: number
    staffId: number
    supervisor: number
    specializedAreas: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HousekeepingStaffAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HousekeepingStaffSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HousekeepingStaffMinAggregateInputType = {
    id?: true
    userId?: true
    staffId?: true
    supervisor?: true
    specializedAreas?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HousekeepingStaffMaxAggregateInputType = {
    id?: true
    userId?: true
    staffId?: true
    supervisor?: true
    specializedAreas?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HousekeepingStaffCountAggregateInputType = {
    id?: true
    userId?: true
    staffId?: true
    supervisor?: true
    specializedAreas?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HousekeepingStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HousekeepingStaff to aggregate.
     */
    where?: HousekeepingStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingStaffs to fetch.
     */
    orderBy?: HousekeepingStaffOrderByWithRelationInput | HousekeepingStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HousekeepingStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HousekeepingStaffs
    **/
    _count?: true | HousekeepingStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HousekeepingStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HousekeepingStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HousekeepingStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HousekeepingStaffMaxAggregateInputType
  }

  export type GetHousekeepingStaffAggregateType<T extends HousekeepingStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateHousekeepingStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHousekeepingStaff[P]>
      : GetScalarType<T[P], AggregateHousekeepingStaff[P]>
  }




  export type HousekeepingStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HousekeepingStaffWhereInput
    orderBy?: HousekeepingStaffOrderByWithAggregationInput | HousekeepingStaffOrderByWithAggregationInput[]
    by: HousekeepingStaffScalarFieldEnum[] | HousekeepingStaffScalarFieldEnum
    having?: HousekeepingStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HousekeepingStaffCountAggregateInputType | true
    _avg?: HousekeepingStaffAvgAggregateInputType
    _sum?: HousekeepingStaffSumAggregateInputType
    _min?: HousekeepingStaffMinAggregateInputType
    _max?: HousekeepingStaffMaxAggregateInputType
  }

  export type HousekeepingStaffGroupByOutputType = {
    id: number
    userId: number
    staffId: string
    supervisor: boolean
    specializedAreas: string | null
    createdAt: Date
    updatedAt: Date
    _count: HousekeepingStaffCountAggregateOutputType | null
    _avg: HousekeepingStaffAvgAggregateOutputType | null
    _sum: HousekeepingStaffSumAggregateOutputType | null
    _min: HousekeepingStaffMinAggregateOutputType | null
    _max: HousekeepingStaffMaxAggregateOutputType | null
  }

  type GetHousekeepingStaffGroupByPayload<T extends HousekeepingStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HousekeepingStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HousekeepingStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HousekeepingStaffGroupByOutputType[P]>
            : GetScalarType<T[P], HousekeepingStaffGroupByOutputType[P]>
        }
      >
    >


  export type HousekeepingStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffId?: boolean
    supervisor?: boolean
    specializedAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cleaningTasks?: boolean | HousekeepingStaff$cleaningTasksArgs<ExtArgs>
    cleaningVerifications?: boolean | HousekeepingStaff$cleaningVerificationsArgs<ExtArgs>
    supplyRequests?: boolean | HousekeepingStaff$supplyRequestsArgs<ExtArgs>
    _count?: boolean | HousekeepingStaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingStaff"]>

  export type HousekeepingStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffId?: boolean
    supervisor?: boolean
    specializedAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingStaff"]>

  export type HousekeepingStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffId?: boolean
    supervisor?: boolean
    specializedAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingStaff"]>

  export type HousekeepingStaffSelectScalar = {
    id?: boolean
    userId?: boolean
    staffId?: boolean
    supervisor?: boolean
    specializedAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HousekeepingStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "staffId" | "supervisor" | "specializedAreas" | "createdAt" | "updatedAt", ExtArgs["result"]["housekeepingStaff"]>
  export type HousekeepingStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cleaningTasks?: boolean | HousekeepingStaff$cleaningTasksArgs<ExtArgs>
    cleaningVerifications?: boolean | HousekeepingStaff$cleaningVerificationsArgs<ExtArgs>
    supplyRequests?: boolean | HousekeepingStaff$supplyRequestsArgs<ExtArgs>
    _count?: boolean | HousekeepingStaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HousekeepingStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HousekeepingStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HousekeepingStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HousekeepingStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cleaningTasks: Prisma.$CleaningTaskPayload<ExtArgs>[]
      cleaningVerifications: Prisma.$CleaningVerificationPayload<ExtArgs>[]
      supplyRequests: Prisma.$CleaningSupplyRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      staffId: string
      supervisor: boolean
      specializedAreas: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["housekeepingStaff"]>
    composites: {}
  }

  type HousekeepingStaffGetPayload<S extends boolean | null | undefined | HousekeepingStaffDefaultArgs> = $Result.GetResult<Prisma.$HousekeepingStaffPayload, S>

  type HousekeepingStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HousekeepingStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HousekeepingStaffCountAggregateInputType | true
    }

  export interface HousekeepingStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HousekeepingStaff'], meta: { name: 'HousekeepingStaff' } }
    /**
     * Find zero or one HousekeepingStaff that matches the filter.
     * @param {HousekeepingStaffFindUniqueArgs} args - Arguments to find a HousekeepingStaff
     * @example
     * // Get one HousekeepingStaff
     * const housekeepingStaff = await prisma.housekeepingStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HousekeepingStaffFindUniqueArgs>(args: SelectSubset<T, HousekeepingStaffFindUniqueArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HousekeepingStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HousekeepingStaffFindUniqueOrThrowArgs} args - Arguments to find a HousekeepingStaff
     * @example
     * // Get one HousekeepingStaff
     * const housekeepingStaff = await prisma.housekeepingStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HousekeepingStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, HousekeepingStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HousekeepingStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffFindFirstArgs} args - Arguments to find a HousekeepingStaff
     * @example
     * // Get one HousekeepingStaff
     * const housekeepingStaff = await prisma.housekeepingStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HousekeepingStaffFindFirstArgs>(args?: SelectSubset<T, HousekeepingStaffFindFirstArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HousekeepingStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffFindFirstOrThrowArgs} args - Arguments to find a HousekeepingStaff
     * @example
     * // Get one HousekeepingStaff
     * const housekeepingStaff = await prisma.housekeepingStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HousekeepingStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, HousekeepingStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HousekeepingStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HousekeepingStaffs
     * const housekeepingStaffs = await prisma.housekeepingStaff.findMany()
     * 
     * // Get first 10 HousekeepingStaffs
     * const housekeepingStaffs = await prisma.housekeepingStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const housekeepingStaffWithIdOnly = await prisma.housekeepingStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HousekeepingStaffFindManyArgs>(args?: SelectSubset<T, HousekeepingStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HousekeepingStaff.
     * @param {HousekeepingStaffCreateArgs} args - Arguments to create a HousekeepingStaff.
     * @example
     * // Create one HousekeepingStaff
     * const HousekeepingStaff = await prisma.housekeepingStaff.create({
     *   data: {
     *     // ... data to create a HousekeepingStaff
     *   }
     * })
     * 
     */
    create<T extends HousekeepingStaffCreateArgs>(args: SelectSubset<T, HousekeepingStaffCreateArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HousekeepingStaffs.
     * @param {HousekeepingStaffCreateManyArgs} args - Arguments to create many HousekeepingStaffs.
     * @example
     * // Create many HousekeepingStaffs
     * const housekeepingStaff = await prisma.housekeepingStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HousekeepingStaffCreateManyArgs>(args?: SelectSubset<T, HousekeepingStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HousekeepingStaffs and returns the data saved in the database.
     * @param {HousekeepingStaffCreateManyAndReturnArgs} args - Arguments to create many HousekeepingStaffs.
     * @example
     * // Create many HousekeepingStaffs
     * const housekeepingStaff = await prisma.housekeepingStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HousekeepingStaffs and only return the `id`
     * const housekeepingStaffWithIdOnly = await prisma.housekeepingStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HousekeepingStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, HousekeepingStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HousekeepingStaff.
     * @param {HousekeepingStaffDeleteArgs} args - Arguments to delete one HousekeepingStaff.
     * @example
     * // Delete one HousekeepingStaff
     * const HousekeepingStaff = await prisma.housekeepingStaff.delete({
     *   where: {
     *     // ... filter to delete one HousekeepingStaff
     *   }
     * })
     * 
     */
    delete<T extends HousekeepingStaffDeleteArgs>(args: SelectSubset<T, HousekeepingStaffDeleteArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HousekeepingStaff.
     * @param {HousekeepingStaffUpdateArgs} args - Arguments to update one HousekeepingStaff.
     * @example
     * // Update one HousekeepingStaff
     * const housekeepingStaff = await prisma.housekeepingStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HousekeepingStaffUpdateArgs>(args: SelectSubset<T, HousekeepingStaffUpdateArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HousekeepingStaffs.
     * @param {HousekeepingStaffDeleteManyArgs} args - Arguments to filter HousekeepingStaffs to delete.
     * @example
     * // Delete a few HousekeepingStaffs
     * const { count } = await prisma.housekeepingStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HousekeepingStaffDeleteManyArgs>(args?: SelectSubset<T, HousekeepingStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HousekeepingStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HousekeepingStaffs
     * const housekeepingStaff = await prisma.housekeepingStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HousekeepingStaffUpdateManyArgs>(args: SelectSubset<T, HousekeepingStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HousekeepingStaffs and returns the data updated in the database.
     * @param {HousekeepingStaffUpdateManyAndReturnArgs} args - Arguments to update many HousekeepingStaffs.
     * @example
     * // Update many HousekeepingStaffs
     * const housekeepingStaff = await prisma.housekeepingStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HousekeepingStaffs and only return the `id`
     * const housekeepingStaffWithIdOnly = await prisma.housekeepingStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HousekeepingStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, HousekeepingStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HousekeepingStaff.
     * @param {HousekeepingStaffUpsertArgs} args - Arguments to update or create a HousekeepingStaff.
     * @example
     * // Update or create a HousekeepingStaff
     * const housekeepingStaff = await prisma.housekeepingStaff.upsert({
     *   create: {
     *     // ... data to create a HousekeepingStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HousekeepingStaff we want to update
     *   }
     * })
     */
    upsert<T extends HousekeepingStaffUpsertArgs>(args: SelectSubset<T, HousekeepingStaffUpsertArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HousekeepingStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffCountArgs} args - Arguments to filter HousekeepingStaffs to count.
     * @example
     * // Count the number of HousekeepingStaffs
     * const count = await prisma.housekeepingStaff.count({
     *   where: {
     *     // ... the filter for the HousekeepingStaffs we want to count
     *   }
     * })
    **/
    count<T extends HousekeepingStaffCountArgs>(
      args?: Subset<T, HousekeepingStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HousekeepingStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HousekeepingStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HousekeepingStaffAggregateArgs>(args: Subset<T, HousekeepingStaffAggregateArgs>): Prisma.PrismaPromise<GetHousekeepingStaffAggregateType<T>>

    /**
     * Group by HousekeepingStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HousekeepingStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HousekeepingStaffGroupByArgs['orderBy'] }
        : { orderBy?: HousekeepingStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HousekeepingStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHousekeepingStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HousekeepingStaff model
   */
  readonly fields: HousekeepingStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HousekeepingStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HousekeepingStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cleaningTasks<T extends HousekeepingStaff$cleaningTasksArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingStaff$cleaningTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningVerifications<T extends HousekeepingStaff$cleaningVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingStaff$cleaningVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplyRequests<T extends HousekeepingStaff$supplyRequestsArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingStaff$supplyRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HousekeepingStaff model
   */
  interface HousekeepingStaffFieldRefs {
    readonly id: FieldRef<"HousekeepingStaff", 'Int'>
    readonly userId: FieldRef<"HousekeepingStaff", 'Int'>
    readonly staffId: FieldRef<"HousekeepingStaff", 'String'>
    readonly supervisor: FieldRef<"HousekeepingStaff", 'Boolean'>
    readonly specializedAreas: FieldRef<"HousekeepingStaff", 'String'>
    readonly createdAt: FieldRef<"HousekeepingStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"HousekeepingStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HousekeepingStaff findUnique
   */
  export type HousekeepingStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingStaff to fetch.
     */
    where: HousekeepingStaffWhereUniqueInput
  }

  /**
   * HousekeepingStaff findUniqueOrThrow
   */
  export type HousekeepingStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingStaff to fetch.
     */
    where: HousekeepingStaffWhereUniqueInput
  }

  /**
   * HousekeepingStaff findFirst
   */
  export type HousekeepingStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingStaff to fetch.
     */
    where?: HousekeepingStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingStaffs to fetch.
     */
    orderBy?: HousekeepingStaffOrderByWithRelationInput | HousekeepingStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HousekeepingStaffs.
     */
    cursor?: HousekeepingStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HousekeepingStaffs.
     */
    distinct?: HousekeepingStaffScalarFieldEnum | HousekeepingStaffScalarFieldEnum[]
  }

  /**
   * HousekeepingStaff findFirstOrThrow
   */
  export type HousekeepingStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingStaff to fetch.
     */
    where?: HousekeepingStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingStaffs to fetch.
     */
    orderBy?: HousekeepingStaffOrderByWithRelationInput | HousekeepingStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HousekeepingStaffs.
     */
    cursor?: HousekeepingStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HousekeepingStaffs.
     */
    distinct?: HousekeepingStaffScalarFieldEnum | HousekeepingStaffScalarFieldEnum[]
  }

  /**
   * HousekeepingStaff findMany
   */
  export type HousekeepingStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingStaffs to fetch.
     */
    where?: HousekeepingStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingStaffs to fetch.
     */
    orderBy?: HousekeepingStaffOrderByWithRelationInput | HousekeepingStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HousekeepingStaffs.
     */
    cursor?: HousekeepingStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingStaffs.
     */
    skip?: number
    distinct?: HousekeepingStaffScalarFieldEnum | HousekeepingStaffScalarFieldEnum[]
  }

  /**
   * HousekeepingStaff create
   */
  export type HousekeepingStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a HousekeepingStaff.
     */
    data: XOR<HousekeepingStaffCreateInput, HousekeepingStaffUncheckedCreateInput>
  }

  /**
   * HousekeepingStaff createMany
   */
  export type HousekeepingStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HousekeepingStaffs.
     */
    data: HousekeepingStaffCreateManyInput | HousekeepingStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HousekeepingStaff createManyAndReturn
   */
  export type HousekeepingStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * The data used to create many HousekeepingStaffs.
     */
    data: HousekeepingStaffCreateManyInput | HousekeepingStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HousekeepingStaff update
   */
  export type HousekeepingStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a HousekeepingStaff.
     */
    data: XOR<HousekeepingStaffUpdateInput, HousekeepingStaffUncheckedUpdateInput>
    /**
     * Choose, which HousekeepingStaff to update.
     */
    where: HousekeepingStaffWhereUniqueInput
  }

  /**
   * HousekeepingStaff updateMany
   */
  export type HousekeepingStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HousekeepingStaffs.
     */
    data: XOR<HousekeepingStaffUpdateManyMutationInput, HousekeepingStaffUncheckedUpdateManyInput>
    /**
     * Filter which HousekeepingStaffs to update
     */
    where?: HousekeepingStaffWhereInput
    /**
     * Limit how many HousekeepingStaffs to update.
     */
    limit?: number
  }

  /**
   * HousekeepingStaff updateManyAndReturn
   */
  export type HousekeepingStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * The data used to update HousekeepingStaffs.
     */
    data: XOR<HousekeepingStaffUpdateManyMutationInput, HousekeepingStaffUncheckedUpdateManyInput>
    /**
     * Filter which HousekeepingStaffs to update
     */
    where?: HousekeepingStaffWhereInput
    /**
     * Limit how many HousekeepingStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HousekeepingStaff upsert
   */
  export type HousekeepingStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the HousekeepingStaff to update in case it exists.
     */
    where: HousekeepingStaffWhereUniqueInput
    /**
     * In case the HousekeepingStaff found by the `where` argument doesn't exist, create a new HousekeepingStaff with this data.
     */
    create: XOR<HousekeepingStaffCreateInput, HousekeepingStaffUncheckedCreateInput>
    /**
     * In case the HousekeepingStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HousekeepingStaffUpdateInput, HousekeepingStaffUncheckedUpdateInput>
  }

  /**
   * HousekeepingStaff delete
   */
  export type HousekeepingStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    /**
     * Filter which HousekeepingStaff to delete.
     */
    where: HousekeepingStaffWhereUniqueInput
  }

  /**
   * HousekeepingStaff deleteMany
   */
  export type HousekeepingStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HousekeepingStaffs to delete
     */
    where?: HousekeepingStaffWhereInput
    /**
     * Limit how many HousekeepingStaffs to delete.
     */
    limit?: number
  }

  /**
   * HousekeepingStaff.cleaningTasks
   */
  export type HousekeepingStaff$cleaningTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    where?: CleaningTaskWhereInput
    orderBy?: CleaningTaskOrderByWithRelationInput | CleaningTaskOrderByWithRelationInput[]
    cursor?: CleaningTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningTaskScalarFieldEnum | CleaningTaskScalarFieldEnum[]
  }

  /**
   * HousekeepingStaff.cleaningVerifications
   */
  export type HousekeepingStaff$cleaningVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    where?: CleaningVerificationWhereInput
    orderBy?: CleaningVerificationOrderByWithRelationInput | CleaningVerificationOrderByWithRelationInput[]
    cursor?: CleaningVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningVerificationScalarFieldEnum | CleaningVerificationScalarFieldEnum[]
  }

  /**
   * HousekeepingStaff.supplyRequests
   */
  export type HousekeepingStaff$supplyRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    where?: CleaningSupplyRequestWhereInput
    orderBy?: CleaningSupplyRequestOrderByWithRelationInput | CleaningSupplyRequestOrderByWithRelationInput[]
    cursor?: CleaningSupplyRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSupplyRequestScalarFieldEnum | CleaningSupplyRequestScalarFieldEnum[]
  }

  /**
   * HousekeepingStaff without action
   */
  export type HousekeepingStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
  }


  /**
   * Model CleaningTask
   */

  export type AggregateCleaningTask = {
    _count: CleaningTaskCountAggregateOutputType | null
    _avg: CleaningTaskAvgAggregateOutputType | null
    _sum: CleaningTaskSumAggregateOutputType | null
    _min: CleaningTaskMinAggregateOutputType | null
    _max: CleaningTaskMaxAggregateOutputType | null
  }

  export type CleaningTaskAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
    assignedToId: number | null
    estimatedDuration: number | null
  }

  export type CleaningTaskSumAggregateOutputType = {
    id: number | null
    areaId: number | null
    assignedToId: number | null
    estimatedDuration: number | null
  }

  export type CleaningTaskMinAggregateOutputType = {
    id: number | null
    areaId: number | null
    assignedToId: number | null
    scheduledDate: Date | null
    scheduledTime: string | null
    estimatedDuration: number | null
    priority: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningTaskMaxAggregateOutputType = {
    id: number | null
    areaId: number | null
    assignedToId: number | null
    scheduledDate: Date | null
    scheduledTime: string | null
    estimatedDuration: number | null
    priority: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningTaskCountAggregateOutputType = {
    id: number
    areaId: number
    assignedToId: number
    scheduledDate: number
    scheduledTime: number
    estimatedDuration: number
    priority: number
    status: number
    startedAt: number
    completedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningTaskAvgAggregateInputType = {
    id?: true
    areaId?: true
    assignedToId?: true
    estimatedDuration?: true
  }

  export type CleaningTaskSumAggregateInputType = {
    id?: true
    areaId?: true
    assignedToId?: true
    estimatedDuration?: true
  }

  export type CleaningTaskMinAggregateInputType = {
    id?: true
    areaId?: true
    assignedToId?: true
    scheduledDate?: true
    scheduledTime?: true
    estimatedDuration?: true
    priority?: true
    status?: true
    startedAt?: true
    completedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningTaskMaxAggregateInputType = {
    id?: true
    areaId?: true
    assignedToId?: true
    scheduledDate?: true
    scheduledTime?: true
    estimatedDuration?: true
    priority?: true
    status?: true
    startedAt?: true
    completedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningTaskCountAggregateInputType = {
    id?: true
    areaId?: true
    assignedToId?: true
    scheduledDate?: true
    scheduledTime?: true
    estimatedDuration?: true
    priority?: true
    status?: true
    startedAt?: true
    completedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningTask to aggregate.
     */
    where?: CleaningTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningTasks to fetch.
     */
    orderBy?: CleaningTaskOrderByWithRelationInput | CleaningTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningTasks
    **/
    _count?: true | CleaningTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningTaskMaxAggregateInputType
  }

  export type GetCleaningTaskAggregateType<T extends CleaningTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningTask[P]>
      : GetScalarType<T[P], AggregateCleaningTask[P]>
  }




  export type CleaningTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningTaskWhereInput
    orderBy?: CleaningTaskOrderByWithAggregationInput | CleaningTaskOrderByWithAggregationInput[]
    by: CleaningTaskScalarFieldEnum[] | CleaningTaskScalarFieldEnum
    having?: CleaningTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningTaskCountAggregateInputType | true
    _avg?: CleaningTaskAvgAggregateInputType
    _sum?: CleaningTaskSumAggregateInputType
    _min?: CleaningTaskMinAggregateInputType
    _max?: CleaningTaskMaxAggregateInputType
  }

  export type CleaningTaskGroupByOutputType = {
    id: number
    areaId: number
    assignedToId: number | null
    scheduledDate: Date
    scheduledTime: string
    estimatedDuration: number
    priority: string
    status: string
    startedAt: Date | null
    completedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CleaningTaskCountAggregateOutputType | null
    _avg: CleaningTaskAvgAggregateOutputType | null
    _sum: CleaningTaskSumAggregateOutputType | null
    _min: CleaningTaskMinAggregateOutputType | null
    _max: CleaningTaskMaxAggregateOutputType | null
  }

  type GetCleaningTaskGroupByPayload<T extends CleaningTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningTaskGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningTaskGroupByOutputType[P]>
        }
      >
    >


  export type CleaningTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    areaId?: boolean
    assignedToId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    area?: boolean | HousekeepingAreaDefaultArgs<ExtArgs>
    assignedTo?: boolean | CleaningTask$assignedToArgs<ExtArgs>
    verifications?: boolean | CleaningTask$verificationsArgs<ExtArgs>
    _count?: boolean | CleaningTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningTask"]>

  export type CleaningTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    areaId?: boolean
    assignedToId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    area?: boolean | HousekeepingAreaDefaultArgs<ExtArgs>
    assignedTo?: boolean | CleaningTask$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningTask"]>

  export type CleaningTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    areaId?: boolean
    assignedToId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    area?: boolean | HousekeepingAreaDefaultArgs<ExtArgs>
    assignedTo?: boolean | CleaningTask$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningTask"]>

  export type CleaningTaskSelectScalar = {
    id?: boolean
    areaId?: boolean
    assignedToId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "areaId" | "assignedToId" | "scheduledDate" | "scheduledTime" | "estimatedDuration" | "priority" | "status" | "startedAt" | "completedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningTask"]>
  export type CleaningTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | HousekeepingAreaDefaultArgs<ExtArgs>
    assignedTo?: boolean | CleaningTask$assignedToArgs<ExtArgs>
    verifications?: boolean | CleaningTask$verificationsArgs<ExtArgs>
    _count?: boolean | CleaningTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | HousekeepingAreaDefaultArgs<ExtArgs>
    assignedTo?: boolean | CleaningTask$assignedToArgs<ExtArgs>
  }
  export type CleaningTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | HousekeepingAreaDefaultArgs<ExtArgs>
    assignedTo?: boolean | CleaningTask$assignedToArgs<ExtArgs>
  }

  export type $CleaningTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningTask"
    objects: {
      area: Prisma.$HousekeepingAreaPayload<ExtArgs>
      assignedTo: Prisma.$HousekeepingStaffPayload<ExtArgs> | null
      verifications: Prisma.$CleaningVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      areaId: number
      assignedToId: number | null
      scheduledDate: Date
      scheduledTime: string
      estimatedDuration: number
      priority: string
      status: string
      startedAt: Date | null
      completedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningTask"]>
    composites: {}
  }

  type CleaningTaskGetPayload<S extends boolean | null | undefined | CleaningTaskDefaultArgs> = $Result.GetResult<Prisma.$CleaningTaskPayload, S>

  type CleaningTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningTaskCountAggregateInputType | true
    }

  export interface CleaningTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningTask'], meta: { name: 'CleaningTask' } }
    /**
     * Find zero or one CleaningTask that matches the filter.
     * @param {CleaningTaskFindUniqueArgs} args - Arguments to find a CleaningTask
     * @example
     * // Get one CleaningTask
     * const cleaningTask = await prisma.cleaningTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningTaskFindUniqueArgs>(args: SelectSubset<T, CleaningTaskFindUniqueArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningTaskFindUniqueOrThrowArgs} args - Arguments to find a CleaningTask
     * @example
     * // Get one CleaningTask
     * const cleaningTask = await prisma.cleaningTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskFindFirstArgs} args - Arguments to find a CleaningTask
     * @example
     * // Get one CleaningTask
     * const cleaningTask = await prisma.cleaningTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningTaskFindFirstArgs>(args?: SelectSubset<T, CleaningTaskFindFirstArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskFindFirstOrThrowArgs} args - Arguments to find a CleaningTask
     * @example
     * // Get one CleaningTask
     * const cleaningTask = await prisma.cleaningTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningTasks
     * const cleaningTasks = await prisma.cleaningTask.findMany()
     * 
     * // Get first 10 CleaningTasks
     * const cleaningTasks = await prisma.cleaningTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningTaskWithIdOnly = await prisma.cleaningTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningTaskFindManyArgs>(args?: SelectSubset<T, CleaningTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningTask.
     * @param {CleaningTaskCreateArgs} args - Arguments to create a CleaningTask.
     * @example
     * // Create one CleaningTask
     * const CleaningTask = await prisma.cleaningTask.create({
     *   data: {
     *     // ... data to create a CleaningTask
     *   }
     * })
     * 
     */
    create<T extends CleaningTaskCreateArgs>(args: SelectSubset<T, CleaningTaskCreateArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningTasks.
     * @param {CleaningTaskCreateManyArgs} args - Arguments to create many CleaningTasks.
     * @example
     * // Create many CleaningTasks
     * const cleaningTask = await prisma.cleaningTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningTaskCreateManyArgs>(args?: SelectSubset<T, CleaningTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningTasks and returns the data saved in the database.
     * @param {CleaningTaskCreateManyAndReturnArgs} args - Arguments to create many CleaningTasks.
     * @example
     * // Create many CleaningTasks
     * const cleaningTask = await prisma.cleaningTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningTasks and only return the `id`
     * const cleaningTaskWithIdOnly = await prisma.cleaningTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningTask.
     * @param {CleaningTaskDeleteArgs} args - Arguments to delete one CleaningTask.
     * @example
     * // Delete one CleaningTask
     * const CleaningTask = await prisma.cleaningTask.delete({
     *   where: {
     *     // ... filter to delete one CleaningTask
     *   }
     * })
     * 
     */
    delete<T extends CleaningTaskDeleteArgs>(args: SelectSubset<T, CleaningTaskDeleteArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningTask.
     * @param {CleaningTaskUpdateArgs} args - Arguments to update one CleaningTask.
     * @example
     * // Update one CleaningTask
     * const cleaningTask = await prisma.cleaningTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningTaskUpdateArgs>(args: SelectSubset<T, CleaningTaskUpdateArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningTasks.
     * @param {CleaningTaskDeleteManyArgs} args - Arguments to filter CleaningTasks to delete.
     * @example
     * // Delete a few CleaningTasks
     * const { count } = await prisma.cleaningTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningTaskDeleteManyArgs>(args?: SelectSubset<T, CleaningTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningTasks
     * const cleaningTask = await prisma.cleaningTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningTaskUpdateManyArgs>(args: SelectSubset<T, CleaningTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningTasks and returns the data updated in the database.
     * @param {CleaningTaskUpdateManyAndReturnArgs} args - Arguments to update many CleaningTasks.
     * @example
     * // Update many CleaningTasks
     * const cleaningTask = await prisma.cleaningTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningTasks and only return the `id`
     * const cleaningTaskWithIdOnly = await prisma.cleaningTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningTask.
     * @param {CleaningTaskUpsertArgs} args - Arguments to update or create a CleaningTask.
     * @example
     * // Update or create a CleaningTask
     * const cleaningTask = await prisma.cleaningTask.upsert({
     *   create: {
     *     // ... data to create a CleaningTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningTask we want to update
     *   }
     * })
     */
    upsert<T extends CleaningTaskUpsertArgs>(args: SelectSubset<T, CleaningTaskUpsertArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskCountArgs} args - Arguments to filter CleaningTasks to count.
     * @example
     * // Count the number of CleaningTasks
     * const count = await prisma.cleaningTask.count({
     *   where: {
     *     // ... the filter for the CleaningTasks we want to count
     *   }
     * })
    **/
    count<T extends CleaningTaskCountArgs>(
      args?: Subset<T, CleaningTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningTaskAggregateArgs>(args: Subset<T, CleaningTaskAggregateArgs>): Prisma.PrismaPromise<GetCleaningTaskAggregateType<T>>

    /**
     * Group by CleaningTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningTaskGroupByArgs['orderBy'] }
        : { orderBy?: CleaningTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningTask model
   */
  readonly fields: CleaningTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends HousekeepingAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingAreaDefaultArgs<ExtArgs>>): Prisma__HousekeepingAreaClient<$Result.GetResult<Prisma.$HousekeepingAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends CleaningTask$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, CleaningTask$assignedToArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verifications<T extends CleaningTask$verificationsArgs<ExtArgs> = {}>(args?: Subset<T, CleaningTask$verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningTask model
   */
  interface CleaningTaskFieldRefs {
    readonly id: FieldRef<"CleaningTask", 'Int'>
    readonly areaId: FieldRef<"CleaningTask", 'Int'>
    readonly assignedToId: FieldRef<"CleaningTask", 'Int'>
    readonly scheduledDate: FieldRef<"CleaningTask", 'DateTime'>
    readonly scheduledTime: FieldRef<"CleaningTask", 'String'>
    readonly estimatedDuration: FieldRef<"CleaningTask", 'Int'>
    readonly priority: FieldRef<"CleaningTask", 'String'>
    readonly status: FieldRef<"CleaningTask", 'String'>
    readonly startedAt: FieldRef<"CleaningTask", 'DateTime'>
    readonly completedAt: FieldRef<"CleaningTask", 'DateTime'>
    readonly notes: FieldRef<"CleaningTask", 'String'>
    readonly createdAt: FieldRef<"CleaningTask", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningTask findUnique
   */
  export type CleaningTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * Filter, which CleaningTask to fetch.
     */
    where: CleaningTaskWhereUniqueInput
  }

  /**
   * CleaningTask findUniqueOrThrow
   */
  export type CleaningTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * Filter, which CleaningTask to fetch.
     */
    where: CleaningTaskWhereUniqueInput
  }

  /**
   * CleaningTask findFirst
   */
  export type CleaningTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * Filter, which CleaningTask to fetch.
     */
    where?: CleaningTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningTasks to fetch.
     */
    orderBy?: CleaningTaskOrderByWithRelationInput | CleaningTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningTasks.
     */
    cursor?: CleaningTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningTasks.
     */
    distinct?: CleaningTaskScalarFieldEnum | CleaningTaskScalarFieldEnum[]
  }

  /**
   * CleaningTask findFirstOrThrow
   */
  export type CleaningTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * Filter, which CleaningTask to fetch.
     */
    where?: CleaningTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningTasks to fetch.
     */
    orderBy?: CleaningTaskOrderByWithRelationInput | CleaningTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningTasks.
     */
    cursor?: CleaningTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningTasks.
     */
    distinct?: CleaningTaskScalarFieldEnum | CleaningTaskScalarFieldEnum[]
  }

  /**
   * CleaningTask findMany
   */
  export type CleaningTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * Filter, which CleaningTasks to fetch.
     */
    where?: CleaningTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningTasks to fetch.
     */
    orderBy?: CleaningTaskOrderByWithRelationInput | CleaningTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningTasks.
     */
    cursor?: CleaningTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningTasks.
     */
    skip?: number
    distinct?: CleaningTaskScalarFieldEnum | CleaningTaskScalarFieldEnum[]
  }

  /**
   * CleaningTask create
   */
  export type CleaningTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningTask.
     */
    data: XOR<CleaningTaskCreateInput, CleaningTaskUncheckedCreateInput>
  }

  /**
   * CleaningTask createMany
   */
  export type CleaningTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningTasks.
     */
    data: CleaningTaskCreateManyInput | CleaningTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningTask createManyAndReturn
   */
  export type CleaningTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningTasks.
     */
    data: CleaningTaskCreateManyInput | CleaningTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningTask update
   */
  export type CleaningTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningTask.
     */
    data: XOR<CleaningTaskUpdateInput, CleaningTaskUncheckedUpdateInput>
    /**
     * Choose, which CleaningTask to update.
     */
    where: CleaningTaskWhereUniqueInput
  }

  /**
   * CleaningTask updateMany
   */
  export type CleaningTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningTasks.
     */
    data: XOR<CleaningTaskUpdateManyMutationInput, CleaningTaskUncheckedUpdateManyInput>
    /**
     * Filter which CleaningTasks to update
     */
    where?: CleaningTaskWhereInput
    /**
     * Limit how many CleaningTasks to update.
     */
    limit?: number
  }

  /**
   * CleaningTask updateManyAndReturn
   */
  export type CleaningTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * The data used to update CleaningTasks.
     */
    data: XOR<CleaningTaskUpdateManyMutationInput, CleaningTaskUncheckedUpdateManyInput>
    /**
     * Filter which CleaningTasks to update
     */
    where?: CleaningTaskWhereInput
    /**
     * Limit how many CleaningTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningTask upsert
   */
  export type CleaningTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningTask to update in case it exists.
     */
    where: CleaningTaskWhereUniqueInput
    /**
     * In case the CleaningTask found by the `where` argument doesn't exist, create a new CleaningTask with this data.
     */
    create: XOR<CleaningTaskCreateInput, CleaningTaskUncheckedCreateInput>
    /**
     * In case the CleaningTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningTaskUpdateInput, CleaningTaskUncheckedUpdateInput>
  }

  /**
   * CleaningTask delete
   */
  export type CleaningTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
    /**
     * Filter which CleaningTask to delete.
     */
    where: CleaningTaskWhereUniqueInput
  }

  /**
   * CleaningTask deleteMany
   */
  export type CleaningTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningTasks to delete
     */
    where?: CleaningTaskWhereInput
    /**
     * Limit how many CleaningTasks to delete.
     */
    limit?: number
  }

  /**
   * CleaningTask.assignedTo
   */
  export type CleaningTask$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingStaff
     */
    select?: HousekeepingStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingStaff
     */
    omit?: HousekeepingStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingStaffInclude<ExtArgs> | null
    where?: HousekeepingStaffWhereInput
  }

  /**
   * CleaningTask.verifications
   */
  export type CleaningTask$verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    where?: CleaningVerificationWhereInput
    orderBy?: CleaningVerificationOrderByWithRelationInput | CleaningVerificationOrderByWithRelationInput[]
    cursor?: CleaningVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningVerificationScalarFieldEnum | CleaningVerificationScalarFieldEnum[]
  }

  /**
   * CleaningTask without action
   */
  export type CleaningTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningTask
     */
    select?: CleaningTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningTask
     */
    omit?: CleaningTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningTaskInclude<ExtArgs> | null
  }


  /**
   * Model CleaningVerification
   */

  export type AggregateCleaningVerification = {
    _count: CleaningVerificationCountAggregateOutputType | null
    _avg: CleaningVerificationAvgAggregateOutputType | null
    _sum: CleaningVerificationSumAggregateOutputType | null
    _min: CleaningVerificationMinAggregateOutputType | null
    _max: CleaningVerificationMaxAggregateOutputType | null
  }

  export type CleaningVerificationAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    verifiedById: number | null
    rating: number | null
    cleanliness: number | null
  }

  export type CleaningVerificationSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    verifiedById: number | null
    rating: number | null
    cleanliness: number | null
  }

  export type CleaningVerificationMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    verifiedById: number | null
    verificationDate: Date | null
    rating: number | null
    cleanliness: number | null
    comments: string | null
    photosUrl: string | null
    status: string | null
    followUpRequired: boolean | null
    followUpNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningVerificationMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    verifiedById: number | null
    verificationDate: Date | null
    rating: number | null
    cleanliness: number | null
    comments: string | null
    photosUrl: string | null
    status: string | null
    followUpRequired: boolean | null
    followUpNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningVerificationCountAggregateOutputType = {
    id: number
    taskId: number
    verifiedById: number
    verificationDate: number
    rating: number
    cleanliness: number
    comments: number
    photosUrl: number
    status: number
    followUpRequired: number
    followUpNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningVerificationAvgAggregateInputType = {
    id?: true
    taskId?: true
    verifiedById?: true
    rating?: true
    cleanliness?: true
  }

  export type CleaningVerificationSumAggregateInputType = {
    id?: true
    taskId?: true
    verifiedById?: true
    rating?: true
    cleanliness?: true
  }

  export type CleaningVerificationMinAggregateInputType = {
    id?: true
    taskId?: true
    verifiedById?: true
    verificationDate?: true
    rating?: true
    cleanliness?: true
    comments?: true
    photosUrl?: true
    status?: true
    followUpRequired?: true
    followUpNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningVerificationMaxAggregateInputType = {
    id?: true
    taskId?: true
    verifiedById?: true
    verificationDate?: true
    rating?: true
    cleanliness?: true
    comments?: true
    photosUrl?: true
    status?: true
    followUpRequired?: true
    followUpNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningVerificationCountAggregateInputType = {
    id?: true
    taskId?: true
    verifiedById?: true
    verificationDate?: true
    rating?: true
    cleanliness?: true
    comments?: true
    photosUrl?: true
    status?: true
    followUpRequired?: true
    followUpNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningVerification to aggregate.
     */
    where?: CleaningVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningVerifications to fetch.
     */
    orderBy?: CleaningVerificationOrderByWithRelationInput | CleaningVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningVerifications
    **/
    _count?: true | CleaningVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningVerificationMaxAggregateInputType
  }

  export type GetCleaningVerificationAggregateType<T extends CleaningVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningVerification[P]>
      : GetScalarType<T[P], AggregateCleaningVerification[P]>
  }




  export type CleaningVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningVerificationWhereInput
    orderBy?: CleaningVerificationOrderByWithAggregationInput | CleaningVerificationOrderByWithAggregationInput[]
    by: CleaningVerificationScalarFieldEnum[] | CleaningVerificationScalarFieldEnum
    having?: CleaningVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningVerificationCountAggregateInputType | true
    _avg?: CleaningVerificationAvgAggregateInputType
    _sum?: CleaningVerificationSumAggregateInputType
    _min?: CleaningVerificationMinAggregateInputType
    _max?: CleaningVerificationMaxAggregateInputType
  }

  export type CleaningVerificationGroupByOutputType = {
    id: number
    taskId: number
    verifiedById: number
    verificationDate: Date
    rating: number
    cleanliness: number
    comments: string | null
    photosUrl: string | null
    status: string
    followUpRequired: boolean
    followUpNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CleaningVerificationCountAggregateOutputType | null
    _avg: CleaningVerificationAvgAggregateOutputType | null
    _sum: CleaningVerificationSumAggregateOutputType | null
    _min: CleaningVerificationMinAggregateOutputType | null
    _max: CleaningVerificationMaxAggregateOutputType | null
  }

  type GetCleaningVerificationGroupByPayload<T extends CleaningVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningVerificationGroupByOutputType[P]>
        }
      >
    >


  export type CleaningVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    verifiedById?: boolean
    verificationDate?: boolean
    rating?: boolean
    cleanliness?: boolean
    comments?: boolean
    photosUrl?: boolean
    status?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | CleaningTaskDefaultArgs<ExtArgs>
    verifiedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningVerification"]>

  export type CleaningVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    verifiedById?: boolean
    verificationDate?: boolean
    rating?: boolean
    cleanliness?: boolean
    comments?: boolean
    photosUrl?: boolean
    status?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | CleaningTaskDefaultArgs<ExtArgs>
    verifiedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningVerification"]>

  export type CleaningVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    verifiedById?: boolean
    verificationDate?: boolean
    rating?: boolean
    cleanliness?: boolean
    comments?: boolean
    photosUrl?: boolean
    status?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | CleaningTaskDefaultArgs<ExtArgs>
    verifiedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningVerification"]>

  export type CleaningVerificationSelectScalar = {
    id?: boolean
    taskId?: boolean
    verifiedById?: boolean
    verificationDate?: boolean
    rating?: boolean
    cleanliness?: boolean
    comments?: boolean
    photosUrl?: boolean
    status?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "verifiedById" | "verificationDate" | "rating" | "cleanliness" | "comments" | "photosUrl" | "status" | "followUpRequired" | "followUpNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningVerification"]>
  export type CleaningVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | CleaningTaskDefaultArgs<ExtArgs>
    verifiedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }
  export type CleaningVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | CleaningTaskDefaultArgs<ExtArgs>
    verifiedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }
  export type CleaningVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | CleaningTaskDefaultArgs<ExtArgs>
    verifiedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }

  export type $CleaningVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningVerification"
    objects: {
      task: Prisma.$CleaningTaskPayload<ExtArgs>
      verifiedBy: Prisma.$HousekeepingStaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      verifiedById: number
      verificationDate: Date
      rating: number
      cleanliness: number
      comments: string | null
      photosUrl: string | null
      status: string
      followUpRequired: boolean
      followUpNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningVerification"]>
    composites: {}
  }

  type CleaningVerificationGetPayload<S extends boolean | null | undefined | CleaningVerificationDefaultArgs> = $Result.GetResult<Prisma.$CleaningVerificationPayload, S>

  type CleaningVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningVerificationCountAggregateInputType | true
    }

  export interface CleaningVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningVerification'], meta: { name: 'CleaningVerification' } }
    /**
     * Find zero or one CleaningVerification that matches the filter.
     * @param {CleaningVerificationFindUniqueArgs} args - Arguments to find a CleaningVerification
     * @example
     * // Get one CleaningVerification
     * const cleaningVerification = await prisma.cleaningVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningVerificationFindUniqueArgs>(args: SelectSubset<T, CleaningVerificationFindUniqueArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningVerificationFindUniqueOrThrowArgs} args - Arguments to find a CleaningVerification
     * @example
     * // Get one CleaningVerification
     * const cleaningVerification = await prisma.cleaningVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationFindFirstArgs} args - Arguments to find a CleaningVerification
     * @example
     * // Get one CleaningVerification
     * const cleaningVerification = await prisma.cleaningVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningVerificationFindFirstArgs>(args?: SelectSubset<T, CleaningVerificationFindFirstArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationFindFirstOrThrowArgs} args - Arguments to find a CleaningVerification
     * @example
     * // Get one CleaningVerification
     * const cleaningVerification = await prisma.cleaningVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningVerifications
     * const cleaningVerifications = await prisma.cleaningVerification.findMany()
     * 
     * // Get first 10 CleaningVerifications
     * const cleaningVerifications = await prisma.cleaningVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningVerificationWithIdOnly = await prisma.cleaningVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningVerificationFindManyArgs>(args?: SelectSubset<T, CleaningVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningVerification.
     * @param {CleaningVerificationCreateArgs} args - Arguments to create a CleaningVerification.
     * @example
     * // Create one CleaningVerification
     * const CleaningVerification = await prisma.cleaningVerification.create({
     *   data: {
     *     // ... data to create a CleaningVerification
     *   }
     * })
     * 
     */
    create<T extends CleaningVerificationCreateArgs>(args: SelectSubset<T, CleaningVerificationCreateArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningVerifications.
     * @param {CleaningVerificationCreateManyArgs} args - Arguments to create many CleaningVerifications.
     * @example
     * // Create many CleaningVerifications
     * const cleaningVerification = await prisma.cleaningVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningVerificationCreateManyArgs>(args?: SelectSubset<T, CleaningVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningVerifications and returns the data saved in the database.
     * @param {CleaningVerificationCreateManyAndReturnArgs} args - Arguments to create many CleaningVerifications.
     * @example
     * // Create many CleaningVerifications
     * const cleaningVerification = await prisma.cleaningVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningVerifications and only return the `id`
     * const cleaningVerificationWithIdOnly = await prisma.cleaningVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningVerification.
     * @param {CleaningVerificationDeleteArgs} args - Arguments to delete one CleaningVerification.
     * @example
     * // Delete one CleaningVerification
     * const CleaningVerification = await prisma.cleaningVerification.delete({
     *   where: {
     *     // ... filter to delete one CleaningVerification
     *   }
     * })
     * 
     */
    delete<T extends CleaningVerificationDeleteArgs>(args: SelectSubset<T, CleaningVerificationDeleteArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningVerification.
     * @param {CleaningVerificationUpdateArgs} args - Arguments to update one CleaningVerification.
     * @example
     * // Update one CleaningVerification
     * const cleaningVerification = await prisma.cleaningVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningVerificationUpdateArgs>(args: SelectSubset<T, CleaningVerificationUpdateArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningVerifications.
     * @param {CleaningVerificationDeleteManyArgs} args - Arguments to filter CleaningVerifications to delete.
     * @example
     * // Delete a few CleaningVerifications
     * const { count } = await prisma.cleaningVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningVerificationDeleteManyArgs>(args?: SelectSubset<T, CleaningVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningVerifications
     * const cleaningVerification = await prisma.cleaningVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningVerificationUpdateManyArgs>(args: SelectSubset<T, CleaningVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningVerifications and returns the data updated in the database.
     * @param {CleaningVerificationUpdateManyAndReturnArgs} args - Arguments to update many CleaningVerifications.
     * @example
     * // Update many CleaningVerifications
     * const cleaningVerification = await prisma.cleaningVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningVerifications and only return the `id`
     * const cleaningVerificationWithIdOnly = await prisma.cleaningVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningVerification.
     * @param {CleaningVerificationUpsertArgs} args - Arguments to update or create a CleaningVerification.
     * @example
     * // Update or create a CleaningVerification
     * const cleaningVerification = await prisma.cleaningVerification.upsert({
     *   create: {
     *     // ... data to create a CleaningVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningVerification we want to update
     *   }
     * })
     */
    upsert<T extends CleaningVerificationUpsertArgs>(args: SelectSubset<T, CleaningVerificationUpsertArgs<ExtArgs>>): Prisma__CleaningVerificationClient<$Result.GetResult<Prisma.$CleaningVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationCountArgs} args - Arguments to filter CleaningVerifications to count.
     * @example
     * // Count the number of CleaningVerifications
     * const count = await prisma.cleaningVerification.count({
     *   where: {
     *     // ... the filter for the CleaningVerifications we want to count
     *   }
     * })
    **/
    count<T extends CleaningVerificationCountArgs>(
      args?: Subset<T, CleaningVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningVerificationAggregateArgs>(args: Subset<T, CleaningVerificationAggregateArgs>): Prisma.PrismaPromise<GetCleaningVerificationAggregateType<T>>

    /**
     * Group by CleaningVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningVerificationGroupByArgs['orderBy'] }
        : { orderBy?: CleaningVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningVerification model
   */
  readonly fields: CleaningVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends CleaningTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningTaskDefaultArgs<ExtArgs>>): Prisma__CleaningTaskClient<$Result.GetResult<Prisma.$CleaningTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends HousekeepingStaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingStaffDefaultArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningVerification model
   */
  interface CleaningVerificationFieldRefs {
    readonly id: FieldRef<"CleaningVerification", 'Int'>
    readonly taskId: FieldRef<"CleaningVerification", 'Int'>
    readonly verifiedById: FieldRef<"CleaningVerification", 'Int'>
    readonly verificationDate: FieldRef<"CleaningVerification", 'DateTime'>
    readonly rating: FieldRef<"CleaningVerification", 'Int'>
    readonly cleanliness: FieldRef<"CleaningVerification", 'Int'>
    readonly comments: FieldRef<"CleaningVerification", 'String'>
    readonly photosUrl: FieldRef<"CleaningVerification", 'String'>
    readonly status: FieldRef<"CleaningVerification", 'String'>
    readonly followUpRequired: FieldRef<"CleaningVerification", 'Boolean'>
    readonly followUpNotes: FieldRef<"CleaningVerification", 'String'>
    readonly createdAt: FieldRef<"CleaningVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningVerification findUnique
   */
  export type CleaningVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * Filter, which CleaningVerification to fetch.
     */
    where: CleaningVerificationWhereUniqueInput
  }

  /**
   * CleaningVerification findUniqueOrThrow
   */
  export type CleaningVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * Filter, which CleaningVerification to fetch.
     */
    where: CleaningVerificationWhereUniqueInput
  }

  /**
   * CleaningVerification findFirst
   */
  export type CleaningVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * Filter, which CleaningVerification to fetch.
     */
    where?: CleaningVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningVerifications to fetch.
     */
    orderBy?: CleaningVerificationOrderByWithRelationInput | CleaningVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningVerifications.
     */
    cursor?: CleaningVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningVerifications.
     */
    distinct?: CleaningVerificationScalarFieldEnum | CleaningVerificationScalarFieldEnum[]
  }

  /**
   * CleaningVerification findFirstOrThrow
   */
  export type CleaningVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * Filter, which CleaningVerification to fetch.
     */
    where?: CleaningVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningVerifications to fetch.
     */
    orderBy?: CleaningVerificationOrderByWithRelationInput | CleaningVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningVerifications.
     */
    cursor?: CleaningVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningVerifications.
     */
    distinct?: CleaningVerificationScalarFieldEnum | CleaningVerificationScalarFieldEnum[]
  }

  /**
   * CleaningVerification findMany
   */
  export type CleaningVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * Filter, which CleaningVerifications to fetch.
     */
    where?: CleaningVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningVerifications to fetch.
     */
    orderBy?: CleaningVerificationOrderByWithRelationInput | CleaningVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningVerifications.
     */
    cursor?: CleaningVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningVerifications.
     */
    skip?: number
    distinct?: CleaningVerificationScalarFieldEnum | CleaningVerificationScalarFieldEnum[]
  }

  /**
   * CleaningVerification create
   */
  export type CleaningVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningVerification.
     */
    data: XOR<CleaningVerificationCreateInput, CleaningVerificationUncheckedCreateInput>
  }

  /**
   * CleaningVerification createMany
   */
  export type CleaningVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningVerifications.
     */
    data: CleaningVerificationCreateManyInput | CleaningVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningVerification createManyAndReturn
   */
  export type CleaningVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningVerifications.
     */
    data: CleaningVerificationCreateManyInput | CleaningVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningVerification update
   */
  export type CleaningVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningVerification.
     */
    data: XOR<CleaningVerificationUpdateInput, CleaningVerificationUncheckedUpdateInput>
    /**
     * Choose, which CleaningVerification to update.
     */
    where: CleaningVerificationWhereUniqueInput
  }

  /**
   * CleaningVerification updateMany
   */
  export type CleaningVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningVerifications.
     */
    data: XOR<CleaningVerificationUpdateManyMutationInput, CleaningVerificationUncheckedUpdateManyInput>
    /**
     * Filter which CleaningVerifications to update
     */
    where?: CleaningVerificationWhereInput
    /**
     * Limit how many CleaningVerifications to update.
     */
    limit?: number
  }

  /**
   * CleaningVerification updateManyAndReturn
   */
  export type CleaningVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * The data used to update CleaningVerifications.
     */
    data: XOR<CleaningVerificationUpdateManyMutationInput, CleaningVerificationUncheckedUpdateManyInput>
    /**
     * Filter which CleaningVerifications to update
     */
    where?: CleaningVerificationWhereInput
    /**
     * Limit how many CleaningVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningVerification upsert
   */
  export type CleaningVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningVerification to update in case it exists.
     */
    where: CleaningVerificationWhereUniqueInput
    /**
     * In case the CleaningVerification found by the `where` argument doesn't exist, create a new CleaningVerification with this data.
     */
    create: XOR<CleaningVerificationCreateInput, CleaningVerificationUncheckedCreateInput>
    /**
     * In case the CleaningVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningVerificationUpdateInput, CleaningVerificationUncheckedUpdateInput>
  }

  /**
   * CleaningVerification delete
   */
  export type CleaningVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
    /**
     * Filter which CleaningVerification to delete.
     */
    where: CleaningVerificationWhereUniqueInput
  }

  /**
   * CleaningVerification deleteMany
   */
  export type CleaningVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningVerifications to delete
     */
    where?: CleaningVerificationWhereInput
    /**
     * Limit how many CleaningVerifications to delete.
     */
    limit?: number
  }

  /**
   * CleaningVerification without action
   */
  export type CleaningVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningVerification
     */
    select?: CleaningVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningVerification
     */
    omit?: CleaningVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningVerificationInclude<ExtArgs> | null
  }


  /**
   * Model CleaningSupply
   */

  export type AggregateCleaningSupply = {
    _count: CleaningSupplyCountAggregateOutputType | null
    _avg: CleaningSupplyAvgAggregateOutputType | null
    _sum: CleaningSupplySumAggregateOutputType | null
    _min: CleaningSupplyMinAggregateOutputType | null
    _max: CleaningSupplyMaxAggregateOutputType | null
  }

  export type CleaningSupplyAvgAggregateOutputType = {
    id: number | null
    currentStock: number | null
    reorderLevel: number | null
    lastPurchasePrice: Decimal | null
  }

  export type CleaningSupplySumAggregateOutputType = {
    id: number | null
    currentStock: number | null
    reorderLevel: number | null
    lastPurchasePrice: Decimal | null
  }

  export type CleaningSupplyMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    unit: string | null
    currentStock: number | null
    reorderLevel: number | null
    location: string | null
    supplier: string | null
    lastPurchaseDate: Date | null
    lastPurchasePrice: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningSupplyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    unit: string | null
    currentStock: number | null
    reorderLevel: number | null
    location: string | null
    supplier: string | null
    lastPurchaseDate: Date | null
    lastPurchasePrice: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningSupplyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    unit: number
    currentStock: number
    reorderLevel: number
    location: number
    supplier: number
    lastPurchaseDate: number
    lastPurchasePrice: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningSupplyAvgAggregateInputType = {
    id?: true
    currentStock?: true
    reorderLevel?: true
    lastPurchasePrice?: true
  }

  export type CleaningSupplySumAggregateInputType = {
    id?: true
    currentStock?: true
    reorderLevel?: true
    lastPurchasePrice?: true
  }

  export type CleaningSupplyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    unit?: true
    currentStock?: true
    reorderLevel?: true
    location?: true
    supplier?: true
    lastPurchaseDate?: true
    lastPurchasePrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningSupplyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    unit?: true
    currentStock?: true
    reorderLevel?: true
    location?: true
    supplier?: true
    lastPurchaseDate?: true
    lastPurchasePrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningSupplyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    unit?: true
    currentStock?: true
    reorderLevel?: true
    location?: true
    supplier?: true
    lastPurchaseDate?: true
    lastPurchasePrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningSupplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSupply to aggregate.
     */
    where?: CleaningSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplies to fetch.
     */
    orderBy?: CleaningSupplyOrderByWithRelationInput | CleaningSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningSupplies
    **/
    _count?: true | CleaningSupplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningSupplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningSupplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningSupplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningSupplyMaxAggregateInputType
  }

  export type GetCleaningSupplyAggregateType<T extends CleaningSupplyAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningSupply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningSupply[P]>
      : GetScalarType<T[P], AggregateCleaningSupply[P]>
  }




  export type CleaningSupplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSupplyWhereInput
    orderBy?: CleaningSupplyOrderByWithAggregationInput | CleaningSupplyOrderByWithAggregationInput[]
    by: CleaningSupplyScalarFieldEnum[] | CleaningSupplyScalarFieldEnum
    having?: CleaningSupplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningSupplyCountAggregateInputType | true
    _avg?: CleaningSupplyAvgAggregateInputType
    _sum?: CleaningSupplySumAggregateInputType
    _min?: CleaningSupplyMinAggregateInputType
    _max?: CleaningSupplyMaxAggregateInputType
  }

  export type CleaningSupplyGroupByOutputType = {
    id: number
    name: string
    description: string | null
    unit: string
    currentStock: number
    reorderLevel: number
    location: string | null
    supplier: string | null
    lastPurchaseDate: Date | null
    lastPurchasePrice: Decimal | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: CleaningSupplyCountAggregateOutputType | null
    _avg: CleaningSupplyAvgAggregateOutputType | null
    _sum: CleaningSupplySumAggregateOutputType | null
    _min: CleaningSupplyMinAggregateOutputType | null
    _max: CleaningSupplyMaxAggregateOutputType | null
  }

  type GetCleaningSupplyGroupByPayload<T extends CleaningSupplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningSupplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningSupplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningSupplyGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningSupplyGroupByOutputType[P]>
        }
      >
    >


  export type CleaningSupplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentStock?: boolean
    reorderLevel?: boolean
    location?: boolean
    supplier?: boolean
    lastPurchaseDate?: boolean
    lastPurchasePrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplyRequests?: boolean | CleaningSupply$supplyRequestsArgs<ExtArgs>
    _count?: boolean | CleaningSupplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupply"]>

  export type CleaningSupplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentStock?: boolean
    reorderLevel?: boolean
    location?: boolean
    supplier?: boolean
    lastPurchaseDate?: boolean
    lastPurchasePrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cleaningSupply"]>

  export type CleaningSupplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentStock?: boolean
    reorderLevel?: boolean
    location?: boolean
    supplier?: boolean
    lastPurchaseDate?: boolean
    lastPurchasePrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cleaningSupply"]>

  export type CleaningSupplySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentStock?: boolean
    reorderLevel?: boolean
    location?: boolean
    supplier?: boolean
    lastPurchaseDate?: boolean
    lastPurchasePrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningSupplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "unit" | "currentStock" | "reorderLevel" | "location" | "supplier" | "lastPurchaseDate" | "lastPurchasePrice" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningSupply"]>
  export type CleaningSupplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplyRequests?: boolean | CleaningSupply$supplyRequestsArgs<ExtArgs>
    _count?: boolean | CleaningSupplyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningSupplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CleaningSupplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CleaningSupplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningSupply"
    objects: {
      supplyRequests: Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      unit: string
      currentStock: number
      reorderLevel: number
      location: string | null
      supplier: string | null
      lastPurchaseDate: Date | null
      lastPurchasePrice: Prisma.Decimal | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningSupply"]>
    composites: {}
  }

  type CleaningSupplyGetPayload<S extends boolean | null | undefined | CleaningSupplyDefaultArgs> = $Result.GetResult<Prisma.$CleaningSupplyPayload, S>

  type CleaningSupplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningSupplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningSupplyCountAggregateInputType | true
    }

  export interface CleaningSupplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningSupply'], meta: { name: 'CleaningSupply' } }
    /**
     * Find zero or one CleaningSupply that matches the filter.
     * @param {CleaningSupplyFindUniqueArgs} args - Arguments to find a CleaningSupply
     * @example
     * // Get one CleaningSupply
     * const cleaningSupply = await prisma.cleaningSupply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningSupplyFindUniqueArgs>(args: SelectSubset<T, CleaningSupplyFindUniqueArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningSupply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningSupplyFindUniqueOrThrowArgs} args - Arguments to find a CleaningSupply
     * @example
     * // Get one CleaningSupply
     * const cleaningSupply = await prisma.cleaningSupply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningSupplyFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningSupplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSupply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyFindFirstArgs} args - Arguments to find a CleaningSupply
     * @example
     * // Get one CleaningSupply
     * const cleaningSupply = await prisma.cleaningSupply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningSupplyFindFirstArgs>(args?: SelectSubset<T, CleaningSupplyFindFirstArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSupply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyFindFirstOrThrowArgs} args - Arguments to find a CleaningSupply
     * @example
     * // Get one CleaningSupply
     * const cleaningSupply = await prisma.cleaningSupply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningSupplyFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningSupplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningSupplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningSupplies
     * const cleaningSupplies = await prisma.cleaningSupply.findMany()
     * 
     * // Get first 10 CleaningSupplies
     * const cleaningSupplies = await prisma.cleaningSupply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningSupplyWithIdOnly = await prisma.cleaningSupply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningSupplyFindManyArgs>(args?: SelectSubset<T, CleaningSupplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningSupply.
     * @param {CleaningSupplyCreateArgs} args - Arguments to create a CleaningSupply.
     * @example
     * // Create one CleaningSupply
     * const CleaningSupply = await prisma.cleaningSupply.create({
     *   data: {
     *     // ... data to create a CleaningSupply
     *   }
     * })
     * 
     */
    create<T extends CleaningSupplyCreateArgs>(args: SelectSubset<T, CleaningSupplyCreateArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningSupplies.
     * @param {CleaningSupplyCreateManyArgs} args - Arguments to create many CleaningSupplies.
     * @example
     * // Create many CleaningSupplies
     * const cleaningSupply = await prisma.cleaningSupply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningSupplyCreateManyArgs>(args?: SelectSubset<T, CleaningSupplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningSupplies and returns the data saved in the database.
     * @param {CleaningSupplyCreateManyAndReturnArgs} args - Arguments to create many CleaningSupplies.
     * @example
     * // Create many CleaningSupplies
     * const cleaningSupply = await prisma.cleaningSupply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningSupplies and only return the `id`
     * const cleaningSupplyWithIdOnly = await prisma.cleaningSupply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningSupplyCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningSupplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningSupply.
     * @param {CleaningSupplyDeleteArgs} args - Arguments to delete one CleaningSupply.
     * @example
     * // Delete one CleaningSupply
     * const CleaningSupply = await prisma.cleaningSupply.delete({
     *   where: {
     *     // ... filter to delete one CleaningSupply
     *   }
     * })
     * 
     */
    delete<T extends CleaningSupplyDeleteArgs>(args: SelectSubset<T, CleaningSupplyDeleteArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningSupply.
     * @param {CleaningSupplyUpdateArgs} args - Arguments to update one CleaningSupply.
     * @example
     * // Update one CleaningSupply
     * const cleaningSupply = await prisma.cleaningSupply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningSupplyUpdateArgs>(args: SelectSubset<T, CleaningSupplyUpdateArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningSupplies.
     * @param {CleaningSupplyDeleteManyArgs} args - Arguments to filter CleaningSupplies to delete.
     * @example
     * // Delete a few CleaningSupplies
     * const { count } = await prisma.cleaningSupply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningSupplyDeleteManyArgs>(args?: SelectSubset<T, CleaningSupplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningSupplies
     * const cleaningSupply = await prisma.cleaningSupply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningSupplyUpdateManyArgs>(args: SelectSubset<T, CleaningSupplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSupplies and returns the data updated in the database.
     * @param {CleaningSupplyUpdateManyAndReturnArgs} args - Arguments to update many CleaningSupplies.
     * @example
     * // Update many CleaningSupplies
     * const cleaningSupply = await prisma.cleaningSupply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningSupplies and only return the `id`
     * const cleaningSupplyWithIdOnly = await prisma.cleaningSupply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningSupplyUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningSupplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningSupply.
     * @param {CleaningSupplyUpsertArgs} args - Arguments to update or create a CleaningSupply.
     * @example
     * // Update or create a CleaningSupply
     * const cleaningSupply = await prisma.cleaningSupply.upsert({
     *   create: {
     *     // ... data to create a CleaningSupply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningSupply we want to update
     *   }
     * })
     */
    upsert<T extends CleaningSupplyUpsertArgs>(args: SelectSubset<T, CleaningSupplyUpsertArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyCountArgs} args - Arguments to filter CleaningSupplies to count.
     * @example
     * // Count the number of CleaningSupplies
     * const count = await prisma.cleaningSupply.count({
     *   where: {
     *     // ... the filter for the CleaningSupplies we want to count
     *   }
     * })
    **/
    count<T extends CleaningSupplyCountArgs>(
      args?: Subset<T, CleaningSupplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningSupplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningSupply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningSupplyAggregateArgs>(args: Subset<T, CleaningSupplyAggregateArgs>): Prisma.PrismaPromise<GetCleaningSupplyAggregateType<T>>

    /**
     * Group by CleaningSupply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningSupplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningSupplyGroupByArgs['orderBy'] }
        : { orderBy?: CleaningSupplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningSupplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningSupplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningSupply model
   */
  readonly fields: CleaningSupplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningSupply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningSupplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplyRequests<T extends CleaningSupply$supplyRequestsArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSupply$supplyRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningSupply model
   */
  interface CleaningSupplyFieldRefs {
    readonly id: FieldRef<"CleaningSupply", 'Int'>
    readonly name: FieldRef<"CleaningSupply", 'String'>
    readonly description: FieldRef<"CleaningSupply", 'String'>
    readonly unit: FieldRef<"CleaningSupply", 'String'>
    readonly currentStock: FieldRef<"CleaningSupply", 'Int'>
    readonly reorderLevel: FieldRef<"CleaningSupply", 'Int'>
    readonly location: FieldRef<"CleaningSupply", 'String'>
    readonly supplier: FieldRef<"CleaningSupply", 'String'>
    readonly lastPurchaseDate: FieldRef<"CleaningSupply", 'DateTime'>
    readonly lastPurchasePrice: FieldRef<"CleaningSupply", 'Decimal'>
    readonly status: FieldRef<"CleaningSupply", 'String'>
    readonly createdAt: FieldRef<"CleaningSupply", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningSupply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningSupply findUnique
   */
  export type CleaningSupplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupply to fetch.
     */
    where: CleaningSupplyWhereUniqueInput
  }

  /**
   * CleaningSupply findUniqueOrThrow
   */
  export type CleaningSupplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupply to fetch.
     */
    where: CleaningSupplyWhereUniqueInput
  }

  /**
   * CleaningSupply findFirst
   */
  export type CleaningSupplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupply to fetch.
     */
    where?: CleaningSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplies to fetch.
     */
    orderBy?: CleaningSupplyOrderByWithRelationInput | CleaningSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSupplies.
     */
    cursor?: CleaningSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSupplies.
     */
    distinct?: CleaningSupplyScalarFieldEnum | CleaningSupplyScalarFieldEnum[]
  }

  /**
   * CleaningSupply findFirstOrThrow
   */
  export type CleaningSupplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupply to fetch.
     */
    where?: CleaningSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplies to fetch.
     */
    orderBy?: CleaningSupplyOrderByWithRelationInput | CleaningSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSupplies.
     */
    cursor?: CleaningSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSupplies.
     */
    distinct?: CleaningSupplyScalarFieldEnum | CleaningSupplyScalarFieldEnum[]
  }

  /**
   * CleaningSupply findMany
   */
  export type CleaningSupplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplies to fetch.
     */
    where?: CleaningSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplies to fetch.
     */
    orderBy?: CleaningSupplyOrderByWithRelationInput | CleaningSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningSupplies.
     */
    cursor?: CleaningSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplies.
     */
    skip?: number
    distinct?: CleaningSupplyScalarFieldEnum | CleaningSupplyScalarFieldEnum[]
  }

  /**
   * CleaningSupply create
   */
  export type CleaningSupplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningSupply.
     */
    data: XOR<CleaningSupplyCreateInput, CleaningSupplyUncheckedCreateInput>
  }

  /**
   * CleaningSupply createMany
   */
  export type CleaningSupplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningSupplies.
     */
    data: CleaningSupplyCreateManyInput | CleaningSupplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningSupply createManyAndReturn
   */
  export type CleaningSupplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningSupplies.
     */
    data: CleaningSupplyCreateManyInput | CleaningSupplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningSupply update
   */
  export type CleaningSupplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningSupply.
     */
    data: XOR<CleaningSupplyUpdateInput, CleaningSupplyUncheckedUpdateInput>
    /**
     * Choose, which CleaningSupply to update.
     */
    where: CleaningSupplyWhereUniqueInput
  }

  /**
   * CleaningSupply updateMany
   */
  export type CleaningSupplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningSupplies.
     */
    data: XOR<CleaningSupplyUpdateManyMutationInput, CleaningSupplyUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSupplies to update
     */
    where?: CleaningSupplyWhereInput
    /**
     * Limit how many CleaningSupplies to update.
     */
    limit?: number
  }

  /**
   * CleaningSupply updateManyAndReturn
   */
  export type CleaningSupplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * The data used to update CleaningSupplies.
     */
    data: XOR<CleaningSupplyUpdateManyMutationInput, CleaningSupplyUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSupplies to update
     */
    where?: CleaningSupplyWhereInput
    /**
     * Limit how many CleaningSupplies to update.
     */
    limit?: number
  }

  /**
   * CleaningSupply upsert
   */
  export type CleaningSupplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningSupply to update in case it exists.
     */
    where: CleaningSupplyWhereUniqueInput
    /**
     * In case the CleaningSupply found by the `where` argument doesn't exist, create a new CleaningSupply with this data.
     */
    create: XOR<CleaningSupplyCreateInput, CleaningSupplyUncheckedCreateInput>
    /**
     * In case the CleaningSupply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningSupplyUpdateInput, CleaningSupplyUncheckedUpdateInput>
  }

  /**
   * CleaningSupply delete
   */
  export type CleaningSupplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
    /**
     * Filter which CleaningSupply to delete.
     */
    where: CleaningSupplyWhereUniqueInput
  }

  /**
   * CleaningSupply deleteMany
   */
  export type CleaningSupplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSupplies to delete
     */
    where?: CleaningSupplyWhereInput
    /**
     * Limit how many CleaningSupplies to delete.
     */
    limit?: number
  }

  /**
   * CleaningSupply.supplyRequests
   */
  export type CleaningSupply$supplyRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    where?: CleaningSupplyRequestItemWhereInput
    orderBy?: CleaningSupplyRequestItemOrderByWithRelationInput | CleaningSupplyRequestItemOrderByWithRelationInput[]
    cursor?: CleaningSupplyRequestItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSupplyRequestItemScalarFieldEnum | CleaningSupplyRequestItemScalarFieldEnum[]
  }

  /**
   * CleaningSupply without action
   */
  export type CleaningSupplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupply
     */
    select?: CleaningSupplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupply
     */
    omit?: CleaningSupplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyInclude<ExtArgs> | null
  }


  /**
   * Model CleaningSupplyRequest
   */

  export type AggregateCleaningSupplyRequest = {
    _count: CleaningSupplyRequestCountAggregateOutputType | null
    _avg: CleaningSupplyRequestAvgAggregateOutputType | null
    _sum: CleaningSupplyRequestSumAggregateOutputType | null
    _min: CleaningSupplyRequestMinAggregateOutputType | null
    _max: CleaningSupplyRequestMaxAggregateOutputType | null
  }

  export type CleaningSupplyRequestAvgAggregateOutputType = {
    id: number | null
    requestedById: number | null
    approvedById: number | null
  }

  export type CleaningSupplyRequestSumAggregateOutputType = {
    id: number | null
    requestedById: number | null
    approvedById: number | null
  }

  export type CleaningSupplyRequestMinAggregateOutputType = {
    id: number | null
    requestedById: number | null
    requestDate: Date | null
    requiredBy: Date | null
    status: string | null
    approvedById: number | null
    approvedAt: Date | null
    fulfilledAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningSupplyRequestMaxAggregateOutputType = {
    id: number | null
    requestedById: number | null
    requestDate: Date | null
    requiredBy: Date | null
    status: string | null
    approvedById: number | null
    approvedAt: Date | null
    fulfilledAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningSupplyRequestCountAggregateOutputType = {
    id: number
    requestedById: number
    requestDate: number
    requiredBy: number
    status: number
    approvedById: number
    approvedAt: number
    fulfilledAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningSupplyRequestAvgAggregateInputType = {
    id?: true
    requestedById?: true
    approvedById?: true
  }

  export type CleaningSupplyRequestSumAggregateInputType = {
    id?: true
    requestedById?: true
    approvedById?: true
  }

  export type CleaningSupplyRequestMinAggregateInputType = {
    id?: true
    requestedById?: true
    requestDate?: true
    requiredBy?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    fulfilledAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningSupplyRequestMaxAggregateInputType = {
    id?: true
    requestedById?: true
    requestDate?: true
    requiredBy?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    fulfilledAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningSupplyRequestCountAggregateInputType = {
    id?: true
    requestedById?: true
    requestDate?: true
    requiredBy?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    fulfilledAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningSupplyRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSupplyRequest to aggregate.
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequests to fetch.
     */
    orderBy?: CleaningSupplyRequestOrderByWithRelationInput | CleaningSupplyRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningSupplyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningSupplyRequests
    **/
    _count?: true | CleaningSupplyRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningSupplyRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningSupplyRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningSupplyRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningSupplyRequestMaxAggregateInputType
  }

  export type GetCleaningSupplyRequestAggregateType<T extends CleaningSupplyRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningSupplyRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningSupplyRequest[P]>
      : GetScalarType<T[P], AggregateCleaningSupplyRequest[P]>
  }




  export type CleaningSupplyRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSupplyRequestWhereInput
    orderBy?: CleaningSupplyRequestOrderByWithAggregationInput | CleaningSupplyRequestOrderByWithAggregationInput[]
    by: CleaningSupplyRequestScalarFieldEnum[] | CleaningSupplyRequestScalarFieldEnum
    having?: CleaningSupplyRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningSupplyRequestCountAggregateInputType | true
    _avg?: CleaningSupplyRequestAvgAggregateInputType
    _sum?: CleaningSupplyRequestSumAggregateInputType
    _min?: CleaningSupplyRequestMinAggregateInputType
    _max?: CleaningSupplyRequestMaxAggregateInputType
  }

  export type CleaningSupplyRequestGroupByOutputType = {
    id: number
    requestedById: number
    requestDate: Date
    requiredBy: Date
    status: string
    approvedById: number | null
    approvedAt: Date | null
    fulfilledAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CleaningSupplyRequestCountAggregateOutputType | null
    _avg: CleaningSupplyRequestAvgAggregateOutputType | null
    _sum: CleaningSupplyRequestSumAggregateOutputType | null
    _min: CleaningSupplyRequestMinAggregateOutputType | null
    _max: CleaningSupplyRequestMaxAggregateOutputType | null
  }

  type GetCleaningSupplyRequestGroupByPayload<T extends CleaningSupplyRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningSupplyRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningSupplyRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningSupplyRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningSupplyRequestGroupByOutputType[P]>
        }
      >
    >


  export type CleaningSupplyRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestedById?: boolean
    requestDate?: boolean
    requiredBy?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    fulfilledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
    requestItems?: boolean | CleaningSupplyRequest$requestItemsArgs<ExtArgs>
    _count?: boolean | CleaningSupplyRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupplyRequest"]>

  export type CleaningSupplyRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestedById?: boolean
    requestDate?: boolean
    requiredBy?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    fulfilledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupplyRequest"]>

  export type CleaningSupplyRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestedById?: boolean
    requestDate?: boolean
    requiredBy?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    fulfilledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupplyRequest"]>

  export type CleaningSupplyRequestSelectScalar = {
    id?: boolean
    requestedById?: boolean
    requestDate?: boolean
    requiredBy?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    fulfilledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningSupplyRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestedById" | "requestDate" | "requiredBy" | "status" | "approvedById" | "approvedAt" | "fulfilledAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningSupplyRequest"]>
  export type CleaningSupplyRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
    requestItems?: boolean | CleaningSupplyRequest$requestItemsArgs<ExtArgs>
    _count?: boolean | CleaningSupplyRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningSupplyRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }
  export type CleaningSupplyRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestedBy?: boolean | HousekeepingStaffDefaultArgs<ExtArgs>
  }

  export type $CleaningSupplyRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningSupplyRequest"
    objects: {
      requestedBy: Prisma.$HousekeepingStaffPayload<ExtArgs>
      requestItems: Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestedById: number
      requestDate: Date
      requiredBy: Date
      status: string
      approvedById: number | null
      approvedAt: Date | null
      fulfilledAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningSupplyRequest"]>
    composites: {}
  }

  type CleaningSupplyRequestGetPayload<S extends boolean | null | undefined | CleaningSupplyRequestDefaultArgs> = $Result.GetResult<Prisma.$CleaningSupplyRequestPayload, S>

  type CleaningSupplyRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningSupplyRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningSupplyRequestCountAggregateInputType | true
    }

  export interface CleaningSupplyRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningSupplyRequest'], meta: { name: 'CleaningSupplyRequest' } }
    /**
     * Find zero or one CleaningSupplyRequest that matches the filter.
     * @param {CleaningSupplyRequestFindUniqueArgs} args - Arguments to find a CleaningSupplyRequest
     * @example
     * // Get one CleaningSupplyRequest
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningSupplyRequestFindUniqueArgs>(args: SelectSubset<T, CleaningSupplyRequestFindUniqueArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningSupplyRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningSupplyRequestFindUniqueOrThrowArgs} args - Arguments to find a CleaningSupplyRequest
     * @example
     * // Get one CleaningSupplyRequest
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningSupplyRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningSupplyRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSupplyRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestFindFirstArgs} args - Arguments to find a CleaningSupplyRequest
     * @example
     * // Get one CleaningSupplyRequest
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningSupplyRequestFindFirstArgs>(args?: SelectSubset<T, CleaningSupplyRequestFindFirstArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSupplyRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestFindFirstOrThrowArgs} args - Arguments to find a CleaningSupplyRequest
     * @example
     * // Get one CleaningSupplyRequest
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningSupplyRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningSupplyRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningSupplyRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningSupplyRequests
     * const cleaningSupplyRequests = await prisma.cleaningSupplyRequest.findMany()
     * 
     * // Get first 10 CleaningSupplyRequests
     * const cleaningSupplyRequests = await prisma.cleaningSupplyRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningSupplyRequestWithIdOnly = await prisma.cleaningSupplyRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningSupplyRequestFindManyArgs>(args?: SelectSubset<T, CleaningSupplyRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningSupplyRequest.
     * @param {CleaningSupplyRequestCreateArgs} args - Arguments to create a CleaningSupplyRequest.
     * @example
     * // Create one CleaningSupplyRequest
     * const CleaningSupplyRequest = await prisma.cleaningSupplyRequest.create({
     *   data: {
     *     // ... data to create a CleaningSupplyRequest
     *   }
     * })
     * 
     */
    create<T extends CleaningSupplyRequestCreateArgs>(args: SelectSubset<T, CleaningSupplyRequestCreateArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningSupplyRequests.
     * @param {CleaningSupplyRequestCreateManyArgs} args - Arguments to create many CleaningSupplyRequests.
     * @example
     * // Create many CleaningSupplyRequests
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningSupplyRequestCreateManyArgs>(args?: SelectSubset<T, CleaningSupplyRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningSupplyRequests and returns the data saved in the database.
     * @param {CleaningSupplyRequestCreateManyAndReturnArgs} args - Arguments to create many CleaningSupplyRequests.
     * @example
     * // Create many CleaningSupplyRequests
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningSupplyRequests and only return the `id`
     * const cleaningSupplyRequestWithIdOnly = await prisma.cleaningSupplyRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningSupplyRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningSupplyRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningSupplyRequest.
     * @param {CleaningSupplyRequestDeleteArgs} args - Arguments to delete one CleaningSupplyRequest.
     * @example
     * // Delete one CleaningSupplyRequest
     * const CleaningSupplyRequest = await prisma.cleaningSupplyRequest.delete({
     *   where: {
     *     // ... filter to delete one CleaningSupplyRequest
     *   }
     * })
     * 
     */
    delete<T extends CleaningSupplyRequestDeleteArgs>(args: SelectSubset<T, CleaningSupplyRequestDeleteArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningSupplyRequest.
     * @param {CleaningSupplyRequestUpdateArgs} args - Arguments to update one CleaningSupplyRequest.
     * @example
     * // Update one CleaningSupplyRequest
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningSupplyRequestUpdateArgs>(args: SelectSubset<T, CleaningSupplyRequestUpdateArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningSupplyRequests.
     * @param {CleaningSupplyRequestDeleteManyArgs} args - Arguments to filter CleaningSupplyRequests to delete.
     * @example
     * // Delete a few CleaningSupplyRequests
     * const { count } = await prisma.cleaningSupplyRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningSupplyRequestDeleteManyArgs>(args?: SelectSubset<T, CleaningSupplyRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSupplyRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningSupplyRequests
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningSupplyRequestUpdateManyArgs>(args: SelectSubset<T, CleaningSupplyRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSupplyRequests and returns the data updated in the database.
     * @param {CleaningSupplyRequestUpdateManyAndReturnArgs} args - Arguments to update many CleaningSupplyRequests.
     * @example
     * // Update many CleaningSupplyRequests
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningSupplyRequests and only return the `id`
     * const cleaningSupplyRequestWithIdOnly = await prisma.cleaningSupplyRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningSupplyRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningSupplyRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningSupplyRequest.
     * @param {CleaningSupplyRequestUpsertArgs} args - Arguments to update or create a CleaningSupplyRequest.
     * @example
     * // Update or create a CleaningSupplyRequest
     * const cleaningSupplyRequest = await prisma.cleaningSupplyRequest.upsert({
     *   create: {
     *     // ... data to create a CleaningSupplyRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningSupplyRequest we want to update
     *   }
     * })
     */
    upsert<T extends CleaningSupplyRequestUpsertArgs>(args: SelectSubset<T, CleaningSupplyRequestUpsertArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningSupplyRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestCountArgs} args - Arguments to filter CleaningSupplyRequests to count.
     * @example
     * // Count the number of CleaningSupplyRequests
     * const count = await prisma.cleaningSupplyRequest.count({
     *   where: {
     *     // ... the filter for the CleaningSupplyRequests we want to count
     *   }
     * })
    **/
    count<T extends CleaningSupplyRequestCountArgs>(
      args?: Subset<T, CleaningSupplyRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningSupplyRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningSupplyRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningSupplyRequestAggregateArgs>(args: Subset<T, CleaningSupplyRequestAggregateArgs>): Prisma.PrismaPromise<GetCleaningSupplyRequestAggregateType<T>>

    /**
     * Group by CleaningSupplyRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningSupplyRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningSupplyRequestGroupByArgs['orderBy'] }
        : { orderBy?: CleaningSupplyRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningSupplyRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningSupplyRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningSupplyRequest model
   */
  readonly fields: CleaningSupplyRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningSupplyRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningSupplyRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestedBy<T extends HousekeepingStaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingStaffDefaultArgs<ExtArgs>>): Prisma__HousekeepingStaffClient<$Result.GetResult<Prisma.$HousekeepingStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestItems<T extends CleaningSupplyRequest$requestItemsArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSupplyRequest$requestItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningSupplyRequest model
   */
  interface CleaningSupplyRequestFieldRefs {
    readonly id: FieldRef<"CleaningSupplyRequest", 'Int'>
    readonly requestedById: FieldRef<"CleaningSupplyRequest", 'Int'>
    readonly requestDate: FieldRef<"CleaningSupplyRequest", 'DateTime'>
    readonly requiredBy: FieldRef<"CleaningSupplyRequest", 'DateTime'>
    readonly status: FieldRef<"CleaningSupplyRequest", 'String'>
    readonly approvedById: FieldRef<"CleaningSupplyRequest", 'Int'>
    readonly approvedAt: FieldRef<"CleaningSupplyRequest", 'DateTime'>
    readonly fulfilledAt: FieldRef<"CleaningSupplyRequest", 'DateTime'>
    readonly notes: FieldRef<"CleaningSupplyRequest", 'String'>
    readonly createdAt: FieldRef<"CleaningSupplyRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningSupplyRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningSupplyRequest findUnique
   */
  export type CleaningSupplyRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequest to fetch.
     */
    where: CleaningSupplyRequestWhereUniqueInput
  }

  /**
   * CleaningSupplyRequest findUniqueOrThrow
   */
  export type CleaningSupplyRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequest to fetch.
     */
    where: CleaningSupplyRequestWhereUniqueInput
  }

  /**
   * CleaningSupplyRequest findFirst
   */
  export type CleaningSupplyRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequest to fetch.
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequests to fetch.
     */
    orderBy?: CleaningSupplyRequestOrderByWithRelationInput | CleaningSupplyRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSupplyRequests.
     */
    cursor?: CleaningSupplyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSupplyRequests.
     */
    distinct?: CleaningSupplyRequestScalarFieldEnum | CleaningSupplyRequestScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequest findFirstOrThrow
   */
  export type CleaningSupplyRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequest to fetch.
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequests to fetch.
     */
    orderBy?: CleaningSupplyRequestOrderByWithRelationInput | CleaningSupplyRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSupplyRequests.
     */
    cursor?: CleaningSupplyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSupplyRequests.
     */
    distinct?: CleaningSupplyRequestScalarFieldEnum | CleaningSupplyRequestScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequest findMany
   */
  export type CleaningSupplyRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequests to fetch.
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequests to fetch.
     */
    orderBy?: CleaningSupplyRequestOrderByWithRelationInput | CleaningSupplyRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningSupplyRequests.
     */
    cursor?: CleaningSupplyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequests.
     */
    skip?: number
    distinct?: CleaningSupplyRequestScalarFieldEnum | CleaningSupplyRequestScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequest create
   */
  export type CleaningSupplyRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningSupplyRequest.
     */
    data: XOR<CleaningSupplyRequestCreateInput, CleaningSupplyRequestUncheckedCreateInput>
  }

  /**
   * CleaningSupplyRequest createMany
   */
  export type CleaningSupplyRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningSupplyRequests.
     */
    data: CleaningSupplyRequestCreateManyInput | CleaningSupplyRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningSupplyRequest createManyAndReturn
   */
  export type CleaningSupplyRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningSupplyRequests.
     */
    data: CleaningSupplyRequestCreateManyInput | CleaningSupplyRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSupplyRequest update
   */
  export type CleaningSupplyRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningSupplyRequest.
     */
    data: XOR<CleaningSupplyRequestUpdateInput, CleaningSupplyRequestUncheckedUpdateInput>
    /**
     * Choose, which CleaningSupplyRequest to update.
     */
    where: CleaningSupplyRequestWhereUniqueInput
  }

  /**
   * CleaningSupplyRequest updateMany
   */
  export type CleaningSupplyRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningSupplyRequests.
     */
    data: XOR<CleaningSupplyRequestUpdateManyMutationInput, CleaningSupplyRequestUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSupplyRequests to update
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * Limit how many CleaningSupplyRequests to update.
     */
    limit?: number
  }

  /**
   * CleaningSupplyRequest updateManyAndReturn
   */
  export type CleaningSupplyRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * The data used to update CleaningSupplyRequests.
     */
    data: XOR<CleaningSupplyRequestUpdateManyMutationInput, CleaningSupplyRequestUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSupplyRequests to update
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * Limit how many CleaningSupplyRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSupplyRequest upsert
   */
  export type CleaningSupplyRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningSupplyRequest to update in case it exists.
     */
    where: CleaningSupplyRequestWhereUniqueInput
    /**
     * In case the CleaningSupplyRequest found by the `where` argument doesn't exist, create a new CleaningSupplyRequest with this data.
     */
    create: XOR<CleaningSupplyRequestCreateInput, CleaningSupplyRequestUncheckedCreateInput>
    /**
     * In case the CleaningSupplyRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningSupplyRequestUpdateInput, CleaningSupplyRequestUncheckedUpdateInput>
  }

  /**
   * CleaningSupplyRequest delete
   */
  export type CleaningSupplyRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
    /**
     * Filter which CleaningSupplyRequest to delete.
     */
    where: CleaningSupplyRequestWhereUniqueInput
  }

  /**
   * CleaningSupplyRequest deleteMany
   */
  export type CleaningSupplyRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSupplyRequests to delete
     */
    where?: CleaningSupplyRequestWhereInput
    /**
     * Limit how many CleaningSupplyRequests to delete.
     */
    limit?: number
  }

  /**
   * CleaningSupplyRequest.requestItems
   */
  export type CleaningSupplyRequest$requestItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    where?: CleaningSupplyRequestItemWhereInput
    orderBy?: CleaningSupplyRequestItemOrderByWithRelationInput | CleaningSupplyRequestItemOrderByWithRelationInput[]
    cursor?: CleaningSupplyRequestItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSupplyRequestItemScalarFieldEnum | CleaningSupplyRequestItemScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequest without action
   */
  export type CleaningSupplyRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequest
     */
    select?: CleaningSupplyRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequest
     */
    omit?: CleaningSupplyRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestInclude<ExtArgs> | null
  }


  /**
   * Model CleaningSupplyRequestItem
   */

  export type AggregateCleaningSupplyRequestItem = {
    _count: CleaningSupplyRequestItemCountAggregateOutputType | null
    _avg: CleaningSupplyRequestItemAvgAggregateOutputType | null
    _sum: CleaningSupplyRequestItemSumAggregateOutputType | null
    _min: CleaningSupplyRequestItemMinAggregateOutputType | null
    _max: CleaningSupplyRequestItemMaxAggregateOutputType | null
  }

  export type CleaningSupplyRequestItemAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
    supplyId: number | null
    quantityRequested: number | null
    quantityApproved: number | null
    quantityFulfilled: number | null
  }

  export type CleaningSupplyRequestItemSumAggregateOutputType = {
    id: number | null
    requestId: number | null
    supplyId: number | null
    quantityRequested: number | null
    quantityApproved: number | null
    quantityFulfilled: number | null
  }

  export type CleaningSupplyRequestItemMinAggregateOutputType = {
    id: number | null
    requestId: number | null
    supplyId: number | null
    quantityRequested: number | null
    quantityApproved: number | null
    quantityFulfilled: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningSupplyRequestItemMaxAggregateOutputType = {
    id: number | null
    requestId: number | null
    supplyId: number | null
    quantityRequested: number | null
    quantityApproved: number | null
    quantityFulfilled: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningSupplyRequestItemCountAggregateOutputType = {
    id: number
    requestId: number
    supplyId: number
    quantityRequested: number
    quantityApproved: number
    quantityFulfilled: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningSupplyRequestItemAvgAggregateInputType = {
    id?: true
    requestId?: true
    supplyId?: true
    quantityRequested?: true
    quantityApproved?: true
    quantityFulfilled?: true
  }

  export type CleaningSupplyRequestItemSumAggregateInputType = {
    id?: true
    requestId?: true
    supplyId?: true
    quantityRequested?: true
    quantityApproved?: true
    quantityFulfilled?: true
  }

  export type CleaningSupplyRequestItemMinAggregateInputType = {
    id?: true
    requestId?: true
    supplyId?: true
    quantityRequested?: true
    quantityApproved?: true
    quantityFulfilled?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningSupplyRequestItemMaxAggregateInputType = {
    id?: true
    requestId?: true
    supplyId?: true
    quantityRequested?: true
    quantityApproved?: true
    quantityFulfilled?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningSupplyRequestItemCountAggregateInputType = {
    id?: true
    requestId?: true
    supplyId?: true
    quantityRequested?: true
    quantityApproved?: true
    quantityFulfilled?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningSupplyRequestItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSupplyRequestItem to aggregate.
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequestItems to fetch.
     */
    orderBy?: CleaningSupplyRequestItemOrderByWithRelationInput | CleaningSupplyRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningSupplyRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequestItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningSupplyRequestItems
    **/
    _count?: true | CleaningSupplyRequestItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningSupplyRequestItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningSupplyRequestItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningSupplyRequestItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningSupplyRequestItemMaxAggregateInputType
  }

  export type GetCleaningSupplyRequestItemAggregateType<T extends CleaningSupplyRequestItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningSupplyRequestItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningSupplyRequestItem[P]>
      : GetScalarType<T[P], AggregateCleaningSupplyRequestItem[P]>
  }




  export type CleaningSupplyRequestItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSupplyRequestItemWhereInput
    orderBy?: CleaningSupplyRequestItemOrderByWithAggregationInput | CleaningSupplyRequestItemOrderByWithAggregationInput[]
    by: CleaningSupplyRequestItemScalarFieldEnum[] | CleaningSupplyRequestItemScalarFieldEnum
    having?: CleaningSupplyRequestItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningSupplyRequestItemCountAggregateInputType | true
    _avg?: CleaningSupplyRequestItemAvgAggregateInputType
    _sum?: CleaningSupplyRequestItemSumAggregateInputType
    _min?: CleaningSupplyRequestItemMinAggregateInputType
    _max?: CleaningSupplyRequestItemMaxAggregateInputType
  }

  export type CleaningSupplyRequestItemGroupByOutputType = {
    id: number
    requestId: number
    supplyId: number
    quantityRequested: number
    quantityApproved: number | null
    quantityFulfilled: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CleaningSupplyRequestItemCountAggregateOutputType | null
    _avg: CleaningSupplyRequestItemAvgAggregateOutputType | null
    _sum: CleaningSupplyRequestItemSumAggregateOutputType | null
    _min: CleaningSupplyRequestItemMinAggregateOutputType | null
    _max: CleaningSupplyRequestItemMaxAggregateOutputType | null
  }

  type GetCleaningSupplyRequestItemGroupByPayload<T extends CleaningSupplyRequestItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningSupplyRequestItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningSupplyRequestItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningSupplyRequestItemGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningSupplyRequestItemGroupByOutputType[P]>
        }
      >
    >


  export type CleaningSupplyRequestItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    supplyId?: boolean
    quantityRequested?: boolean
    quantityApproved?: boolean
    quantityFulfilled?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | CleaningSupplyRequestDefaultArgs<ExtArgs>
    supply?: boolean | CleaningSupplyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupplyRequestItem"]>

  export type CleaningSupplyRequestItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    supplyId?: boolean
    quantityRequested?: boolean
    quantityApproved?: boolean
    quantityFulfilled?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | CleaningSupplyRequestDefaultArgs<ExtArgs>
    supply?: boolean | CleaningSupplyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupplyRequestItem"]>

  export type CleaningSupplyRequestItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    supplyId?: boolean
    quantityRequested?: boolean
    quantityApproved?: boolean
    quantityFulfilled?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | CleaningSupplyRequestDefaultArgs<ExtArgs>
    supply?: boolean | CleaningSupplyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSupplyRequestItem"]>

  export type CleaningSupplyRequestItemSelectScalar = {
    id?: boolean
    requestId?: boolean
    supplyId?: boolean
    quantityRequested?: boolean
    quantityApproved?: boolean
    quantityFulfilled?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningSupplyRequestItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "supplyId" | "quantityRequested" | "quantityApproved" | "quantityFulfilled" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningSupplyRequestItem"]>
  export type CleaningSupplyRequestItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | CleaningSupplyRequestDefaultArgs<ExtArgs>
    supply?: boolean | CleaningSupplyDefaultArgs<ExtArgs>
  }
  export type CleaningSupplyRequestItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | CleaningSupplyRequestDefaultArgs<ExtArgs>
    supply?: boolean | CleaningSupplyDefaultArgs<ExtArgs>
  }
  export type CleaningSupplyRequestItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | CleaningSupplyRequestDefaultArgs<ExtArgs>
    supply?: boolean | CleaningSupplyDefaultArgs<ExtArgs>
  }

  export type $CleaningSupplyRequestItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningSupplyRequestItem"
    objects: {
      request: Prisma.$CleaningSupplyRequestPayload<ExtArgs>
      supply: Prisma.$CleaningSupplyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestId: number
      supplyId: number
      quantityRequested: number
      quantityApproved: number | null
      quantityFulfilled: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningSupplyRequestItem"]>
    composites: {}
  }

  type CleaningSupplyRequestItemGetPayload<S extends boolean | null | undefined | CleaningSupplyRequestItemDefaultArgs> = $Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload, S>

  type CleaningSupplyRequestItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningSupplyRequestItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningSupplyRequestItemCountAggregateInputType | true
    }

  export interface CleaningSupplyRequestItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningSupplyRequestItem'], meta: { name: 'CleaningSupplyRequestItem' } }
    /**
     * Find zero or one CleaningSupplyRequestItem that matches the filter.
     * @param {CleaningSupplyRequestItemFindUniqueArgs} args - Arguments to find a CleaningSupplyRequestItem
     * @example
     * // Get one CleaningSupplyRequestItem
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningSupplyRequestItemFindUniqueArgs>(args: SelectSubset<T, CleaningSupplyRequestItemFindUniqueArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningSupplyRequestItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningSupplyRequestItemFindUniqueOrThrowArgs} args - Arguments to find a CleaningSupplyRequestItem
     * @example
     * // Get one CleaningSupplyRequestItem
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningSupplyRequestItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningSupplyRequestItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSupplyRequestItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemFindFirstArgs} args - Arguments to find a CleaningSupplyRequestItem
     * @example
     * // Get one CleaningSupplyRequestItem
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningSupplyRequestItemFindFirstArgs>(args?: SelectSubset<T, CleaningSupplyRequestItemFindFirstArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSupplyRequestItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemFindFirstOrThrowArgs} args - Arguments to find a CleaningSupplyRequestItem
     * @example
     * // Get one CleaningSupplyRequestItem
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningSupplyRequestItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningSupplyRequestItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningSupplyRequestItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningSupplyRequestItems
     * const cleaningSupplyRequestItems = await prisma.cleaningSupplyRequestItem.findMany()
     * 
     * // Get first 10 CleaningSupplyRequestItems
     * const cleaningSupplyRequestItems = await prisma.cleaningSupplyRequestItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningSupplyRequestItemWithIdOnly = await prisma.cleaningSupplyRequestItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningSupplyRequestItemFindManyArgs>(args?: SelectSubset<T, CleaningSupplyRequestItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningSupplyRequestItem.
     * @param {CleaningSupplyRequestItemCreateArgs} args - Arguments to create a CleaningSupplyRequestItem.
     * @example
     * // Create one CleaningSupplyRequestItem
     * const CleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.create({
     *   data: {
     *     // ... data to create a CleaningSupplyRequestItem
     *   }
     * })
     * 
     */
    create<T extends CleaningSupplyRequestItemCreateArgs>(args: SelectSubset<T, CleaningSupplyRequestItemCreateArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningSupplyRequestItems.
     * @param {CleaningSupplyRequestItemCreateManyArgs} args - Arguments to create many CleaningSupplyRequestItems.
     * @example
     * // Create many CleaningSupplyRequestItems
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningSupplyRequestItemCreateManyArgs>(args?: SelectSubset<T, CleaningSupplyRequestItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningSupplyRequestItems and returns the data saved in the database.
     * @param {CleaningSupplyRequestItemCreateManyAndReturnArgs} args - Arguments to create many CleaningSupplyRequestItems.
     * @example
     * // Create many CleaningSupplyRequestItems
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningSupplyRequestItems and only return the `id`
     * const cleaningSupplyRequestItemWithIdOnly = await prisma.cleaningSupplyRequestItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningSupplyRequestItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningSupplyRequestItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningSupplyRequestItem.
     * @param {CleaningSupplyRequestItemDeleteArgs} args - Arguments to delete one CleaningSupplyRequestItem.
     * @example
     * // Delete one CleaningSupplyRequestItem
     * const CleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.delete({
     *   where: {
     *     // ... filter to delete one CleaningSupplyRequestItem
     *   }
     * })
     * 
     */
    delete<T extends CleaningSupplyRequestItemDeleteArgs>(args: SelectSubset<T, CleaningSupplyRequestItemDeleteArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningSupplyRequestItem.
     * @param {CleaningSupplyRequestItemUpdateArgs} args - Arguments to update one CleaningSupplyRequestItem.
     * @example
     * // Update one CleaningSupplyRequestItem
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningSupplyRequestItemUpdateArgs>(args: SelectSubset<T, CleaningSupplyRequestItemUpdateArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningSupplyRequestItems.
     * @param {CleaningSupplyRequestItemDeleteManyArgs} args - Arguments to filter CleaningSupplyRequestItems to delete.
     * @example
     * // Delete a few CleaningSupplyRequestItems
     * const { count } = await prisma.cleaningSupplyRequestItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningSupplyRequestItemDeleteManyArgs>(args?: SelectSubset<T, CleaningSupplyRequestItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSupplyRequestItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningSupplyRequestItems
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningSupplyRequestItemUpdateManyArgs>(args: SelectSubset<T, CleaningSupplyRequestItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSupplyRequestItems and returns the data updated in the database.
     * @param {CleaningSupplyRequestItemUpdateManyAndReturnArgs} args - Arguments to update many CleaningSupplyRequestItems.
     * @example
     * // Update many CleaningSupplyRequestItems
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningSupplyRequestItems and only return the `id`
     * const cleaningSupplyRequestItemWithIdOnly = await prisma.cleaningSupplyRequestItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningSupplyRequestItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningSupplyRequestItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningSupplyRequestItem.
     * @param {CleaningSupplyRequestItemUpsertArgs} args - Arguments to update or create a CleaningSupplyRequestItem.
     * @example
     * // Update or create a CleaningSupplyRequestItem
     * const cleaningSupplyRequestItem = await prisma.cleaningSupplyRequestItem.upsert({
     *   create: {
     *     // ... data to create a CleaningSupplyRequestItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningSupplyRequestItem we want to update
     *   }
     * })
     */
    upsert<T extends CleaningSupplyRequestItemUpsertArgs>(args: SelectSubset<T, CleaningSupplyRequestItemUpsertArgs<ExtArgs>>): Prisma__CleaningSupplyRequestItemClient<$Result.GetResult<Prisma.$CleaningSupplyRequestItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningSupplyRequestItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemCountArgs} args - Arguments to filter CleaningSupplyRequestItems to count.
     * @example
     * // Count the number of CleaningSupplyRequestItems
     * const count = await prisma.cleaningSupplyRequestItem.count({
     *   where: {
     *     // ... the filter for the CleaningSupplyRequestItems we want to count
     *   }
     * })
    **/
    count<T extends CleaningSupplyRequestItemCountArgs>(
      args?: Subset<T, CleaningSupplyRequestItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningSupplyRequestItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningSupplyRequestItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningSupplyRequestItemAggregateArgs>(args: Subset<T, CleaningSupplyRequestItemAggregateArgs>): Prisma.PrismaPromise<GetCleaningSupplyRequestItemAggregateType<T>>

    /**
     * Group by CleaningSupplyRequestItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSupplyRequestItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningSupplyRequestItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningSupplyRequestItemGroupByArgs['orderBy'] }
        : { orderBy?: CleaningSupplyRequestItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningSupplyRequestItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningSupplyRequestItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningSupplyRequestItem model
   */
  readonly fields: CleaningSupplyRequestItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningSupplyRequestItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningSupplyRequestItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends CleaningSupplyRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSupplyRequestDefaultArgs<ExtArgs>>): Prisma__CleaningSupplyRequestClient<$Result.GetResult<Prisma.$CleaningSupplyRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supply<T extends CleaningSupplyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSupplyDefaultArgs<ExtArgs>>): Prisma__CleaningSupplyClient<$Result.GetResult<Prisma.$CleaningSupplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningSupplyRequestItem model
   */
  interface CleaningSupplyRequestItemFieldRefs {
    readonly id: FieldRef<"CleaningSupplyRequestItem", 'Int'>
    readonly requestId: FieldRef<"CleaningSupplyRequestItem", 'Int'>
    readonly supplyId: FieldRef<"CleaningSupplyRequestItem", 'Int'>
    readonly quantityRequested: FieldRef<"CleaningSupplyRequestItem", 'Int'>
    readonly quantityApproved: FieldRef<"CleaningSupplyRequestItem", 'Int'>
    readonly quantityFulfilled: FieldRef<"CleaningSupplyRequestItem", 'Int'>
    readonly notes: FieldRef<"CleaningSupplyRequestItem", 'String'>
    readonly createdAt: FieldRef<"CleaningSupplyRequestItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningSupplyRequestItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningSupplyRequestItem findUnique
   */
  export type CleaningSupplyRequestItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequestItem to fetch.
     */
    where: CleaningSupplyRequestItemWhereUniqueInput
  }

  /**
   * CleaningSupplyRequestItem findUniqueOrThrow
   */
  export type CleaningSupplyRequestItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequestItem to fetch.
     */
    where: CleaningSupplyRequestItemWhereUniqueInput
  }

  /**
   * CleaningSupplyRequestItem findFirst
   */
  export type CleaningSupplyRequestItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequestItem to fetch.
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequestItems to fetch.
     */
    orderBy?: CleaningSupplyRequestItemOrderByWithRelationInput | CleaningSupplyRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSupplyRequestItems.
     */
    cursor?: CleaningSupplyRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequestItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSupplyRequestItems.
     */
    distinct?: CleaningSupplyRequestItemScalarFieldEnum | CleaningSupplyRequestItemScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequestItem findFirstOrThrow
   */
  export type CleaningSupplyRequestItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequestItem to fetch.
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequestItems to fetch.
     */
    orderBy?: CleaningSupplyRequestItemOrderByWithRelationInput | CleaningSupplyRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSupplyRequestItems.
     */
    cursor?: CleaningSupplyRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequestItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSupplyRequestItems.
     */
    distinct?: CleaningSupplyRequestItemScalarFieldEnum | CleaningSupplyRequestItemScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequestItem findMany
   */
  export type CleaningSupplyRequestItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSupplyRequestItems to fetch.
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSupplyRequestItems to fetch.
     */
    orderBy?: CleaningSupplyRequestItemOrderByWithRelationInput | CleaningSupplyRequestItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningSupplyRequestItems.
     */
    cursor?: CleaningSupplyRequestItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSupplyRequestItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSupplyRequestItems.
     */
    skip?: number
    distinct?: CleaningSupplyRequestItemScalarFieldEnum | CleaningSupplyRequestItemScalarFieldEnum[]
  }

  /**
   * CleaningSupplyRequestItem create
   */
  export type CleaningSupplyRequestItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningSupplyRequestItem.
     */
    data: XOR<CleaningSupplyRequestItemCreateInput, CleaningSupplyRequestItemUncheckedCreateInput>
  }

  /**
   * CleaningSupplyRequestItem createMany
   */
  export type CleaningSupplyRequestItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningSupplyRequestItems.
     */
    data: CleaningSupplyRequestItemCreateManyInput | CleaningSupplyRequestItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningSupplyRequestItem createManyAndReturn
   */
  export type CleaningSupplyRequestItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningSupplyRequestItems.
     */
    data: CleaningSupplyRequestItemCreateManyInput | CleaningSupplyRequestItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSupplyRequestItem update
   */
  export type CleaningSupplyRequestItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningSupplyRequestItem.
     */
    data: XOR<CleaningSupplyRequestItemUpdateInput, CleaningSupplyRequestItemUncheckedUpdateInput>
    /**
     * Choose, which CleaningSupplyRequestItem to update.
     */
    where: CleaningSupplyRequestItemWhereUniqueInput
  }

  /**
   * CleaningSupplyRequestItem updateMany
   */
  export type CleaningSupplyRequestItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningSupplyRequestItems.
     */
    data: XOR<CleaningSupplyRequestItemUpdateManyMutationInput, CleaningSupplyRequestItemUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSupplyRequestItems to update
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * Limit how many CleaningSupplyRequestItems to update.
     */
    limit?: number
  }

  /**
   * CleaningSupplyRequestItem updateManyAndReturn
   */
  export type CleaningSupplyRequestItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * The data used to update CleaningSupplyRequestItems.
     */
    data: XOR<CleaningSupplyRequestItemUpdateManyMutationInput, CleaningSupplyRequestItemUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSupplyRequestItems to update
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * Limit how many CleaningSupplyRequestItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSupplyRequestItem upsert
   */
  export type CleaningSupplyRequestItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningSupplyRequestItem to update in case it exists.
     */
    where: CleaningSupplyRequestItemWhereUniqueInput
    /**
     * In case the CleaningSupplyRequestItem found by the `where` argument doesn't exist, create a new CleaningSupplyRequestItem with this data.
     */
    create: XOR<CleaningSupplyRequestItemCreateInput, CleaningSupplyRequestItemUncheckedCreateInput>
    /**
     * In case the CleaningSupplyRequestItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningSupplyRequestItemUpdateInput, CleaningSupplyRequestItemUncheckedUpdateInput>
  }

  /**
   * CleaningSupplyRequestItem delete
   */
  export type CleaningSupplyRequestItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
    /**
     * Filter which CleaningSupplyRequestItem to delete.
     */
    where: CleaningSupplyRequestItemWhereUniqueInput
  }

  /**
   * CleaningSupplyRequestItem deleteMany
   */
  export type CleaningSupplyRequestItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSupplyRequestItems to delete
     */
    where?: CleaningSupplyRequestItemWhereInput
    /**
     * Limit how many CleaningSupplyRequestItems to delete.
     */
    limit?: number
  }

  /**
   * CleaningSupplyRequestItem without action
   */
  export type CleaningSupplyRequestItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSupplyRequestItem
     */
    select?: CleaningSupplyRequestItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSupplyRequestItem
     */
    omit?: CleaningSupplyRequestItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSupplyRequestItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    roleId: 'roleId',
    status: 'status',
    phoneNumber: 'phoneNumber',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    profileImage: 'profileImage',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    provider: 'provider',
    providerId: 'providerId',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    specialization: 'specialization',
    qualification: 'qualification',
    experience: 'experience',
    licenseNumber: 'licenseNumber',
    consultationFee: 'consultationFee',
    availableDays: 'availableDays',
    availableTimeStart: 'availableTimeStart',
    availableTimeEnd: 'availableTimeEnd',
    department: 'department',
    bio: 'bio',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    patientId: 'patientId',
    bloodGroup: 'bloodGroup',
    height: 'height',
    weight: 'weight',
    allergies: 'allergies',
    chronicDiseases: 'chronicDiseases',
    emergencyContact: 'emergencyContact',
    emergencyName: 'emergencyName',
    emergencyRelation: 'emergencyRelation',
    insuranceProvider: 'insuranceProvider',
    insuranceId: 'insuranceId',
    tpaId: 'tpaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const NurseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licenseNumber: 'licenseNumber',
    qualification: 'qualification',
    experience: 'experience',
    department: 'department',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NurseScalarFieldEnum = (typeof NurseScalarFieldEnum)[keyof typeof NurseScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    appointmentDate: 'appointmentDate',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    reason: 'reason',
    notes: 'notes',
    followUp: 'followUp',
    followUpDate: 'followUpDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    appointmentId: 'appointmentId',
    prescriptionDate: 'prescriptionDate',
    diagnosis: 'diagnosis',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionMedicineScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    medicineId: 'medicineId',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    instructions: 'instructions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrescriptionMedicineScalarFieldEnum = (typeof PrescriptionMedicineScalarFieldEnum)[keyof typeof PrescriptionMedicineScalarFieldEnum]


  export const MedicineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genericName: 'genericName',
    category: 'category',
    manufacturer: 'manufacturer',
    description: 'description',
    dosageForm: 'dosageForm',
    strength: 'strength',
    price: 'price',
    stock: 'stock',
    reorderLevel: 'reorderLevel',
    expiryDate: 'expiryDate',
    batchNumber: 'batchNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineScalarFieldEnum = (typeof MedicineScalarFieldEnum)[keyof typeof MedicineScalarFieldEnum]


  export const InventoryLogScalarFieldEnum: {
    id: 'id',
    medicineId: 'medicineId',
    quantity: 'quantity',
    type: 'type',
    reason: 'reason',
    referenceId: 'referenceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryLogScalarFieldEnum = (typeof InventoryLogScalarFieldEnum)[keyof typeof InventoryLogScalarFieldEnum]


  export const LabReportScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    appointmentId: 'appointmentId',
    testDate: 'testDate',
    reportDate: 'reportDate',
    testType: 'testType',
    testResult: 'testResult',
    normalRange: 'normalRange',
    notes: 'notes',
    attachmentUrl: 'attachmentUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabReportScalarFieldEnum = (typeof LabReportScalarFieldEnum)[keyof typeof LabReportScalarFieldEnum]


  export const RadiologyReportScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    appointmentId: 'appointmentId',
    testDate: 'testDate',
    reportDate: 'reportDate',
    testType: 'testType',
    findings: 'findings',
    impression: 'impression',
    notes: 'notes',
    attachmentUrl: 'attachmentUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RadiologyReportScalarFieldEnum = (typeof RadiologyReportScalarFieldEnum)[keyof typeof RadiologyReportScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    invoiceNumber: 'invoiceNumber',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    totalAmount: 'totalAmount',
    discountAmount: 'discountAmount',
    taxAmount: 'taxAmount',
    netAmount: 'netAmount',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemType: 'itemType',
    itemId: 'itemId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    labReportId: 'labReportId',
    radiologyReportId: 'radiologyReportId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    patientId: 'patientId',
    paymentDate: 'paymentDate',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const BedScalarFieldEnum: {
    id: 'id',
    bedNumber: 'bedNumber',
    wardId: 'wardId',
    status: 'status',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BedScalarFieldEnum = (typeof BedScalarFieldEnum)[keyof typeof BedScalarFieldEnum]


  export const WardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    wardType: 'wardType',
    floor: 'floor',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WardScalarFieldEnum = (typeof WardScalarFieldEnum)[keyof typeof WardScalarFieldEnum]


  export const BedAllocationScalarFieldEnum: {
    id: 'id',
    bedId: 'bedId',
    patientId: 'patientId',
    nurseId: 'nurseId',
    allocatedAt: 'allocatedAt',
    dischargedAt: 'dischargedAt',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BedAllocationScalarFieldEnum = (typeof BedAllocationScalarFieldEnum)[keyof typeof BedAllocationScalarFieldEnum]


  export const VitalSignScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    recordedBy: 'recordedBy',
    temperature: 'temperature',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    heartRate: 'heartRate',
    respiratoryRate: 'respiratoryRate',
    oxygenSaturation: 'oxygenSaturation',
    height: 'height',
    weight: 'weight',
    notes: 'notes',
    recordedAt: 'recordedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VitalSignScalarFieldEnum = (typeof VitalSignScalarFieldEnum)[keyof typeof VitalSignScalarFieldEnum]


  export const OperationTheaterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    status: 'status',
    doctorId: 'doctorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperationTheaterScalarFieldEnum = (typeof OperationTheaterScalarFieldEnum)[keyof typeof OperationTheaterScalarFieldEnum]


  export const SurgeryScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    operationTheaterId: 'operationTheaterId',
    surgeryDate: 'surgeryDate',
    startTime: 'startTime',
    endTime: 'endTime',
    surgeryType: 'surgeryType',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurgeryScalarFieldEnum = (typeof SurgeryScalarFieldEnum)[keyof typeof SurgeryScalarFieldEnum]


  export const OperationTheaterEquipmentScalarFieldEnum: {
    id: 'id',
    operationTheaterId: 'operationTheaterId',
    name: 'name',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    purchaseDate: 'purchaseDate',
    lastMaintenanceDate: 'lastMaintenanceDate',
    nextMaintenanceDate: 'nextMaintenanceDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperationTheaterEquipmentScalarFieldEnum = (typeof OperationTheaterEquipmentScalarFieldEnum)[keyof typeof OperationTheaterEquipmentScalarFieldEnum]


  export const MedicalGasCylinderScalarFieldEnum: {
    id: 'id',
    cylinderNumber: 'cylinderNumber',
    gasType: 'gasType',
    capacity: 'capacity',
    currentLevel: 'currentLevel',
    location: 'location',
    status: 'status',
    lastRefillDate: 'lastRefillDate',
    nextRefillDate: 'nextRefillDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalGasCylinderScalarFieldEnum = (typeof MedicalGasCylinderScalarFieldEnum)[keyof typeof MedicalGasCylinderScalarFieldEnum]


  export const EquipmentMaintenanceScalarFieldEnum: {
    id: 'id',
    equipmentType: 'equipmentType',
    equipmentId: 'equipmentId',
    maintenanceDate: 'maintenanceDate',
    maintenanceType: 'maintenanceType',
    performedBy: 'performedBy',
    cost: 'cost',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentMaintenanceScalarFieldEnum = (typeof EquipmentMaintenanceScalarFieldEnum)[keyof typeof EquipmentMaintenanceScalarFieldEnum]


  export const AmbulanceScalarFieldEnum: {
    id: 'id',
    vehicleNumber: 'vehicleNumber',
    model: 'model',
    type: 'type',
    capacity: 'capacity',
    driverName: 'driverName',
    driverContact: 'driverContact',
    status: 'status',
    lastMaintenanceDate: 'lastMaintenanceDate',
    nextMaintenanceDate: 'nextMaintenanceDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmbulanceScalarFieldEnum = (typeof AmbulanceScalarFieldEnum)[keyof typeof AmbulanceScalarFieldEnum]


  export const AmbulanceServiceScalarFieldEnum: {
    id: 'id',
    ambulanceId: 'ambulanceId',
    patientName: 'patientName',
    patientContact: 'patientContact',
    pickupLocation: 'pickupLocation',
    dropLocation: 'dropLocation',
    serviceDate: 'serviceDate',
    status: 'status',
    fare: 'fare',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmbulanceServiceScalarFieldEnum = (typeof AmbulanceServiceScalarFieldEnum)[keyof typeof AmbulanceServiceScalarFieldEnum]


  export const BiometricDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    biometricId: 'biometricId',
    fingerprint: 'fingerprint',
    faceData: 'faceData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiometricDataScalarFieldEnum = (typeof BiometricDataScalarFieldEnum)[keyof typeof BiometricDataScalarFieldEnum]


  export const AttendanceLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    status: 'status',
    deviceId: 'deviceId',
    verificationMode: 'verificationMode',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceLogScalarFieldEnum = (typeof AttendanceLogScalarFieldEnum)[keyof typeof AttendanceLogScalarFieldEnum]


  export const DutyRosterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startDate: 'startDate',
    endDate: 'endDate',
    shiftStart: 'shiftStart',
    shiftEnd: 'shiftEnd',
    department: 'department',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DutyRosterScalarFieldEnum = (typeof DutyRosterScalarFieldEnum)[keyof typeof DutyRosterScalarFieldEnum]


  export const TPAScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    contactNumber: 'contactNumber',
    email: 'email',
    address: 'address',
    contractStartDate: 'contractStartDate',
    contractEndDate: 'contractEndDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TPAScalarFieldEnum = (typeof TPAScalarFieldEnum)[keyof typeof TPAScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeId: 'employeeId',
    department: 'department',
    position: 'position',
    joiningDate: 'joiningDate',
    contractType: 'contractType',
    contractEndDate: 'contractEndDate',
    salary: 'salary',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    ifscCode: 'ifscCode',
    panNumber: 'panNumber',
    emergencyContact: 'emergencyContact',
    emergencyName: 'emergencyName',
    emergencyRelation: 'emergencyRelation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    totalDays: 'totalDays',
    reason: 'reason',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const SalaryPaymentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    paymentDate: 'paymentDate',
    salaryMonth: 'salaryMonth',
    basicSalary: 'basicSalary',
    allowances: 'allowances',
    deductions: 'deductions',
    taxDeducted: 'taxDeducted',
    netSalary: 'netSalary',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryPaymentScalarFieldEnum = (typeof SalaryPaymentScalarFieldEnum)[keyof typeof SalaryPaymentScalarFieldEnum]


  export const EmployeeDocumentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    documentType: 'documentType',
    documentName: 'documentName',
    documentUrl: 'documentUrl',
    isVerified: 'isVerified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeDocumentScalarFieldEnum = (typeof EmployeeDocumentScalarFieldEnum)[keyof typeof EmployeeDocumentScalarFieldEnum]


  export const PerformanceReviewScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    reviewDate: 'reviewDate',
    reviewPeriodStart: 'reviewPeriodStart',
    reviewPeriodEnd: 'reviewPeriodEnd',
    reviewedBy: 'reviewedBy',
    rating: 'rating',
    strengths: 'strengths',
    areasOfImprovement: 'areasOfImprovement',
    goals: 'goals',
    comments: 'comments',
    employeeComments: 'employeeComments',
    status: 'status',
    acknowledgedAt: 'acknowledgedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceReviewScalarFieldEnum = (typeof PerformanceReviewScalarFieldEnum)[keyof typeof PerformanceReviewScalarFieldEnum]


  export const SubsidySchemeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    issuingAuthority: 'issuingAuthority',
    startDate: 'startDate',
    endDate: 'endDate',
    eligibilityCriteria: 'eligibilityCriteria',
    subsidyType: 'subsidyType',
    percentageValue: 'percentageValue',
    fixedAmount: 'fixedAmount',
    maxCoverageAmount: 'maxCoverageAmount',
    maxCoveragePerTreatment: 'maxCoveragePerTreatment',
    applicableServices: 'applicableServices',
    documentationRequired: 'documentationRequired',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubsidySchemeScalarFieldEnum = (typeof SubsidySchemeScalarFieldEnum)[keyof typeof SubsidySchemeScalarFieldEnum]


  export const PatientSubsidyScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    schemeId: 'schemeId',
    enrollmentDate: 'enrollmentDate',
    enrollmentNumber: 'enrollmentNumber',
    cardNumber: 'cardNumber',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    remainingBalance: 'remainingBalance',
    status: 'status',
    verificationStatus: 'verificationStatus',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientSubsidyScalarFieldEnum = (typeof PatientSubsidyScalarFieldEnum)[keyof typeof PatientSubsidyScalarFieldEnum]


  export const SubsidyClaimScalarFieldEnum: {
    id: 'id',
    patientSubsidyId: 'patientSubsidyId',
    schemeId: 'schemeId',
    invoiceId: 'invoiceId',
    claimDate: 'claimDate',
    claimAmount: 'claimAmount',
    approvedAmount: 'approvedAmount',
    rejectionReason: 'rejectionReason',
    claimStatus: 'claimStatus',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    reimbursementDate: 'reimbursementDate',
    transactionId: 'transactionId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubsidyClaimScalarFieldEnum = (typeof SubsidyClaimScalarFieldEnum)[keyof typeof SubsidyClaimScalarFieldEnum]


  export const HousekeepingAreaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    floor: 'floor',
    buildingSection: 'buildingSection',
    priority: 'priority',
    cleaningFrequency: 'cleaningFrequency',
    specialInstructions: 'specialInstructions',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HousekeepingAreaScalarFieldEnum = (typeof HousekeepingAreaScalarFieldEnum)[keyof typeof HousekeepingAreaScalarFieldEnum]


  export const HousekeepingStaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    staffId: 'staffId',
    supervisor: 'supervisor',
    specializedAreas: 'specializedAreas',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HousekeepingStaffScalarFieldEnum = (typeof HousekeepingStaffScalarFieldEnum)[keyof typeof HousekeepingStaffScalarFieldEnum]


  export const CleaningTaskScalarFieldEnum: {
    id: 'id',
    areaId: 'areaId',
    assignedToId: 'assignedToId',
    scheduledDate: 'scheduledDate',
    scheduledTime: 'scheduledTime',
    estimatedDuration: 'estimatedDuration',
    priority: 'priority',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningTaskScalarFieldEnum = (typeof CleaningTaskScalarFieldEnum)[keyof typeof CleaningTaskScalarFieldEnum]


  export const CleaningVerificationScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    verifiedById: 'verifiedById',
    verificationDate: 'verificationDate',
    rating: 'rating',
    cleanliness: 'cleanliness',
    comments: 'comments',
    photosUrl: 'photosUrl',
    status: 'status',
    followUpRequired: 'followUpRequired',
    followUpNotes: 'followUpNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningVerificationScalarFieldEnum = (typeof CleaningVerificationScalarFieldEnum)[keyof typeof CleaningVerificationScalarFieldEnum]


  export const CleaningSupplyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    unit: 'unit',
    currentStock: 'currentStock',
    reorderLevel: 'reorderLevel',
    location: 'location',
    supplier: 'supplier',
    lastPurchaseDate: 'lastPurchaseDate',
    lastPurchasePrice: 'lastPurchasePrice',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningSupplyScalarFieldEnum = (typeof CleaningSupplyScalarFieldEnum)[keyof typeof CleaningSupplyScalarFieldEnum]


  export const CleaningSupplyRequestScalarFieldEnum: {
    id: 'id',
    requestedById: 'requestedById',
    requestDate: 'requestDate',
    requiredBy: 'requiredBy',
    status: 'status',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    fulfilledAt: 'fulfilledAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningSupplyRequestScalarFieldEnum = (typeof CleaningSupplyRequestScalarFieldEnum)[keyof typeof CleaningSupplyRequestScalarFieldEnum]


  export const CleaningSupplyRequestItemScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    supplyId: 'supplyId',
    quantityRequested: 'quantityRequested',
    quantityApproved: 'quantityApproved',
    quantityFulfilled: 'quantityFulfilled',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningSupplyRequestItemScalarFieldEnum = (typeof CleaningSupplyRequestItemScalarFieldEnum)[keyof typeof CleaningSupplyRequestItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    category?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    roleId?: IntNullableFilter<"User"> | number | null
    status?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    provider?: StringNullableFilter<"User"> | string | null
    providerId?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    passwordReset?: XOR<PasswordResetNullableScalarRelationFilter, PasswordResetWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    nurse?: XOR<NurseNullableScalarRelationFilter, NurseWhereInput> | null
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    biometricData?: XOR<BiometricDataNullableScalarRelationFilter, BiometricDataWhereInput> | null
    attendanceLogs?: AttendanceLogListRelationFilter
    dutyRosters?: DutyRosterListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    housekeepingStaff?: XOR<HousekeepingStaffNullableScalarRelationFilter, HousekeepingStaffWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    roleId?: SortOrderInput | SortOrder
    status?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    passwordReset?: PasswordResetOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    nurse?: NurseOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    biometricData?: BiometricDataOrderByWithRelationInput
    attendanceLogs?: AttendanceLogOrderByRelationAggregateInput
    dutyRosters?: DutyRosterOrderByRelationAggregateInput
    employee?: EmployeeOrderByWithRelationInput
    housekeepingStaff?: HousekeepingStaffOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    roleId?: IntNullableFilter<"User"> | number | null
    status?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    provider?: StringNullableFilter<"User"> | string | null
    providerId?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    passwordReset?: XOR<PasswordResetNullableScalarRelationFilter, PasswordResetWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    nurse?: XOR<NurseNullableScalarRelationFilter, NurseWhereInput> | null
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    biometricData?: XOR<BiometricDataNullableScalarRelationFilter, BiometricDataWhereInput> | null
    attendanceLogs?: AttendanceLogListRelationFilter
    dutyRosters?: DutyRosterListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    housekeepingStaff?: XOR<HousekeepingStaffNullableScalarRelationFilter, HousekeepingStaffWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    roleId?: SortOrderInput | SortOrder
    status?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    roleId?: IntNullableWithAggregatesFilter<"User"> | number | null
    status?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    provider?: StringNullableWithAggregatesFilter<"User"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    userId?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    token?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _avg?: PasswordResetAvgOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
    _sum?: PasswordResetSumOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordReset"> | number
    userId?: IntWithAggregatesFilter<"PasswordReset"> | number
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: IntFilter<"Doctor"> | number
    userId?: IntFilter<"Doctor"> | number
    specialization?: StringFilter<"Doctor"> | string
    qualification?: StringFilter<"Doctor"> | string
    experience?: IntFilter<"Doctor"> | number
    licenseNumber?: StringFilter<"Doctor"> | string
    consultationFee?: DecimalFilter<"Doctor"> | Decimal | DecimalJsLike | number | string
    availableDays?: StringNullableFilter<"Doctor"> | string | null
    availableTimeStart?: StringNullableFilter<"Doctor"> | string | null
    availableTimeEnd?: StringNullableFilter<"Doctor"> | string | null
    department?: StringNullableFilter<"Doctor"> | string | null
    bio?: StringNullableFilter<"Doctor"> | string | null
    isVerified?: BoolFilter<"Doctor"> | boolean
    createdAt?: DateTimeFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointments?: AppointmentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    labReports?: LabReportListRelationFilter
    radiologyReports?: RadiologyReportListRelationFilter
    operationTheaters?: OperationTheaterListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    consultationFee?: SortOrder
    availableDays?: SortOrderInput | SortOrder
    availableTimeStart?: SortOrderInput | SortOrder
    availableTimeEnd?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    labReports?: LabReportOrderByRelationAggregateInput
    radiologyReports?: RadiologyReportOrderByRelationAggregateInput
    operationTheaters?: OperationTheaterOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    licenseNumber?: string
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    specialization?: StringFilter<"Doctor"> | string
    qualification?: StringFilter<"Doctor"> | string
    experience?: IntFilter<"Doctor"> | number
    consultationFee?: DecimalFilter<"Doctor"> | Decimal | DecimalJsLike | number | string
    availableDays?: StringNullableFilter<"Doctor"> | string | null
    availableTimeStart?: StringNullableFilter<"Doctor"> | string | null
    availableTimeEnd?: StringNullableFilter<"Doctor"> | string | null
    department?: StringNullableFilter<"Doctor"> | string | null
    bio?: StringNullableFilter<"Doctor"> | string | null
    isVerified?: BoolFilter<"Doctor"> | boolean
    createdAt?: DateTimeFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointments?: AppointmentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    labReports?: LabReportListRelationFilter
    radiologyReports?: RadiologyReportListRelationFilter
    operationTheaters?: OperationTheaterListRelationFilter
  }, "id" | "userId" | "licenseNumber">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    consultationFee?: SortOrder
    availableDays?: SortOrderInput | SortOrder
    availableTimeStart?: SortOrderInput | SortOrder
    availableTimeEnd?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _avg?: DoctorAvgOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
    _sum?: DoctorSumOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Doctor"> | number
    userId?: IntWithAggregatesFilter<"Doctor"> | number
    specialization?: StringWithAggregatesFilter<"Doctor"> | string
    qualification?: StringWithAggregatesFilter<"Doctor"> | string
    experience?: IntWithAggregatesFilter<"Doctor"> | number
    licenseNumber?: StringWithAggregatesFilter<"Doctor"> | string
    consultationFee?: DecimalWithAggregatesFilter<"Doctor"> | Decimal | DecimalJsLike | number | string
    availableDays?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    availableTimeStart?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    availableTimeEnd?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    department?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Doctor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    userId?: IntFilter<"Patient"> | number
    patientId?: StringFilter<"Patient"> | string
    bloodGroup?: StringNullableFilter<"Patient"> | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    chronicDiseases?: StringNullableFilter<"Patient"> | string | null
    emergencyContact?: StringNullableFilter<"Patient"> | string | null
    emergencyName?: StringNullableFilter<"Patient"> | string | null
    emergencyRelation?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insuranceId?: StringNullableFilter<"Patient"> | string | null
    tpaId?: IntNullableFilter<"Patient"> | number | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tpa?: XOR<TPANullableScalarRelationFilter, TPAWhereInput> | null
    appointments?: AppointmentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    labReports?: LabReportListRelationFilter
    radiologyReports?: RadiologyReportListRelationFilter
    invoices?: InvoiceListRelationFilter
    bedAllocations?: BedAllocationListRelationFilter
    vitalSigns?: VitalSignListRelationFilter
    patientSubsidies?: PatientSubsidyListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    patientId?: SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicDiseases?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyName?: SortOrderInput | SortOrder
    emergencyRelation?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insuranceId?: SortOrderInput | SortOrder
    tpaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tpa?: TPAOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    labReports?: LabReportOrderByRelationAggregateInput
    radiologyReports?: RadiologyReportOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    bedAllocations?: BedAllocationOrderByRelationAggregateInput
    vitalSigns?: VitalSignOrderByRelationAggregateInput
    patientSubsidies?: PatientSubsidyOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    patientId?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    bloodGroup?: StringNullableFilter<"Patient"> | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    chronicDiseases?: StringNullableFilter<"Patient"> | string | null
    emergencyContact?: StringNullableFilter<"Patient"> | string | null
    emergencyName?: StringNullableFilter<"Patient"> | string | null
    emergencyRelation?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insuranceId?: StringNullableFilter<"Patient"> | string | null
    tpaId?: IntNullableFilter<"Patient"> | number | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tpa?: XOR<TPANullableScalarRelationFilter, TPAWhereInput> | null
    appointments?: AppointmentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    labReports?: LabReportListRelationFilter
    radiologyReports?: RadiologyReportListRelationFilter
    invoices?: InvoiceListRelationFilter
    bedAllocations?: BedAllocationListRelationFilter
    vitalSigns?: VitalSignListRelationFilter
    patientSubsidies?: PatientSubsidyListRelationFilter
  }, "id" | "userId" | "patientId">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    patientId?: SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicDiseases?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyName?: SortOrderInput | SortOrder
    emergencyRelation?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insuranceId?: SortOrderInput | SortOrder
    tpaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    userId?: IntWithAggregatesFilter<"Patient"> | number
    patientId?: StringWithAggregatesFilter<"Patient"> | string
    bloodGroup?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    height?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    allergies?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    chronicDiseases?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyRelation?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    tpaId?: IntNullableWithAggregatesFilter<"Patient"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type NurseWhereInput = {
    AND?: NurseWhereInput | NurseWhereInput[]
    OR?: NurseWhereInput[]
    NOT?: NurseWhereInput | NurseWhereInput[]
    id?: IntFilter<"Nurse"> | number
    userId?: IntFilter<"Nurse"> | number
    licenseNumber?: StringFilter<"Nurse"> | string
    qualification?: StringFilter<"Nurse"> | string
    experience?: IntFilter<"Nurse"> | number
    department?: StringNullableFilter<"Nurse"> | string | null
    createdAt?: DateTimeFilter<"Nurse"> | Date | string
    updatedAt?: DateTimeFilter<"Nurse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    vitalSigns?: VitalSignListRelationFilter
    bedAllocations?: BedAllocationListRelationFilter
  }

  export type NurseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vitalSigns?: VitalSignOrderByRelationAggregateInput
    bedAllocations?: BedAllocationOrderByRelationAggregateInput
  }

  export type NurseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    licenseNumber?: string
    AND?: NurseWhereInput | NurseWhereInput[]
    OR?: NurseWhereInput[]
    NOT?: NurseWhereInput | NurseWhereInput[]
    qualification?: StringFilter<"Nurse"> | string
    experience?: IntFilter<"Nurse"> | number
    department?: StringNullableFilter<"Nurse"> | string | null
    createdAt?: DateTimeFilter<"Nurse"> | Date | string
    updatedAt?: DateTimeFilter<"Nurse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    vitalSigns?: VitalSignListRelationFilter
    bedAllocations?: BedAllocationListRelationFilter
  }, "id" | "userId" | "licenseNumber">

  export type NurseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NurseCountOrderByAggregateInput
    _avg?: NurseAvgOrderByAggregateInput
    _max?: NurseMaxOrderByAggregateInput
    _min?: NurseMinOrderByAggregateInput
    _sum?: NurseSumOrderByAggregateInput
  }

  export type NurseScalarWhereWithAggregatesInput = {
    AND?: NurseScalarWhereWithAggregatesInput | NurseScalarWhereWithAggregatesInput[]
    OR?: NurseScalarWhereWithAggregatesInput[]
    NOT?: NurseScalarWhereWithAggregatesInput | NurseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Nurse"> | number
    userId?: IntWithAggregatesFilter<"Nurse"> | number
    licenseNumber?: StringWithAggregatesFilter<"Nurse"> | string
    qualification?: StringWithAggregatesFilter<"Nurse"> | string
    experience?: IntWithAggregatesFilter<"Nurse"> | number
    department?: StringNullableWithAggregatesFilter<"Nurse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Nurse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Nurse"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntFilter<"Appointment"> | number
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    startTime?: StringFilter<"Appointment"> | string
    endTime?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    followUp?: BoolFilter<"Appointment"> | boolean
    followUpDate?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    prescriptions?: PrescriptionListRelationFilter
    labReports?: LabReportListRelationFilter
    radiologyReports?: RadiologyReportListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    followUp?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    labReports?: LabReportOrderByRelationAggregateInput
    radiologyReports?: RadiologyReportOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntFilter<"Appointment"> | number
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    startTime?: StringFilter<"Appointment"> | string
    endTime?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    followUp?: BoolFilter<"Appointment"> | boolean
    followUpDate?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    prescriptions?: PrescriptionListRelationFilter
    labReports?: LabReportListRelationFilter
    radiologyReports?: RadiologyReportListRelationFilter
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    followUp?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    patientId?: IntWithAggregatesFilter<"Appointment"> | number
    doctorId?: IntWithAggregatesFilter<"Appointment"> | number
    appointmentDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    startTime?: StringWithAggregatesFilter<"Appointment"> | string
    endTime?: StringWithAggregatesFilter<"Appointment"> | string
    status?: StringWithAggregatesFilter<"Appointment"> | string
    reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    followUp?: BoolWithAggregatesFilter<"Appointment"> | boolean
    followUpDate?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: IntFilter<"Prescription"> | number
    patientId?: IntFilter<"Prescription"> | number
    doctorId?: IntFilter<"Prescription"> | number
    appointmentId?: IntNullableFilter<"Prescription"> | number | null
    prescriptionDate?: DateTimeFilter<"Prescription"> | Date | string
    diagnosis?: StringFilter<"Prescription"> | string
    notes?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    medicines?: PrescriptionMedicineListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    prescriptionDate?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    medicines?: PrescriptionMedicineOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    patientId?: IntFilter<"Prescription"> | number
    doctorId?: IntFilter<"Prescription"> | number
    appointmentId?: IntNullableFilter<"Prescription"> | number | null
    prescriptionDate?: DateTimeFilter<"Prescription"> | Date | string
    diagnosis?: StringFilter<"Prescription"> | string
    notes?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    medicines?: PrescriptionMedicineListRelationFilter
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    prescriptionDate?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prescription"> | number
    patientId?: IntWithAggregatesFilter<"Prescription"> | number
    doctorId?: IntWithAggregatesFilter<"Prescription"> | number
    appointmentId?: IntNullableWithAggregatesFilter<"Prescription"> | number | null
    prescriptionDate?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    diagnosis?: StringWithAggregatesFilter<"Prescription"> | string
    notes?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
  }

  export type PrescriptionMedicineWhereInput = {
    AND?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    OR?: PrescriptionMedicineWhereInput[]
    NOT?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    id?: IntFilter<"PrescriptionMedicine"> | number
    prescriptionId?: IntFilter<"PrescriptionMedicine"> | number
    medicineId?: IntFilter<"PrescriptionMedicine"> | number
    dosage?: StringFilter<"PrescriptionMedicine"> | string
    frequency?: StringFilter<"PrescriptionMedicine"> | string
    duration?: StringFilter<"PrescriptionMedicine"> | string
    instructions?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    createdAt?: DateTimeFilter<"PrescriptionMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"PrescriptionMedicine"> | Date | string
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }

  export type PrescriptionMedicineOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
    medicine?: MedicineOrderByWithRelationInput
  }

  export type PrescriptionMedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    OR?: PrescriptionMedicineWhereInput[]
    NOT?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    prescriptionId?: IntFilter<"PrescriptionMedicine"> | number
    medicineId?: IntFilter<"PrescriptionMedicine"> | number
    dosage?: StringFilter<"PrescriptionMedicine"> | string
    frequency?: StringFilter<"PrescriptionMedicine"> | string
    duration?: StringFilter<"PrescriptionMedicine"> | string
    instructions?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    createdAt?: DateTimeFilter<"PrescriptionMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"PrescriptionMedicine"> | Date | string
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }, "id">

  export type PrescriptionMedicineOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrescriptionMedicineCountOrderByAggregateInput
    _avg?: PrescriptionMedicineAvgOrderByAggregateInput
    _max?: PrescriptionMedicineMaxOrderByAggregateInput
    _min?: PrescriptionMedicineMinOrderByAggregateInput
    _sum?: PrescriptionMedicineSumOrderByAggregateInput
  }

  export type PrescriptionMedicineScalarWhereWithAggregatesInput = {
    AND?: PrescriptionMedicineScalarWhereWithAggregatesInput | PrescriptionMedicineScalarWhereWithAggregatesInput[]
    OR?: PrescriptionMedicineScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionMedicineScalarWhereWithAggregatesInput | PrescriptionMedicineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrescriptionMedicine"> | number
    prescriptionId?: IntWithAggregatesFilter<"PrescriptionMedicine"> | number
    medicineId?: IntWithAggregatesFilter<"PrescriptionMedicine"> | number
    dosage?: StringWithAggregatesFilter<"PrescriptionMedicine"> | string
    frequency?: StringWithAggregatesFilter<"PrescriptionMedicine"> | string
    duration?: StringWithAggregatesFilter<"PrescriptionMedicine"> | string
    instructions?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrescriptionMedicine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrescriptionMedicine"> | Date | string
  }

  export type MedicineWhereInput = {
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    id?: IntFilter<"Medicine"> | number
    name?: StringFilter<"Medicine"> | string
    genericName?: StringNullableFilter<"Medicine"> | string | null
    category?: StringNullableFilter<"Medicine"> | string | null
    manufacturer?: StringNullableFilter<"Medicine"> | string | null
    description?: StringNullableFilter<"Medicine"> | string | null
    dosageForm?: StringNullableFilter<"Medicine"> | string | null
    strength?: StringNullableFilter<"Medicine"> | string | null
    price?: DecimalFilter<"Medicine"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"Medicine"> | number
    reorderLevel?: IntFilter<"Medicine"> | number
    expiryDate?: DateTimeNullableFilter<"Medicine"> | Date | string | null
    batchNumber?: StringNullableFilter<"Medicine"> | string | null
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeFilter<"Medicine"> | Date | string
    prescriptionMedicines?: PrescriptionMedicineListRelationFilter
    inventoryLogs?: InventoryLogListRelationFilter
  }

  export type MedicineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dosageForm?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prescriptionMedicines?: PrescriptionMedicineOrderByRelationAggregateInput
    inventoryLogs?: InventoryLogOrderByRelationAggregateInput
  }

  export type MedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    name?: StringFilter<"Medicine"> | string
    genericName?: StringNullableFilter<"Medicine"> | string | null
    category?: StringNullableFilter<"Medicine"> | string | null
    manufacturer?: StringNullableFilter<"Medicine"> | string | null
    description?: StringNullableFilter<"Medicine"> | string | null
    dosageForm?: StringNullableFilter<"Medicine"> | string | null
    strength?: StringNullableFilter<"Medicine"> | string | null
    price?: DecimalFilter<"Medicine"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"Medicine"> | number
    reorderLevel?: IntFilter<"Medicine"> | number
    expiryDate?: DateTimeNullableFilter<"Medicine"> | Date | string | null
    batchNumber?: StringNullableFilter<"Medicine"> | string | null
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeFilter<"Medicine"> | Date | string
    prescriptionMedicines?: PrescriptionMedicineListRelationFilter
    inventoryLogs?: InventoryLogListRelationFilter
  }, "id">

  export type MedicineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dosageForm?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineCountOrderByAggregateInput
    _avg?: MedicineAvgOrderByAggregateInput
    _max?: MedicineMaxOrderByAggregateInput
    _min?: MedicineMinOrderByAggregateInput
    _sum?: MedicineSumOrderByAggregateInput
  }

  export type MedicineScalarWhereWithAggregatesInput = {
    AND?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    OR?: MedicineScalarWhereWithAggregatesInput[]
    NOT?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Medicine"> | number
    name?: StringWithAggregatesFilter<"Medicine"> | string
    genericName?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    category?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    description?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    dosageForm?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    strength?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    price?: DecimalWithAggregatesFilter<"Medicine"> | Decimal | DecimalJsLike | number | string
    stock?: IntWithAggregatesFilter<"Medicine"> | number
    reorderLevel?: IntWithAggregatesFilter<"Medicine"> | number
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Medicine"> | Date | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Medicine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medicine"> | Date | string
  }

  export type InventoryLogWhereInput = {
    AND?: InventoryLogWhereInput | InventoryLogWhereInput[]
    OR?: InventoryLogWhereInput[]
    NOT?: InventoryLogWhereInput | InventoryLogWhereInput[]
    id?: IntFilter<"InventoryLog"> | number
    medicineId?: IntFilter<"InventoryLog"> | number
    quantity?: IntFilter<"InventoryLog"> | number
    type?: StringFilter<"InventoryLog"> | string
    reason?: StringNullableFilter<"InventoryLog"> | string | null
    referenceId?: StringNullableFilter<"InventoryLog"> | string | null
    createdAt?: DateTimeFilter<"InventoryLog"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryLog"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }

  export type InventoryLogOrderByWithRelationInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicine?: MedicineOrderByWithRelationInput
  }

  export type InventoryLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryLogWhereInput | InventoryLogWhereInput[]
    OR?: InventoryLogWhereInput[]
    NOT?: InventoryLogWhereInput | InventoryLogWhereInput[]
    medicineId?: IntFilter<"InventoryLog"> | number
    quantity?: IntFilter<"InventoryLog"> | number
    type?: StringFilter<"InventoryLog"> | string
    reason?: StringNullableFilter<"InventoryLog"> | string | null
    referenceId?: StringNullableFilter<"InventoryLog"> | string | null
    createdAt?: DateTimeFilter<"InventoryLog"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryLog"> | Date | string
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }, "id">

  export type InventoryLogOrderByWithAggregationInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryLogCountOrderByAggregateInput
    _avg?: InventoryLogAvgOrderByAggregateInput
    _max?: InventoryLogMaxOrderByAggregateInput
    _min?: InventoryLogMinOrderByAggregateInput
    _sum?: InventoryLogSumOrderByAggregateInput
  }

  export type InventoryLogScalarWhereWithAggregatesInput = {
    AND?: InventoryLogScalarWhereWithAggregatesInput | InventoryLogScalarWhereWithAggregatesInput[]
    OR?: InventoryLogScalarWhereWithAggregatesInput[]
    NOT?: InventoryLogScalarWhereWithAggregatesInput | InventoryLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryLog"> | number
    medicineId?: IntWithAggregatesFilter<"InventoryLog"> | number
    quantity?: IntWithAggregatesFilter<"InventoryLog"> | number
    type?: StringWithAggregatesFilter<"InventoryLog"> | string
    reason?: StringNullableWithAggregatesFilter<"InventoryLog"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"InventoryLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryLog"> | Date | string
  }

  export type LabReportWhereInput = {
    AND?: LabReportWhereInput | LabReportWhereInput[]
    OR?: LabReportWhereInput[]
    NOT?: LabReportWhereInput | LabReportWhereInput[]
    id?: IntFilter<"LabReport"> | number
    patientId?: IntFilter<"LabReport"> | number
    doctorId?: IntFilter<"LabReport"> | number
    appointmentId?: IntNullableFilter<"LabReport"> | number | null
    testDate?: DateTimeFilter<"LabReport"> | Date | string
    reportDate?: DateTimeNullableFilter<"LabReport"> | Date | string | null
    testType?: StringFilter<"LabReport"> | string
    testResult?: StringNullableFilter<"LabReport"> | string | null
    normalRange?: StringNullableFilter<"LabReport"> | string | null
    notes?: StringNullableFilter<"LabReport"> | string | null
    attachmentUrl?: StringNullableFilter<"LabReport"> | string | null
    status?: StringFilter<"LabReport"> | string
    createdAt?: DateTimeFilter<"LabReport"> | Date | string
    updatedAt?: DateTimeFilter<"LabReport"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type LabReportOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    testDate?: SortOrder
    reportDate?: SortOrderInput | SortOrder
    testType?: SortOrder
    testResult?: SortOrderInput | SortOrder
    normalRange?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type LabReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LabReportWhereInput | LabReportWhereInput[]
    OR?: LabReportWhereInput[]
    NOT?: LabReportWhereInput | LabReportWhereInput[]
    patientId?: IntFilter<"LabReport"> | number
    doctorId?: IntFilter<"LabReport"> | number
    appointmentId?: IntNullableFilter<"LabReport"> | number | null
    testDate?: DateTimeFilter<"LabReport"> | Date | string
    reportDate?: DateTimeNullableFilter<"LabReport"> | Date | string | null
    testType?: StringFilter<"LabReport"> | string
    testResult?: StringNullableFilter<"LabReport"> | string | null
    normalRange?: StringNullableFilter<"LabReport"> | string | null
    notes?: StringNullableFilter<"LabReport"> | string | null
    attachmentUrl?: StringNullableFilter<"LabReport"> | string | null
    status?: StringFilter<"LabReport"> | string
    createdAt?: DateTimeFilter<"LabReport"> | Date | string
    updatedAt?: DateTimeFilter<"LabReport"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id">

  export type LabReportOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    testDate?: SortOrder
    reportDate?: SortOrderInput | SortOrder
    testType?: SortOrder
    testResult?: SortOrderInput | SortOrder
    normalRange?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabReportCountOrderByAggregateInput
    _avg?: LabReportAvgOrderByAggregateInput
    _max?: LabReportMaxOrderByAggregateInput
    _min?: LabReportMinOrderByAggregateInput
    _sum?: LabReportSumOrderByAggregateInput
  }

  export type LabReportScalarWhereWithAggregatesInput = {
    AND?: LabReportScalarWhereWithAggregatesInput | LabReportScalarWhereWithAggregatesInput[]
    OR?: LabReportScalarWhereWithAggregatesInput[]
    NOT?: LabReportScalarWhereWithAggregatesInput | LabReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabReport"> | number
    patientId?: IntWithAggregatesFilter<"LabReport"> | number
    doctorId?: IntWithAggregatesFilter<"LabReport"> | number
    appointmentId?: IntNullableWithAggregatesFilter<"LabReport"> | number | null
    testDate?: DateTimeWithAggregatesFilter<"LabReport"> | Date | string
    reportDate?: DateTimeNullableWithAggregatesFilter<"LabReport"> | Date | string | null
    testType?: StringWithAggregatesFilter<"LabReport"> | string
    testResult?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    normalRange?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    notes?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    attachmentUrl?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    status?: StringWithAggregatesFilter<"LabReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LabReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabReport"> | Date | string
  }

  export type RadiologyReportWhereInput = {
    AND?: RadiologyReportWhereInput | RadiologyReportWhereInput[]
    OR?: RadiologyReportWhereInput[]
    NOT?: RadiologyReportWhereInput | RadiologyReportWhereInput[]
    id?: IntFilter<"RadiologyReport"> | number
    patientId?: IntFilter<"RadiologyReport"> | number
    doctorId?: IntFilter<"RadiologyReport"> | number
    appointmentId?: IntNullableFilter<"RadiologyReport"> | number | null
    testDate?: DateTimeFilter<"RadiologyReport"> | Date | string
    reportDate?: DateTimeNullableFilter<"RadiologyReport"> | Date | string | null
    testType?: StringFilter<"RadiologyReport"> | string
    findings?: StringNullableFilter<"RadiologyReport"> | string | null
    impression?: StringNullableFilter<"RadiologyReport"> | string | null
    notes?: StringNullableFilter<"RadiologyReport"> | string | null
    attachmentUrl?: StringNullableFilter<"RadiologyReport"> | string | null
    status?: StringFilter<"RadiologyReport"> | string
    createdAt?: DateTimeFilter<"RadiologyReport"> | Date | string
    updatedAt?: DateTimeFilter<"RadiologyReport"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type RadiologyReportOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    testDate?: SortOrder
    reportDate?: SortOrderInput | SortOrder
    testType?: SortOrder
    findings?: SortOrderInput | SortOrder
    impression?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type RadiologyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RadiologyReportWhereInput | RadiologyReportWhereInput[]
    OR?: RadiologyReportWhereInput[]
    NOT?: RadiologyReportWhereInput | RadiologyReportWhereInput[]
    patientId?: IntFilter<"RadiologyReport"> | number
    doctorId?: IntFilter<"RadiologyReport"> | number
    appointmentId?: IntNullableFilter<"RadiologyReport"> | number | null
    testDate?: DateTimeFilter<"RadiologyReport"> | Date | string
    reportDate?: DateTimeNullableFilter<"RadiologyReport"> | Date | string | null
    testType?: StringFilter<"RadiologyReport"> | string
    findings?: StringNullableFilter<"RadiologyReport"> | string | null
    impression?: StringNullableFilter<"RadiologyReport"> | string | null
    notes?: StringNullableFilter<"RadiologyReport"> | string | null
    attachmentUrl?: StringNullableFilter<"RadiologyReport"> | string | null
    status?: StringFilter<"RadiologyReport"> | string
    createdAt?: DateTimeFilter<"RadiologyReport"> | Date | string
    updatedAt?: DateTimeFilter<"RadiologyReport"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id">

  export type RadiologyReportOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    testDate?: SortOrder
    reportDate?: SortOrderInput | SortOrder
    testType?: SortOrder
    findings?: SortOrderInput | SortOrder
    impression?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RadiologyReportCountOrderByAggregateInput
    _avg?: RadiologyReportAvgOrderByAggregateInput
    _max?: RadiologyReportMaxOrderByAggregateInput
    _min?: RadiologyReportMinOrderByAggregateInput
    _sum?: RadiologyReportSumOrderByAggregateInput
  }

  export type RadiologyReportScalarWhereWithAggregatesInput = {
    AND?: RadiologyReportScalarWhereWithAggregatesInput | RadiologyReportScalarWhereWithAggregatesInput[]
    OR?: RadiologyReportScalarWhereWithAggregatesInput[]
    NOT?: RadiologyReportScalarWhereWithAggregatesInput | RadiologyReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RadiologyReport"> | number
    patientId?: IntWithAggregatesFilter<"RadiologyReport"> | number
    doctorId?: IntWithAggregatesFilter<"RadiologyReport"> | number
    appointmentId?: IntNullableWithAggregatesFilter<"RadiologyReport"> | number | null
    testDate?: DateTimeWithAggregatesFilter<"RadiologyReport"> | Date | string
    reportDate?: DateTimeNullableWithAggregatesFilter<"RadiologyReport"> | Date | string | null
    testType?: StringWithAggregatesFilter<"RadiologyReport"> | string
    findings?: StringNullableWithAggregatesFilter<"RadiologyReport"> | string | null
    impression?: StringNullableWithAggregatesFilter<"RadiologyReport"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RadiologyReport"> | string | null
    attachmentUrl?: StringNullableWithAggregatesFilter<"RadiologyReport"> | string | null
    status?: StringWithAggregatesFilter<"RadiologyReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RadiologyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RadiologyReport"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    patientId?: IntFilter<"Invoice"> | number
    invoiceNumber?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    patient?: XOR<UserScalarRelationFilter, UserWhereInput>
    patientDetails?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    subsidyClaims?: SubsidyClaimListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: UserOrderByWithRelationInput
    patientDetails?: PatientOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    subsidyClaims?: SubsidyClaimOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    patientId?: IntFilter<"Invoice"> | number
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    patient?: XOR<UserScalarRelationFilter, UserWhereInput>
    patientDetails?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    subsidyClaims?: SubsidyClaimListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    patientId?: IntWithAggregatesFilter<"Invoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: StringFilter<"InvoiceItem"> | string
    itemId?: IntNullableFilter<"InvoiceItem"> | number | null
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    labReportId?: IntNullableFilter<"InvoiceItem"> | number | null
    radiologyReportId?: IntNullableFilter<"InvoiceItem"> | number | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    labReport?: XOR<LabReportNullableScalarRelationFilter, LabReportWhereInput> | null
    radiologyReport?: XOR<RadiologyReportNullableScalarRelationFilter, RadiologyReportWhereInput> | null
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrderInput | SortOrder
    radiologyReportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    labReport?: LabReportOrderByWithRelationInput
    radiologyReport?: RadiologyReportOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: StringFilter<"InvoiceItem"> | string
    itemId?: IntNullableFilter<"InvoiceItem"> | number | null
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    labReportId?: IntNullableFilter<"InvoiceItem"> | number | null
    radiologyReportId?: IntNullableFilter<"InvoiceItem"> | number | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    labReport?: XOR<LabReportNullableScalarRelationFilter, LabReportWhereInput> | null
    radiologyReport?: XOR<RadiologyReportNullableScalarRelationFilter, RadiologyReportWhereInput> | null
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrderInput | SortOrder
    radiologyReportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"InvoiceItem"> | number
    itemType?: StringWithAggregatesFilter<"InvoiceItem"> | string
    itemId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    labReportId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    radiologyReportId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    patientId?: IntFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    patient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    patient?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: IntFilter<"Payment"> | number
    patientId?: IntFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    patient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    invoiceId?: IntWithAggregatesFilter<"Payment"> | number
    patientId?: IntWithAggregatesFilter<"Payment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type BedWhereInput = {
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    id?: IntFilter<"Bed"> | number
    bedNumber?: StringFilter<"Bed"> | string
    wardId?: IntFilter<"Bed"> | number
    status?: StringFilter<"Bed"> | string
    price?: DecimalFilter<"Bed"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
    ward?: XOR<WardScalarRelationFilter, WardWhereInput>
    bedAllocations?: BedAllocationListRelationFilter
  }

  export type BedOrderByWithRelationInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    wardId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ward?: WardOrderByWithRelationInput
    bedAllocations?: BedAllocationOrderByRelationAggregateInput
  }

  export type BedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bedNumber?: string
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    wardId?: IntFilter<"Bed"> | number
    status?: StringFilter<"Bed"> | string
    price?: DecimalFilter<"Bed"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
    ward?: XOR<WardScalarRelationFilter, WardWhereInput>
    bedAllocations?: BedAllocationListRelationFilter
  }, "id" | "bedNumber">

  export type BedOrderByWithAggregationInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    wardId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BedCountOrderByAggregateInput
    _avg?: BedAvgOrderByAggregateInput
    _max?: BedMaxOrderByAggregateInput
    _min?: BedMinOrderByAggregateInput
    _sum?: BedSumOrderByAggregateInput
  }

  export type BedScalarWhereWithAggregatesInput = {
    AND?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    OR?: BedScalarWhereWithAggregatesInput[]
    NOT?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bed"> | number
    bedNumber?: StringWithAggregatesFilter<"Bed"> | string
    wardId?: IntWithAggregatesFilter<"Bed"> | number
    status?: StringWithAggregatesFilter<"Bed"> | string
    price?: DecimalWithAggregatesFilter<"Bed"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Bed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bed"> | Date | string
  }

  export type WardWhereInput = {
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    id?: IntFilter<"Ward"> | number
    name?: StringFilter<"Ward"> | string
    wardType?: StringFilter<"Ward"> | string
    floor?: StringNullableFilter<"Ward"> | string | null
    capacity?: IntFilter<"Ward"> | number
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
    beds?: BedListRelationFilter
  }

  export type WardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    wardType?: SortOrder
    floor?: SortOrderInput | SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beds?: BedOrderByRelationAggregateInput
  }

  export type WardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    name?: StringFilter<"Ward"> | string
    wardType?: StringFilter<"Ward"> | string
    floor?: StringNullableFilter<"Ward"> | string | null
    capacity?: IntFilter<"Ward"> | number
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
    beds?: BedListRelationFilter
  }, "id">

  export type WardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    wardType?: SortOrder
    floor?: SortOrderInput | SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WardCountOrderByAggregateInput
    _avg?: WardAvgOrderByAggregateInput
    _max?: WardMaxOrderByAggregateInput
    _min?: WardMinOrderByAggregateInput
    _sum?: WardSumOrderByAggregateInput
  }

  export type WardScalarWhereWithAggregatesInput = {
    AND?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    OR?: WardScalarWhereWithAggregatesInput[]
    NOT?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ward"> | number
    name?: StringWithAggregatesFilter<"Ward"> | string
    wardType?: StringWithAggregatesFilter<"Ward"> | string
    floor?: StringNullableWithAggregatesFilter<"Ward"> | string | null
    capacity?: IntWithAggregatesFilter<"Ward"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ward"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ward"> | Date | string
  }

  export type BedAllocationWhereInput = {
    AND?: BedAllocationWhereInput | BedAllocationWhereInput[]
    OR?: BedAllocationWhereInput[]
    NOT?: BedAllocationWhereInput | BedAllocationWhereInput[]
    id?: IntFilter<"BedAllocation"> | number
    bedId?: IntFilter<"BedAllocation"> | number
    patientId?: IntFilter<"BedAllocation"> | number
    nurseId?: IntNullableFilter<"BedAllocation"> | number | null
    allocatedAt?: DateTimeFilter<"BedAllocation"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"BedAllocation"> | Date | string | null
    status?: StringFilter<"BedAllocation"> | string
    notes?: StringNullableFilter<"BedAllocation"> | string | null
    createdAt?: DateTimeFilter<"BedAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"BedAllocation"> | Date | string
    bed?: XOR<BedScalarRelationFilter, BedWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    nurse?: XOR<NurseNullableScalarRelationFilter, NurseWhereInput> | null
  }

  export type BedAllocationOrderByWithRelationInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrderInput | SortOrder
    allocatedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bed?: BedOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    nurse?: NurseOrderByWithRelationInput
  }

  export type BedAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BedAllocationWhereInput | BedAllocationWhereInput[]
    OR?: BedAllocationWhereInput[]
    NOT?: BedAllocationWhereInput | BedAllocationWhereInput[]
    bedId?: IntFilter<"BedAllocation"> | number
    patientId?: IntFilter<"BedAllocation"> | number
    nurseId?: IntNullableFilter<"BedAllocation"> | number | null
    allocatedAt?: DateTimeFilter<"BedAllocation"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"BedAllocation"> | Date | string | null
    status?: StringFilter<"BedAllocation"> | string
    notes?: StringNullableFilter<"BedAllocation"> | string | null
    createdAt?: DateTimeFilter<"BedAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"BedAllocation"> | Date | string
    bed?: XOR<BedScalarRelationFilter, BedWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    nurse?: XOR<NurseNullableScalarRelationFilter, NurseWhereInput> | null
  }, "id">

  export type BedAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrderInput | SortOrder
    allocatedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BedAllocationCountOrderByAggregateInput
    _avg?: BedAllocationAvgOrderByAggregateInput
    _max?: BedAllocationMaxOrderByAggregateInput
    _min?: BedAllocationMinOrderByAggregateInput
    _sum?: BedAllocationSumOrderByAggregateInput
  }

  export type BedAllocationScalarWhereWithAggregatesInput = {
    AND?: BedAllocationScalarWhereWithAggregatesInput | BedAllocationScalarWhereWithAggregatesInput[]
    OR?: BedAllocationScalarWhereWithAggregatesInput[]
    NOT?: BedAllocationScalarWhereWithAggregatesInput | BedAllocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BedAllocation"> | number
    bedId?: IntWithAggregatesFilter<"BedAllocation"> | number
    patientId?: IntWithAggregatesFilter<"BedAllocation"> | number
    nurseId?: IntNullableWithAggregatesFilter<"BedAllocation"> | number | null
    allocatedAt?: DateTimeWithAggregatesFilter<"BedAllocation"> | Date | string
    dischargedAt?: DateTimeNullableWithAggregatesFilter<"BedAllocation"> | Date | string | null
    status?: StringWithAggregatesFilter<"BedAllocation"> | string
    notes?: StringNullableWithAggregatesFilter<"BedAllocation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BedAllocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BedAllocation"> | Date | string
  }

  export type VitalSignWhereInput = {
    AND?: VitalSignWhereInput | VitalSignWhereInput[]
    OR?: VitalSignWhereInput[]
    NOT?: VitalSignWhereInput | VitalSignWhereInput[]
    id?: IntFilter<"VitalSign"> | number
    patientId?: IntFilter<"VitalSign"> | number
    recordedBy?: IntFilter<"VitalSign"> | number
    temperature?: FloatNullableFilter<"VitalSign"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"VitalSign"> | number | null
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSign"> | number | null
    oxygenSaturation?: FloatNullableFilter<"VitalSign"> | number | null
    height?: FloatNullableFilter<"VitalSign"> | number | null
    weight?: FloatNullableFilter<"VitalSign"> | number | null
    notes?: StringNullableFilter<"VitalSign"> | string | null
    recordedAt?: DateTimeFilter<"VitalSign"> | Date | string
    createdAt?: DateTimeFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeFilter<"VitalSign"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    nurse?: XOR<NurseScalarRelationFilter, NurseWhereInput>
  }

  export type VitalSignOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    nurse?: NurseOrderByWithRelationInput
  }

  export type VitalSignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VitalSignWhereInput | VitalSignWhereInput[]
    OR?: VitalSignWhereInput[]
    NOT?: VitalSignWhereInput | VitalSignWhereInput[]
    patientId?: IntFilter<"VitalSign"> | number
    recordedBy?: IntFilter<"VitalSign"> | number
    temperature?: FloatNullableFilter<"VitalSign"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"VitalSign"> | number | null
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSign"> | number | null
    oxygenSaturation?: FloatNullableFilter<"VitalSign"> | number | null
    height?: FloatNullableFilter<"VitalSign"> | number | null
    weight?: FloatNullableFilter<"VitalSign"> | number | null
    notes?: StringNullableFilter<"VitalSign"> | string | null
    recordedAt?: DateTimeFilter<"VitalSign"> | Date | string
    createdAt?: DateTimeFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeFilter<"VitalSign"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    nurse?: XOR<NurseScalarRelationFilter, NurseWhereInput>
  }, "id">

  export type VitalSignOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VitalSignCountOrderByAggregateInput
    _avg?: VitalSignAvgOrderByAggregateInput
    _max?: VitalSignMaxOrderByAggregateInput
    _min?: VitalSignMinOrderByAggregateInput
    _sum?: VitalSignSumOrderByAggregateInput
  }

  export type VitalSignScalarWhereWithAggregatesInput = {
    AND?: VitalSignScalarWhereWithAggregatesInput | VitalSignScalarWhereWithAggregatesInput[]
    OR?: VitalSignScalarWhereWithAggregatesInput[]
    NOT?: VitalSignScalarWhereWithAggregatesInput | VitalSignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VitalSign"> | number
    patientId?: IntWithAggregatesFilter<"VitalSign"> | number
    recordedBy?: IntWithAggregatesFilter<"VitalSign"> | number
    temperature?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    bloodPressureSystolic?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    heartRate?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    respiratoryRate?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    oxygenSaturation?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    height?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    notes?: StringNullableWithAggregatesFilter<"VitalSign"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
  }

  export type OperationTheaterWhereInput = {
    AND?: OperationTheaterWhereInput | OperationTheaterWhereInput[]
    OR?: OperationTheaterWhereInput[]
    NOT?: OperationTheaterWhereInput | OperationTheaterWhereInput[]
    id?: IntFilter<"OperationTheater"> | number
    name?: StringFilter<"OperationTheater"> | string
    location?: StringNullableFilter<"OperationTheater"> | string | null
    status?: StringFilter<"OperationTheater"> | string
    doctorId?: IntNullableFilter<"OperationTheater"> | number | null
    createdAt?: DateTimeFilter<"OperationTheater"> | Date | string
    updatedAt?: DateTimeFilter<"OperationTheater"> | Date | string
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    surgeries?: SurgeryListRelationFilter
    equipments?: OperationTheaterEquipmentListRelationFilter
  }

  export type OperationTheaterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    surgeries?: SurgeryOrderByRelationAggregateInput
    equipments?: OperationTheaterEquipmentOrderByRelationAggregateInput
  }

  export type OperationTheaterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperationTheaterWhereInput | OperationTheaterWhereInput[]
    OR?: OperationTheaterWhereInput[]
    NOT?: OperationTheaterWhereInput | OperationTheaterWhereInput[]
    name?: StringFilter<"OperationTheater"> | string
    location?: StringNullableFilter<"OperationTheater"> | string | null
    status?: StringFilter<"OperationTheater"> | string
    doctorId?: IntNullableFilter<"OperationTheater"> | number | null
    createdAt?: DateTimeFilter<"OperationTheater"> | Date | string
    updatedAt?: DateTimeFilter<"OperationTheater"> | Date | string
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    surgeries?: SurgeryListRelationFilter
    equipments?: OperationTheaterEquipmentListRelationFilter
  }, "id">

  export type OperationTheaterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperationTheaterCountOrderByAggregateInput
    _avg?: OperationTheaterAvgOrderByAggregateInput
    _max?: OperationTheaterMaxOrderByAggregateInput
    _min?: OperationTheaterMinOrderByAggregateInput
    _sum?: OperationTheaterSumOrderByAggregateInput
  }

  export type OperationTheaterScalarWhereWithAggregatesInput = {
    AND?: OperationTheaterScalarWhereWithAggregatesInput | OperationTheaterScalarWhereWithAggregatesInput[]
    OR?: OperationTheaterScalarWhereWithAggregatesInput[]
    NOT?: OperationTheaterScalarWhereWithAggregatesInput | OperationTheaterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperationTheater"> | number
    name?: StringWithAggregatesFilter<"OperationTheater"> | string
    location?: StringNullableWithAggregatesFilter<"OperationTheater"> | string | null
    status?: StringWithAggregatesFilter<"OperationTheater"> | string
    doctorId?: IntNullableWithAggregatesFilter<"OperationTheater"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"OperationTheater"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OperationTheater"> | Date | string
  }

  export type SurgeryWhereInput = {
    AND?: SurgeryWhereInput | SurgeryWhereInput[]
    OR?: SurgeryWhereInput[]
    NOT?: SurgeryWhereInput | SurgeryWhereInput[]
    id?: IntFilter<"Surgery"> | number
    patientId?: IntFilter<"Surgery"> | number
    operationTheaterId?: IntFilter<"Surgery"> | number
    surgeryDate?: DateTimeFilter<"Surgery"> | Date | string
    startTime?: StringFilter<"Surgery"> | string
    endTime?: StringFilter<"Surgery"> | string
    surgeryType?: StringFilter<"Surgery"> | string
    notes?: StringNullableFilter<"Surgery"> | string | null
    status?: StringFilter<"Surgery"> | string
    createdAt?: DateTimeFilter<"Surgery"> | Date | string
    updatedAt?: DateTimeFilter<"Surgery"> | Date | string
    operationTheater?: XOR<OperationTheaterScalarRelationFilter, OperationTheaterWhereInput>
  }

  export type SurgeryOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
    surgeryDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    surgeryType?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationTheater?: OperationTheaterOrderByWithRelationInput
  }

  export type SurgeryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SurgeryWhereInput | SurgeryWhereInput[]
    OR?: SurgeryWhereInput[]
    NOT?: SurgeryWhereInput | SurgeryWhereInput[]
    patientId?: IntFilter<"Surgery"> | number
    operationTheaterId?: IntFilter<"Surgery"> | number
    surgeryDate?: DateTimeFilter<"Surgery"> | Date | string
    startTime?: StringFilter<"Surgery"> | string
    endTime?: StringFilter<"Surgery"> | string
    surgeryType?: StringFilter<"Surgery"> | string
    notes?: StringNullableFilter<"Surgery"> | string | null
    status?: StringFilter<"Surgery"> | string
    createdAt?: DateTimeFilter<"Surgery"> | Date | string
    updatedAt?: DateTimeFilter<"Surgery"> | Date | string
    operationTheater?: XOR<OperationTheaterScalarRelationFilter, OperationTheaterWhereInput>
  }, "id">

  export type SurgeryOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
    surgeryDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    surgeryType?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurgeryCountOrderByAggregateInput
    _avg?: SurgeryAvgOrderByAggregateInput
    _max?: SurgeryMaxOrderByAggregateInput
    _min?: SurgeryMinOrderByAggregateInput
    _sum?: SurgerySumOrderByAggregateInput
  }

  export type SurgeryScalarWhereWithAggregatesInput = {
    AND?: SurgeryScalarWhereWithAggregatesInput | SurgeryScalarWhereWithAggregatesInput[]
    OR?: SurgeryScalarWhereWithAggregatesInput[]
    NOT?: SurgeryScalarWhereWithAggregatesInput | SurgeryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Surgery"> | number
    patientId?: IntWithAggregatesFilter<"Surgery"> | number
    operationTheaterId?: IntWithAggregatesFilter<"Surgery"> | number
    surgeryDate?: DateTimeWithAggregatesFilter<"Surgery"> | Date | string
    startTime?: StringWithAggregatesFilter<"Surgery"> | string
    endTime?: StringWithAggregatesFilter<"Surgery"> | string
    surgeryType?: StringWithAggregatesFilter<"Surgery"> | string
    notes?: StringNullableWithAggregatesFilter<"Surgery"> | string | null
    status?: StringWithAggregatesFilter<"Surgery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Surgery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Surgery"> | Date | string
  }

  export type OperationTheaterEquipmentWhereInput = {
    AND?: OperationTheaterEquipmentWhereInput | OperationTheaterEquipmentWhereInput[]
    OR?: OperationTheaterEquipmentWhereInput[]
    NOT?: OperationTheaterEquipmentWhereInput | OperationTheaterEquipmentWhereInput[]
    id?: IntFilter<"OperationTheaterEquipment"> | number
    operationTheaterId?: IntFilter<"OperationTheaterEquipment"> | number
    name?: StringFilter<"OperationTheaterEquipment"> | string
    serialNumber?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    manufacturer?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    purchaseDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    status?: StringFilter<"OperationTheaterEquipment"> | string
    notes?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    createdAt?: DateTimeFilter<"OperationTheaterEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"OperationTheaterEquipment"> | Date | string
    operationTheater?: XOR<OperationTheaterScalarRelationFilter, OperationTheaterWhereInput>
  }

  export type OperationTheaterEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    nextMaintenanceDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operationTheater?: OperationTheaterOrderByWithRelationInput
  }

  export type OperationTheaterEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperationTheaterEquipmentWhereInput | OperationTheaterEquipmentWhereInput[]
    OR?: OperationTheaterEquipmentWhereInput[]
    NOT?: OperationTheaterEquipmentWhereInput | OperationTheaterEquipmentWhereInput[]
    operationTheaterId?: IntFilter<"OperationTheaterEquipment"> | number
    name?: StringFilter<"OperationTheaterEquipment"> | string
    serialNumber?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    manufacturer?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    purchaseDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    status?: StringFilter<"OperationTheaterEquipment"> | string
    notes?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    createdAt?: DateTimeFilter<"OperationTheaterEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"OperationTheaterEquipment"> | Date | string
    operationTheater?: XOR<OperationTheaterScalarRelationFilter, OperationTheaterWhereInput>
  }, "id">

  export type OperationTheaterEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    nextMaintenanceDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperationTheaterEquipmentCountOrderByAggregateInput
    _avg?: OperationTheaterEquipmentAvgOrderByAggregateInput
    _max?: OperationTheaterEquipmentMaxOrderByAggregateInput
    _min?: OperationTheaterEquipmentMinOrderByAggregateInput
    _sum?: OperationTheaterEquipmentSumOrderByAggregateInput
  }

  export type OperationTheaterEquipmentScalarWhereWithAggregatesInput = {
    AND?: OperationTheaterEquipmentScalarWhereWithAggregatesInput | OperationTheaterEquipmentScalarWhereWithAggregatesInput[]
    OR?: OperationTheaterEquipmentScalarWhereWithAggregatesInput[]
    NOT?: OperationTheaterEquipmentScalarWhereWithAggregatesInput | OperationTheaterEquipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperationTheaterEquipment"> | number
    operationTheaterId?: IntWithAggregatesFilter<"OperationTheaterEquipment"> | number
    name?: StringWithAggregatesFilter<"OperationTheaterEquipment"> | string
    serialNumber?: StringNullableWithAggregatesFilter<"OperationTheaterEquipment"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"OperationTheaterEquipment"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"OperationTheaterEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"OperationTheaterEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"OperationTheaterEquipment"> | Date | string | null
    status?: StringWithAggregatesFilter<"OperationTheaterEquipment"> | string
    notes?: StringNullableWithAggregatesFilter<"OperationTheaterEquipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OperationTheaterEquipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OperationTheaterEquipment"> | Date | string
  }

  export type MedicalGasCylinderWhereInput = {
    AND?: MedicalGasCylinderWhereInput | MedicalGasCylinderWhereInput[]
    OR?: MedicalGasCylinderWhereInput[]
    NOT?: MedicalGasCylinderWhereInput | MedicalGasCylinderWhereInput[]
    id?: IntFilter<"MedicalGasCylinder"> | number
    cylinderNumber?: StringFilter<"MedicalGasCylinder"> | string
    gasType?: StringFilter<"MedicalGasCylinder"> | string
    capacity?: FloatFilter<"MedicalGasCylinder"> | number
    currentLevel?: FloatFilter<"MedicalGasCylinder"> | number
    location?: StringNullableFilter<"MedicalGasCylinder"> | string | null
    status?: StringFilter<"MedicalGasCylinder"> | string
    lastRefillDate?: DateTimeNullableFilter<"MedicalGasCylinder"> | Date | string | null
    nextRefillDate?: DateTimeNullableFilter<"MedicalGasCylinder"> | Date | string | null
    notes?: StringNullableFilter<"MedicalGasCylinder"> | string | null
    createdAt?: DateTimeFilter<"MedicalGasCylinder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalGasCylinder"> | Date | string
  }

  export type MedicalGasCylinderOrderByWithRelationInput = {
    id?: SortOrder
    cylinderNumber?: SortOrder
    gasType?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    lastRefillDate?: SortOrderInput | SortOrder
    nextRefillDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalGasCylinderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cylinderNumber?: string
    AND?: MedicalGasCylinderWhereInput | MedicalGasCylinderWhereInput[]
    OR?: MedicalGasCylinderWhereInput[]
    NOT?: MedicalGasCylinderWhereInput | MedicalGasCylinderWhereInput[]
    gasType?: StringFilter<"MedicalGasCylinder"> | string
    capacity?: FloatFilter<"MedicalGasCylinder"> | number
    currentLevel?: FloatFilter<"MedicalGasCylinder"> | number
    location?: StringNullableFilter<"MedicalGasCylinder"> | string | null
    status?: StringFilter<"MedicalGasCylinder"> | string
    lastRefillDate?: DateTimeNullableFilter<"MedicalGasCylinder"> | Date | string | null
    nextRefillDate?: DateTimeNullableFilter<"MedicalGasCylinder"> | Date | string | null
    notes?: StringNullableFilter<"MedicalGasCylinder"> | string | null
    createdAt?: DateTimeFilter<"MedicalGasCylinder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalGasCylinder"> | Date | string
  }, "id" | "cylinderNumber">

  export type MedicalGasCylinderOrderByWithAggregationInput = {
    id?: SortOrder
    cylinderNumber?: SortOrder
    gasType?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    lastRefillDate?: SortOrderInput | SortOrder
    nextRefillDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalGasCylinderCountOrderByAggregateInput
    _avg?: MedicalGasCylinderAvgOrderByAggregateInput
    _max?: MedicalGasCylinderMaxOrderByAggregateInput
    _min?: MedicalGasCylinderMinOrderByAggregateInput
    _sum?: MedicalGasCylinderSumOrderByAggregateInput
  }

  export type MedicalGasCylinderScalarWhereWithAggregatesInput = {
    AND?: MedicalGasCylinderScalarWhereWithAggregatesInput | MedicalGasCylinderScalarWhereWithAggregatesInput[]
    OR?: MedicalGasCylinderScalarWhereWithAggregatesInput[]
    NOT?: MedicalGasCylinderScalarWhereWithAggregatesInput | MedicalGasCylinderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicalGasCylinder"> | number
    cylinderNumber?: StringWithAggregatesFilter<"MedicalGasCylinder"> | string
    gasType?: StringWithAggregatesFilter<"MedicalGasCylinder"> | string
    capacity?: FloatWithAggregatesFilter<"MedicalGasCylinder"> | number
    currentLevel?: FloatWithAggregatesFilter<"MedicalGasCylinder"> | number
    location?: StringNullableWithAggregatesFilter<"MedicalGasCylinder"> | string | null
    status?: StringWithAggregatesFilter<"MedicalGasCylinder"> | string
    lastRefillDate?: DateTimeNullableWithAggregatesFilter<"MedicalGasCylinder"> | Date | string | null
    nextRefillDate?: DateTimeNullableWithAggregatesFilter<"MedicalGasCylinder"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"MedicalGasCylinder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicalGasCylinder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalGasCylinder"> | Date | string
  }

  export type EquipmentMaintenanceWhereInput = {
    AND?: EquipmentMaintenanceWhereInput | EquipmentMaintenanceWhereInput[]
    OR?: EquipmentMaintenanceWhereInput[]
    NOT?: EquipmentMaintenanceWhereInput | EquipmentMaintenanceWhereInput[]
    id?: IntFilter<"EquipmentMaintenance"> | number
    equipmentType?: StringFilter<"EquipmentMaintenance"> | string
    equipmentId?: IntFilter<"EquipmentMaintenance"> | number
    maintenanceDate?: DateTimeFilter<"EquipmentMaintenance"> | Date | string
    maintenanceType?: StringFilter<"EquipmentMaintenance"> | string
    performedBy?: StringFilter<"EquipmentMaintenance"> | string
    cost?: DecimalFilter<"EquipmentMaintenance"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"EquipmentMaintenance"> | string | null
    status?: StringFilter<"EquipmentMaintenance"> | string
    createdAt?: DateTimeFilter<"EquipmentMaintenance"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentMaintenance"> | Date | string
  }

  export type EquipmentMaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    equipmentType?: SortOrder
    equipmentId?: SortOrder
    maintenanceDate?: SortOrder
    maintenanceType?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EquipmentMaintenanceWhereInput | EquipmentMaintenanceWhereInput[]
    OR?: EquipmentMaintenanceWhereInput[]
    NOT?: EquipmentMaintenanceWhereInput | EquipmentMaintenanceWhereInput[]
    equipmentType?: StringFilter<"EquipmentMaintenance"> | string
    equipmentId?: IntFilter<"EquipmentMaintenance"> | number
    maintenanceDate?: DateTimeFilter<"EquipmentMaintenance"> | Date | string
    maintenanceType?: StringFilter<"EquipmentMaintenance"> | string
    performedBy?: StringFilter<"EquipmentMaintenance"> | string
    cost?: DecimalFilter<"EquipmentMaintenance"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"EquipmentMaintenance"> | string | null
    status?: StringFilter<"EquipmentMaintenance"> | string
    createdAt?: DateTimeFilter<"EquipmentMaintenance"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentMaintenance"> | Date | string
  }, "id">

  export type EquipmentMaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentType?: SortOrder
    equipmentId?: SortOrder
    maintenanceDate?: SortOrder
    maintenanceType?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentMaintenanceCountOrderByAggregateInput
    _avg?: EquipmentMaintenanceAvgOrderByAggregateInput
    _max?: EquipmentMaintenanceMaxOrderByAggregateInput
    _min?: EquipmentMaintenanceMinOrderByAggregateInput
    _sum?: EquipmentMaintenanceSumOrderByAggregateInput
  }

  export type EquipmentMaintenanceScalarWhereWithAggregatesInput = {
    AND?: EquipmentMaintenanceScalarWhereWithAggregatesInput | EquipmentMaintenanceScalarWhereWithAggregatesInput[]
    OR?: EquipmentMaintenanceScalarWhereWithAggregatesInput[]
    NOT?: EquipmentMaintenanceScalarWhereWithAggregatesInput | EquipmentMaintenanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EquipmentMaintenance"> | number
    equipmentType?: StringWithAggregatesFilter<"EquipmentMaintenance"> | string
    equipmentId?: IntWithAggregatesFilter<"EquipmentMaintenance"> | number
    maintenanceDate?: DateTimeWithAggregatesFilter<"EquipmentMaintenance"> | Date | string
    maintenanceType?: StringWithAggregatesFilter<"EquipmentMaintenance"> | string
    performedBy?: StringWithAggregatesFilter<"EquipmentMaintenance"> | string
    cost?: DecimalWithAggregatesFilter<"EquipmentMaintenance"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"EquipmentMaintenance"> | string | null
    status?: StringWithAggregatesFilter<"EquipmentMaintenance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentMaintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentMaintenance"> | Date | string
  }

  export type AmbulanceWhereInput = {
    AND?: AmbulanceWhereInput | AmbulanceWhereInput[]
    OR?: AmbulanceWhereInput[]
    NOT?: AmbulanceWhereInput | AmbulanceWhereInput[]
    id?: IntFilter<"Ambulance"> | number
    vehicleNumber?: StringFilter<"Ambulance"> | string
    model?: StringNullableFilter<"Ambulance"> | string | null
    type?: StringFilter<"Ambulance"> | string
    capacity?: IntFilter<"Ambulance"> | number
    driverName?: StringNullableFilter<"Ambulance"> | string | null
    driverContact?: StringNullableFilter<"Ambulance"> | string | null
    status?: StringFilter<"Ambulance"> | string
    lastMaintenanceDate?: DateTimeNullableFilter<"Ambulance"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"Ambulance"> | Date | string | null
    notes?: StringNullableFilter<"Ambulance"> | string | null
    createdAt?: DateTimeFilter<"Ambulance"> | Date | string
    updatedAt?: DateTimeFilter<"Ambulance"> | Date | string
    ambulanceServices?: AmbulanceServiceListRelationFilter
  }

  export type AmbulanceOrderByWithRelationInput = {
    id?: SortOrder
    vehicleNumber?: SortOrder
    model?: SortOrderInput | SortOrder
    type?: SortOrder
    capacity?: SortOrder
    driverName?: SortOrderInput | SortOrder
    driverContact?: SortOrderInput | SortOrder
    status?: SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    nextMaintenanceDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambulanceServices?: AmbulanceServiceOrderByRelationAggregateInput
  }

  export type AmbulanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    vehicleNumber?: string
    AND?: AmbulanceWhereInput | AmbulanceWhereInput[]
    OR?: AmbulanceWhereInput[]
    NOT?: AmbulanceWhereInput | AmbulanceWhereInput[]
    model?: StringNullableFilter<"Ambulance"> | string | null
    type?: StringFilter<"Ambulance"> | string
    capacity?: IntFilter<"Ambulance"> | number
    driverName?: StringNullableFilter<"Ambulance"> | string | null
    driverContact?: StringNullableFilter<"Ambulance"> | string | null
    status?: StringFilter<"Ambulance"> | string
    lastMaintenanceDate?: DateTimeNullableFilter<"Ambulance"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"Ambulance"> | Date | string | null
    notes?: StringNullableFilter<"Ambulance"> | string | null
    createdAt?: DateTimeFilter<"Ambulance"> | Date | string
    updatedAt?: DateTimeFilter<"Ambulance"> | Date | string
    ambulanceServices?: AmbulanceServiceListRelationFilter
  }, "id" | "vehicleNumber">

  export type AmbulanceOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleNumber?: SortOrder
    model?: SortOrderInput | SortOrder
    type?: SortOrder
    capacity?: SortOrder
    driverName?: SortOrderInput | SortOrder
    driverContact?: SortOrderInput | SortOrder
    status?: SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    nextMaintenanceDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmbulanceCountOrderByAggregateInput
    _avg?: AmbulanceAvgOrderByAggregateInput
    _max?: AmbulanceMaxOrderByAggregateInput
    _min?: AmbulanceMinOrderByAggregateInput
    _sum?: AmbulanceSumOrderByAggregateInput
  }

  export type AmbulanceScalarWhereWithAggregatesInput = {
    AND?: AmbulanceScalarWhereWithAggregatesInput | AmbulanceScalarWhereWithAggregatesInput[]
    OR?: AmbulanceScalarWhereWithAggregatesInput[]
    NOT?: AmbulanceScalarWhereWithAggregatesInput | AmbulanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ambulance"> | number
    vehicleNumber?: StringWithAggregatesFilter<"Ambulance"> | string
    model?: StringNullableWithAggregatesFilter<"Ambulance"> | string | null
    type?: StringWithAggregatesFilter<"Ambulance"> | string
    capacity?: IntWithAggregatesFilter<"Ambulance"> | number
    driverName?: StringNullableWithAggregatesFilter<"Ambulance"> | string | null
    driverContact?: StringNullableWithAggregatesFilter<"Ambulance"> | string | null
    status?: StringWithAggregatesFilter<"Ambulance"> | string
    lastMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"Ambulance"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"Ambulance"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Ambulance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ambulance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ambulance"> | Date | string
  }

  export type AmbulanceServiceWhereInput = {
    AND?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    OR?: AmbulanceServiceWhereInput[]
    NOT?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    id?: IntFilter<"AmbulanceService"> | number
    ambulanceId?: IntFilter<"AmbulanceService"> | number
    patientName?: StringFilter<"AmbulanceService"> | string
    patientContact?: StringFilter<"AmbulanceService"> | string
    pickupLocation?: StringFilter<"AmbulanceService"> | string
    dropLocation?: StringFilter<"AmbulanceService"> | string
    serviceDate?: DateTimeFilter<"AmbulanceService"> | Date | string
    status?: StringFilter<"AmbulanceService"> | string
    fare?: DecimalFilter<"AmbulanceService"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AmbulanceService"> | string | null
    createdAt?: DateTimeFilter<"AmbulanceService"> | Date | string
    updatedAt?: DateTimeFilter<"AmbulanceService"> | Date | string
    ambulance?: XOR<AmbulanceScalarRelationFilter, AmbulanceWhereInput>
  }

  export type AmbulanceServiceOrderByWithRelationInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    patientName?: SortOrder
    patientContact?: SortOrder
    pickupLocation?: SortOrder
    dropLocation?: SortOrder
    serviceDate?: SortOrder
    status?: SortOrder
    fare?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambulance?: AmbulanceOrderByWithRelationInput
  }

  export type AmbulanceServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    OR?: AmbulanceServiceWhereInput[]
    NOT?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    ambulanceId?: IntFilter<"AmbulanceService"> | number
    patientName?: StringFilter<"AmbulanceService"> | string
    patientContact?: StringFilter<"AmbulanceService"> | string
    pickupLocation?: StringFilter<"AmbulanceService"> | string
    dropLocation?: StringFilter<"AmbulanceService"> | string
    serviceDate?: DateTimeFilter<"AmbulanceService"> | Date | string
    status?: StringFilter<"AmbulanceService"> | string
    fare?: DecimalFilter<"AmbulanceService"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AmbulanceService"> | string | null
    createdAt?: DateTimeFilter<"AmbulanceService"> | Date | string
    updatedAt?: DateTimeFilter<"AmbulanceService"> | Date | string
    ambulance?: XOR<AmbulanceScalarRelationFilter, AmbulanceWhereInput>
  }, "id">

  export type AmbulanceServiceOrderByWithAggregationInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    patientName?: SortOrder
    patientContact?: SortOrder
    pickupLocation?: SortOrder
    dropLocation?: SortOrder
    serviceDate?: SortOrder
    status?: SortOrder
    fare?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmbulanceServiceCountOrderByAggregateInput
    _avg?: AmbulanceServiceAvgOrderByAggregateInput
    _max?: AmbulanceServiceMaxOrderByAggregateInput
    _min?: AmbulanceServiceMinOrderByAggregateInput
    _sum?: AmbulanceServiceSumOrderByAggregateInput
  }

  export type AmbulanceServiceScalarWhereWithAggregatesInput = {
    AND?: AmbulanceServiceScalarWhereWithAggregatesInput | AmbulanceServiceScalarWhereWithAggregatesInput[]
    OR?: AmbulanceServiceScalarWhereWithAggregatesInput[]
    NOT?: AmbulanceServiceScalarWhereWithAggregatesInput | AmbulanceServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AmbulanceService"> | number
    ambulanceId?: IntWithAggregatesFilter<"AmbulanceService"> | number
    patientName?: StringWithAggregatesFilter<"AmbulanceService"> | string
    patientContact?: StringWithAggregatesFilter<"AmbulanceService"> | string
    pickupLocation?: StringWithAggregatesFilter<"AmbulanceService"> | string
    dropLocation?: StringWithAggregatesFilter<"AmbulanceService"> | string
    serviceDate?: DateTimeWithAggregatesFilter<"AmbulanceService"> | Date | string
    status?: StringWithAggregatesFilter<"AmbulanceService"> | string
    fare?: DecimalWithAggregatesFilter<"AmbulanceService"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"AmbulanceService"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AmbulanceService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AmbulanceService"> | Date | string
  }

  export type BiometricDataWhereInput = {
    AND?: BiometricDataWhereInput | BiometricDataWhereInput[]
    OR?: BiometricDataWhereInput[]
    NOT?: BiometricDataWhereInput | BiometricDataWhereInput[]
    id?: IntFilter<"BiometricData"> | number
    userId?: IntFilter<"BiometricData"> | number
    biometricId?: StringFilter<"BiometricData"> | string
    fingerprint?: StringNullableFilter<"BiometricData"> | string | null
    faceData?: StringNullableFilter<"BiometricData"> | string | null
    createdAt?: DateTimeFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeFilter<"BiometricData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BiometricDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    biometricId?: SortOrder
    fingerprint?: SortOrderInput | SortOrder
    faceData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BiometricDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    biometricId?: string
    AND?: BiometricDataWhereInput | BiometricDataWhereInput[]
    OR?: BiometricDataWhereInput[]
    NOT?: BiometricDataWhereInput | BiometricDataWhereInput[]
    fingerprint?: StringNullableFilter<"BiometricData"> | string | null
    faceData?: StringNullableFilter<"BiometricData"> | string | null
    createdAt?: DateTimeFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeFilter<"BiometricData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "biometricId">

  export type BiometricDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    biometricId?: SortOrder
    fingerprint?: SortOrderInput | SortOrder
    faceData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiometricDataCountOrderByAggregateInput
    _avg?: BiometricDataAvgOrderByAggregateInput
    _max?: BiometricDataMaxOrderByAggregateInput
    _min?: BiometricDataMinOrderByAggregateInput
    _sum?: BiometricDataSumOrderByAggregateInput
  }

  export type BiometricDataScalarWhereWithAggregatesInput = {
    AND?: BiometricDataScalarWhereWithAggregatesInput | BiometricDataScalarWhereWithAggregatesInput[]
    OR?: BiometricDataScalarWhereWithAggregatesInput[]
    NOT?: BiometricDataScalarWhereWithAggregatesInput | BiometricDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BiometricData"> | number
    userId?: IntWithAggregatesFilter<"BiometricData"> | number
    biometricId?: StringWithAggregatesFilter<"BiometricData"> | string
    fingerprint?: StringNullableWithAggregatesFilter<"BiometricData"> | string | null
    faceData?: StringNullableWithAggregatesFilter<"BiometricData"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiometricData"> | Date | string
  }

  export type AttendanceLogWhereInput = {
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    id?: IntFilter<"AttendanceLog"> | number
    userId?: IntFilter<"AttendanceLog"> | number
    checkInTime?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    status?: StringFilter<"AttendanceLog"> | string
    deviceId?: StringNullableFilter<"AttendanceLog"> | string | null
    verificationMode?: StringNullableFilter<"AttendanceLog"> | string | null
    notes?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    status?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    verificationMode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    userId?: IntFilter<"AttendanceLog"> | number
    checkInTime?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    status?: StringFilter<"AttendanceLog"> | string
    deviceId?: StringNullableFilter<"AttendanceLog"> | string | null
    verificationMode?: StringNullableFilter<"AttendanceLog"> | string | null
    notes?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AttendanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    status?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    verificationMode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceLogCountOrderByAggregateInput
    _avg?: AttendanceLogAvgOrderByAggregateInput
    _max?: AttendanceLogMaxOrderByAggregateInput
    _min?: AttendanceLogMinOrderByAggregateInput
    _sum?: AttendanceLogSumOrderByAggregateInput
  }

  export type AttendanceLogScalarWhereWithAggregatesInput = {
    AND?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    OR?: AttendanceLogScalarWhereWithAggregatesInput[]
    NOT?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceLog"> | number
    userId?: IntWithAggregatesFilter<"AttendanceLog"> | number
    checkInTime?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    status?: StringWithAggregatesFilter<"AttendanceLog"> | string
    deviceId?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    verificationMode?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
  }

  export type DutyRosterWhereInput = {
    AND?: DutyRosterWhereInput | DutyRosterWhereInput[]
    OR?: DutyRosterWhereInput[]
    NOT?: DutyRosterWhereInput | DutyRosterWhereInput[]
    id?: IntFilter<"DutyRoster"> | number
    userId?: IntFilter<"DutyRoster"> | number
    startDate?: DateTimeFilter<"DutyRoster"> | Date | string
    endDate?: DateTimeFilter<"DutyRoster"> | Date | string
    shiftStart?: StringFilter<"DutyRoster"> | string
    shiftEnd?: StringFilter<"DutyRoster"> | string
    department?: StringNullableFilter<"DutyRoster"> | string | null
    notes?: StringNullableFilter<"DutyRoster"> | string | null
    createdAt?: DateTimeFilter<"DutyRoster"> | Date | string
    updatedAt?: DateTimeFilter<"DutyRoster"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DutyRosterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    department?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DutyRosterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DutyRosterWhereInput | DutyRosterWhereInput[]
    OR?: DutyRosterWhereInput[]
    NOT?: DutyRosterWhereInput | DutyRosterWhereInput[]
    userId?: IntFilter<"DutyRoster"> | number
    startDate?: DateTimeFilter<"DutyRoster"> | Date | string
    endDate?: DateTimeFilter<"DutyRoster"> | Date | string
    shiftStart?: StringFilter<"DutyRoster"> | string
    shiftEnd?: StringFilter<"DutyRoster"> | string
    department?: StringNullableFilter<"DutyRoster"> | string | null
    notes?: StringNullableFilter<"DutyRoster"> | string | null
    createdAt?: DateTimeFilter<"DutyRoster"> | Date | string
    updatedAt?: DateTimeFilter<"DutyRoster"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DutyRosterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    department?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DutyRosterCountOrderByAggregateInput
    _avg?: DutyRosterAvgOrderByAggregateInput
    _max?: DutyRosterMaxOrderByAggregateInput
    _min?: DutyRosterMinOrderByAggregateInput
    _sum?: DutyRosterSumOrderByAggregateInput
  }

  export type DutyRosterScalarWhereWithAggregatesInput = {
    AND?: DutyRosterScalarWhereWithAggregatesInput | DutyRosterScalarWhereWithAggregatesInput[]
    OR?: DutyRosterScalarWhereWithAggregatesInput[]
    NOT?: DutyRosterScalarWhereWithAggregatesInput | DutyRosterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DutyRoster"> | number
    userId?: IntWithAggregatesFilter<"DutyRoster"> | number
    startDate?: DateTimeWithAggregatesFilter<"DutyRoster"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"DutyRoster"> | Date | string
    shiftStart?: StringWithAggregatesFilter<"DutyRoster"> | string
    shiftEnd?: StringWithAggregatesFilter<"DutyRoster"> | string
    department?: StringNullableWithAggregatesFilter<"DutyRoster"> | string | null
    notes?: StringNullableWithAggregatesFilter<"DutyRoster"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DutyRoster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DutyRoster"> | Date | string
  }

  export type TPAWhereInput = {
    AND?: TPAWhereInput | TPAWhereInput[]
    OR?: TPAWhereInput[]
    NOT?: TPAWhereInput | TPAWhereInput[]
    id?: IntFilter<"TPA"> | number
    name?: StringFilter<"TPA"> | string
    contactPerson?: StringNullableFilter<"TPA"> | string | null
    contactNumber?: StringNullableFilter<"TPA"> | string | null
    email?: StringNullableFilter<"TPA"> | string | null
    address?: StringNullableFilter<"TPA"> | string | null
    contractStartDate?: DateTimeNullableFilter<"TPA"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"TPA"> | Date | string | null
    status?: StringFilter<"TPA"> | string
    notes?: StringNullableFilter<"TPA"> | string | null
    createdAt?: DateTimeFilter<"TPA"> | Date | string
    updatedAt?: DateTimeFilter<"TPA"> | Date | string
    patients?: PatientListRelationFilter
  }

  export type TPAOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patients?: PatientOrderByRelationAggregateInput
  }

  export type TPAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TPAWhereInput | TPAWhereInput[]
    OR?: TPAWhereInput[]
    NOT?: TPAWhereInput | TPAWhereInput[]
    name?: StringFilter<"TPA"> | string
    contactPerson?: StringNullableFilter<"TPA"> | string | null
    contactNumber?: StringNullableFilter<"TPA"> | string | null
    email?: StringNullableFilter<"TPA"> | string | null
    address?: StringNullableFilter<"TPA"> | string | null
    contractStartDate?: DateTimeNullableFilter<"TPA"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"TPA"> | Date | string | null
    status?: StringFilter<"TPA"> | string
    notes?: StringNullableFilter<"TPA"> | string | null
    createdAt?: DateTimeFilter<"TPA"> | Date | string
    updatedAt?: DateTimeFilter<"TPA"> | Date | string
    patients?: PatientListRelationFilter
  }, "id">

  export type TPAOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TPACountOrderByAggregateInput
    _avg?: TPAAvgOrderByAggregateInput
    _max?: TPAMaxOrderByAggregateInput
    _min?: TPAMinOrderByAggregateInput
    _sum?: TPASumOrderByAggregateInput
  }

  export type TPAScalarWhereWithAggregatesInput = {
    AND?: TPAScalarWhereWithAggregatesInput | TPAScalarWhereWithAggregatesInput[]
    OR?: TPAScalarWhereWithAggregatesInput[]
    NOT?: TPAScalarWhereWithAggregatesInput | TPAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TPA"> | number
    name?: StringWithAggregatesFilter<"TPA"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"TPA"> | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"TPA"> | string | null
    email?: StringNullableWithAggregatesFilter<"TPA"> | string | null
    address?: StringNullableWithAggregatesFilter<"TPA"> | string | null
    contractStartDate?: DateTimeNullableWithAggregatesFilter<"TPA"> | Date | string | null
    contractEndDate?: DateTimeNullableWithAggregatesFilter<"TPA"> | Date | string | null
    status?: StringWithAggregatesFilter<"TPA"> | string
    notes?: StringNullableWithAggregatesFilter<"TPA"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TPA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TPA"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    userId?: IntFilter<"Employee"> | number
    employeeId?: StringFilter<"Employee"> | string
    department?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    joiningDate?: DateTimeFilter<"Employee"> | Date | string
    contractType?: StringFilter<"Employee"> | string
    contractEndDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bankName?: StringNullableFilter<"Employee"> | string | null
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    ifscCode?: StringNullableFilter<"Employee"> | string | null
    panNumber?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    emergencyName?: StringNullableFilter<"Employee"> | string | null
    emergencyRelation?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    leaves?: LeaveListRelationFilter
    salaryPayments?: SalaryPaymentListRelationFilter
    documents?: EmployeeDocumentListRelationFilter
    performanceReviews?: PerformanceReviewListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    joiningDate?: SortOrder
    contractType?: SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    salary?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyName?: SortOrderInput | SortOrder
    emergencyRelation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    leaves?: LeaveOrderByRelationAggregateInput
    salaryPayments?: SalaryPaymentOrderByRelationAggregateInput
    documents?: EmployeeDocumentOrderByRelationAggregateInput
    performanceReviews?: PerformanceReviewOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    employeeId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    department?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    joiningDate?: DateTimeFilter<"Employee"> | Date | string
    contractType?: StringFilter<"Employee"> | string
    contractEndDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bankName?: StringNullableFilter<"Employee"> | string | null
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    ifscCode?: StringNullableFilter<"Employee"> | string | null
    panNumber?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    emergencyName?: StringNullableFilter<"Employee"> | string | null
    emergencyRelation?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    leaves?: LeaveListRelationFilter
    salaryPayments?: SalaryPaymentListRelationFilter
    documents?: EmployeeDocumentListRelationFilter
    performanceReviews?: PerformanceReviewListRelationFilter
  }, "id" | "userId" | "employeeId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    joiningDate?: SortOrder
    contractType?: SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    salary?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyName?: SortOrderInput | SortOrder
    emergencyRelation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    userId?: IntWithAggregatesFilter<"Employee"> | number
    employeeId?: StringWithAggregatesFilter<"Employee"> | string
    department?: StringWithAggregatesFilter<"Employee"> | string
    position?: StringWithAggregatesFilter<"Employee"> | string
    joiningDate?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    contractType?: StringWithAggregatesFilter<"Employee"> | string
    contractEndDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    salary?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bankName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    ifscCode?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    panNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyRelation?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: IntFilter<"Leave"> | number
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    totalDays?: IntFilter<"Leave"> | number
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    notes?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    totalDays?: IntFilter<"Leave"> | number
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    notes?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave"> | number
    employeeId?: IntWithAggregatesFilter<"Leave"> | number
    leaveType?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    totalDays?: IntWithAggregatesFilter<"Leave"> | number
    reason?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    status?: StringWithAggregatesFilter<"Leave"> | string
    approvedBy?: IntNullableWithAggregatesFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Leave"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
  }

  export type SalaryPaymentWhereInput = {
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    id?: IntFilter<"SalaryPayment"> | number
    employeeId?: IntFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    salaryMonth?: StringFilter<"SalaryPayment"> | string
    basicSalary?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"SalaryPayment"> | string
    transactionId?: StringNullableFilter<"SalaryPayment"> | string | null
    status?: StringFilter<"SalaryPayment"> | string
    notes?: StringNullableFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type SalaryPaymentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    salaryMonth?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type SalaryPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    employeeId?: IntFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    salaryMonth?: StringFilter<"SalaryPayment"> | string
    basicSalary?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"SalaryPayment"> | string
    transactionId?: StringNullableFilter<"SalaryPayment"> | string | null
    status?: StringFilter<"SalaryPayment"> | string
    notes?: StringNullableFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type SalaryPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    salaryMonth?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryPaymentCountOrderByAggregateInput
    _avg?: SalaryPaymentAvgOrderByAggregateInput
    _max?: SalaryPaymentMaxOrderByAggregateInput
    _min?: SalaryPaymentMinOrderByAggregateInput
    _sum?: SalaryPaymentSumOrderByAggregateInput
  }

  export type SalaryPaymentScalarWhereWithAggregatesInput = {
    AND?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    OR?: SalaryPaymentScalarWhereWithAggregatesInput[]
    NOT?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryPayment"> | number
    employeeId?: IntWithAggregatesFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    salaryMonth?: StringWithAggregatesFilter<"SalaryPayment"> | string
    basicSalary?: DecimalWithAggregatesFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalWithAggregatesFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalWithAggregatesFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalWithAggregatesFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalWithAggregatesFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringWithAggregatesFilter<"SalaryPayment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"SalaryPayment"> | string | null
    status?: StringWithAggregatesFilter<"SalaryPayment"> | string
    notes?: StringNullableWithAggregatesFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
  }

  export type EmployeeDocumentWhereInput = {
    AND?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    OR?: EmployeeDocumentWhereInput[]
    NOT?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    id?: IntFilter<"EmployeeDocument"> | number
    employeeId?: IntFilter<"EmployeeDocument"> | number
    documentType?: StringFilter<"EmployeeDocument"> | string
    documentName?: StringFilter<"EmployeeDocument"> | string
    documentUrl?: StringFilter<"EmployeeDocument"> | string
    isVerified?: BoolFilter<"EmployeeDocument"> | boolean
    verifiedBy?: IntNullableFilter<"EmployeeDocument"> | number | null
    verifiedAt?: DateTimeNullableFilter<"EmployeeDocument"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeDocument"> | string | null
    createdAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type EmployeeDocumentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type EmployeeDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    OR?: EmployeeDocumentWhereInput[]
    NOT?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    employeeId?: IntFilter<"EmployeeDocument"> | number
    documentType?: StringFilter<"EmployeeDocument"> | string
    documentName?: StringFilter<"EmployeeDocument"> | string
    documentUrl?: StringFilter<"EmployeeDocument"> | string
    isVerified?: BoolFilter<"EmployeeDocument"> | boolean
    verifiedBy?: IntNullableFilter<"EmployeeDocument"> | number | null
    verifiedAt?: DateTimeNullableFilter<"EmployeeDocument"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeDocument"> | string | null
    createdAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type EmployeeDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeDocumentCountOrderByAggregateInput
    _avg?: EmployeeDocumentAvgOrderByAggregateInput
    _max?: EmployeeDocumentMaxOrderByAggregateInput
    _min?: EmployeeDocumentMinOrderByAggregateInput
    _sum?: EmployeeDocumentSumOrderByAggregateInput
  }

  export type EmployeeDocumentScalarWhereWithAggregatesInput = {
    AND?: EmployeeDocumentScalarWhereWithAggregatesInput | EmployeeDocumentScalarWhereWithAggregatesInput[]
    OR?: EmployeeDocumentScalarWhereWithAggregatesInput[]
    NOT?: EmployeeDocumentScalarWhereWithAggregatesInput | EmployeeDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeDocument"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeDocument"> | number
    documentType?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    documentName?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    documentUrl?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    isVerified?: BoolWithAggregatesFilter<"EmployeeDocument"> | boolean
    verifiedBy?: IntNullableWithAggregatesFilter<"EmployeeDocument"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeDocument"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"EmployeeDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeDocument"> | Date | string
  }

  export type PerformanceReviewWhereInput = {
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    id?: IntFilter<"PerformanceReview"> | number
    employeeId?: IntFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewedBy?: IntFilter<"PerformanceReview"> | number
    rating?: IntFilter<"PerformanceReview"> | number
    strengths?: StringNullableFilter<"PerformanceReview"> | string | null
    areasOfImprovement?: StringNullableFilter<"PerformanceReview"> | string | null
    goals?: StringNullableFilter<"PerformanceReview"> | string | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    employeeComments?: StringNullableFilter<"PerformanceReview"> | string | null
    status?: StringFilter<"PerformanceReview"> | string
    acknowledgedAt?: DateTimeNullableFilter<"PerformanceReview"> | Date | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type PerformanceReviewOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
    strengths?: SortOrderInput | SortOrder
    areasOfImprovement?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    employeeComments?: SortOrderInput | SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PerformanceReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    employeeId?: IntFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewedBy?: IntFilter<"PerformanceReview"> | number
    rating?: IntFilter<"PerformanceReview"> | number
    strengths?: StringNullableFilter<"PerformanceReview"> | string | null
    areasOfImprovement?: StringNullableFilter<"PerformanceReview"> | string | null
    goals?: StringNullableFilter<"PerformanceReview"> | string | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    employeeComments?: StringNullableFilter<"PerformanceReview"> | string | null
    status?: StringFilter<"PerformanceReview"> | string
    acknowledgedAt?: DateTimeNullableFilter<"PerformanceReview"> | Date | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PerformanceReviewOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
    strengths?: SortOrderInput | SortOrder
    areasOfImprovement?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    employeeComments?: SortOrderInput | SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceReviewCountOrderByAggregateInput
    _avg?: PerformanceReviewAvgOrderByAggregateInput
    _max?: PerformanceReviewMaxOrderByAggregateInput
    _min?: PerformanceReviewMinOrderByAggregateInput
    _sum?: PerformanceReviewSumOrderByAggregateInput
  }

  export type PerformanceReviewScalarWhereWithAggregatesInput = {
    AND?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    OR?: PerformanceReviewScalarWhereWithAggregatesInput[]
    NOT?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceReview"> | number
    employeeId?: IntWithAggregatesFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    reviewPeriodStart?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    reviewedBy?: IntWithAggregatesFilter<"PerformanceReview"> | number
    rating?: IntWithAggregatesFilter<"PerformanceReview"> | number
    strengths?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    areasOfImprovement?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    goals?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    comments?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    employeeComments?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    status?: StringWithAggregatesFilter<"PerformanceReview"> | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"PerformanceReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
  }

  export type SubsidySchemeWhereInput = {
    AND?: SubsidySchemeWhereInput | SubsidySchemeWhereInput[]
    OR?: SubsidySchemeWhereInput[]
    NOT?: SubsidySchemeWhereInput | SubsidySchemeWhereInput[]
    id?: IntFilter<"SubsidyScheme"> | number
    name?: StringFilter<"SubsidyScheme"> | string
    code?: StringFilter<"SubsidyScheme"> | string
    description?: StringNullableFilter<"SubsidyScheme"> | string | null
    issuingAuthority?: StringFilter<"SubsidyScheme"> | string
    startDate?: DateTimeFilter<"SubsidyScheme"> | Date | string
    endDate?: DateTimeNullableFilter<"SubsidyScheme"> | Date | string | null
    eligibilityCriteria?: StringNullableFilter<"SubsidyScheme"> | string | null
    subsidyType?: StringFilter<"SubsidyScheme"> | string
    percentageValue?: FloatNullableFilter<"SubsidyScheme"> | number | null
    fixedAmount?: DecimalNullableFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: DecimalNullableFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: DecimalNullableFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    applicableServices?: StringNullableFilter<"SubsidyScheme"> | string | null
    documentationRequired?: StringNullableFilter<"SubsidyScheme"> | string | null
    status?: StringFilter<"SubsidyScheme"> | string
    createdAt?: DateTimeFilter<"SubsidyScheme"> | Date | string
    updatedAt?: DateTimeFilter<"SubsidyScheme"> | Date | string
    patientSubsidies?: PatientSubsidyListRelationFilter
    subsidyClaims?: SubsidyClaimListRelationFilter
  }

  export type SubsidySchemeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    issuingAuthority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    eligibilityCriteria?: SortOrderInput | SortOrder
    subsidyType?: SortOrder
    percentageValue?: SortOrderInput | SortOrder
    fixedAmount?: SortOrderInput | SortOrder
    maxCoverageAmount?: SortOrderInput | SortOrder
    maxCoveragePerTreatment?: SortOrderInput | SortOrder
    applicableServices?: SortOrderInput | SortOrder
    documentationRequired?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientSubsidies?: PatientSubsidyOrderByRelationAggregateInput
    subsidyClaims?: SubsidyClaimOrderByRelationAggregateInput
  }

  export type SubsidySchemeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SubsidySchemeWhereInput | SubsidySchemeWhereInput[]
    OR?: SubsidySchemeWhereInput[]
    NOT?: SubsidySchemeWhereInput | SubsidySchemeWhereInput[]
    name?: StringFilter<"SubsidyScheme"> | string
    description?: StringNullableFilter<"SubsidyScheme"> | string | null
    issuingAuthority?: StringFilter<"SubsidyScheme"> | string
    startDate?: DateTimeFilter<"SubsidyScheme"> | Date | string
    endDate?: DateTimeNullableFilter<"SubsidyScheme"> | Date | string | null
    eligibilityCriteria?: StringNullableFilter<"SubsidyScheme"> | string | null
    subsidyType?: StringFilter<"SubsidyScheme"> | string
    percentageValue?: FloatNullableFilter<"SubsidyScheme"> | number | null
    fixedAmount?: DecimalNullableFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: DecimalNullableFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: DecimalNullableFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    applicableServices?: StringNullableFilter<"SubsidyScheme"> | string | null
    documentationRequired?: StringNullableFilter<"SubsidyScheme"> | string | null
    status?: StringFilter<"SubsidyScheme"> | string
    createdAt?: DateTimeFilter<"SubsidyScheme"> | Date | string
    updatedAt?: DateTimeFilter<"SubsidyScheme"> | Date | string
    patientSubsidies?: PatientSubsidyListRelationFilter
    subsidyClaims?: SubsidyClaimListRelationFilter
  }, "id" | "code">

  export type SubsidySchemeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    issuingAuthority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    eligibilityCriteria?: SortOrderInput | SortOrder
    subsidyType?: SortOrder
    percentageValue?: SortOrderInput | SortOrder
    fixedAmount?: SortOrderInput | SortOrder
    maxCoverageAmount?: SortOrderInput | SortOrder
    maxCoveragePerTreatment?: SortOrderInput | SortOrder
    applicableServices?: SortOrderInput | SortOrder
    documentationRequired?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubsidySchemeCountOrderByAggregateInput
    _avg?: SubsidySchemeAvgOrderByAggregateInput
    _max?: SubsidySchemeMaxOrderByAggregateInput
    _min?: SubsidySchemeMinOrderByAggregateInput
    _sum?: SubsidySchemeSumOrderByAggregateInput
  }

  export type SubsidySchemeScalarWhereWithAggregatesInput = {
    AND?: SubsidySchemeScalarWhereWithAggregatesInput | SubsidySchemeScalarWhereWithAggregatesInput[]
    OR?: SubsidySchemeScalarWhereWithAggregatesInput[]
    NOT?: SubsidySchemeScalarWhereWithAggregatesInput | SubsidySchemeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubsidyScheme"> | number
    name?: StringWithAggregatesFilter<"SubsidyScheme"> | string
    code?: StringWithAggregatesFilter<"SubsidyScheme"> | string
    description?: StringNullableWithAggregatesFilter<"SubsidyScheme"> | string | null
    issuingAuthority?: StringWithAggregatesFilter<"SubsidyScheme"> | string
    startDate?: DateTimeWithAggregatesFilter<"SubsidyScheme"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"SubsidyScheme"> | Date | string | null
    eligibilityCriteria?: StringNullableWithAggregatesFilter<"SubsidyScheme"> | string | null
    subsidyType?: StringWithAggregatesFilter<"SubsidyScheme"> | string
    percentageValue?: FloatNullableWithAggregatesFilter<"SubsidyScheme"> | number | null
    fixedAmount?: DecimalNullableWithAggregatesFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: DecimalNullableWithAggregatesFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: DecimalNullableWithAggregatesFilter<"SubsidyScheme"> | Decimal | DecimalJsLike | number | string | null
    applicableServices?: StringNullableWithAggregatesFilter<"SubsidyScheme"> | string | null
    documentationRequired?: StringNullableWithAggregatesFilter<"SubsidyScheme"> | string | null
    status?: StringWithAggregatesFilter<"SubsidyScheme"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubsidyScheme"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubsidyScheme"> | Date | string
  }

  export type PatientSubsidyWhereInput = {
    AND?: PatientSubsidyWhereInput | PatientSubsidyWhereInput[]
    OR?: PatientSubsidyWhereInput[]
    NOT?: PatientSubsidyWhereInput | PatientSubsidyWhereInput[]
    id?: IntFilter<"PatientSubsidy"> | number
    patientId?: IntFilter<"PatientSubsidy"> | number
    schemeId?: IntFilter<"PatientSubsidy"> | number
    enrollmentDate?: DateTimeFilter<"PatientSubsidy"> | Date | string
    enrollmentNumber?: StringFilter<"PatientSubsidy"> | string
    cardNumber?: StringNullableFilter<"PatientSubsidy"> | string | null
    validFrom?: DateTimeFilter<"PatientSubsidy"> | Date | string
    validUntil?: DateTimeNullableFilter<"PatientSubsidy"> | Date | string | null
    remainingBalance?: DecimalNullableFilter<"PatientSubsidy"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"PatientSubsidy"> | string
    verificationStatus?: StringFilter<"PatientSubsidy"> | string
    verifiedBy?: IntNullableFilter<"PatientSubsidy"> | number | null
    verifiedAt?: DateTimeNullableFilter<"PatientSubsidy"> | Date | string | null
    notes?: StringNullableFilter<"PatientSubsidy"> | string | null
    createdAt?: DateTimeFilter<"PatientSubsidy"> | Date | string
    updatedAt?: DateTimeFilter<"PatientSubsidy"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    scheme?: XOR<SubsidySchemeScalarRelationFilter, SubsidySchemeWhereInput>
    subsidyClaims?: SubsidyClaimListRelationFilter
  }

  export type PatientSubsidyOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    enrollmentDate?: SortOrder
    enrollmentNumber?: SortOrder
    cardNumber?: SortOrderInput | SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    remainingBalance?: SortOrderInput | SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    scheme?: SubsidySchemeOrderByWithRelationInput
    subsidyClaims?: SubsidyClaimOrderByRelationAggregateInput
  }

  export type PatientSubsidyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enrollmentNumber?: string
    AND?: PatientSubsidyWhereInput | PatientSubsidyWhereInput[]
    OR?: PatientSubsidyWhereInput[]
    NOT?: PatientSubsidyWhereInput | PatientSubsidyWhereInput[]
    patientId?: IntFilter<"PatientSubsidy"> | number
    schemeId?: IntFilter<"PatientSubsidy"> | number
    enrollmentDate?: DateTimeFilter<"PatientSubsidy"> | Date | string
    cardNumber?: StringNullableFilter<"PatientSubsidy"> | string | null
    validFrom?: DateTimeFilter<"PatientSubsidy"> | Date | string
    validUntil?: DateTimeNullableFilter<"PatientSubsidy"> | Date | string | null
    remainingBalance?: DecimalNullableFilter<"PatientSubsidy"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"PatientSubsidy"> | string
    verificationStatus?: StringFilter<"PatientSubsidy"> | string
    verifiedBy?: IntNullableFilter<"PatientSubsidy"> | number | null
    verifiedAt?: DateTimeNullableFilter<"PatientSubsidy"> | Date | string | null
    notes?: StringNullableFilter<"PatientSubsidy"> | string | null
    createdAt?: DateTimeFilter<"PatientSubsidy"> | Date | string
    updatedAt?: DateTimeFilter<"PatientSubsidy"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    scheme?: XOR<SubsidySchemeScalarRelationFilter, SubsidySchemeWhereInput>
    subsidyClaims?: SubsidyClaimListRelationFilter
  }, "id" | "enrollmentNumber">

  export type PatientSubsidyOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    enrollmentDate?: SortOrder
    enrollmentNumber?: SortOrder
    cardNumber?: SortOrderInput | SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    remainingBalance?: SortOrderInput | SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientSubsidyCountOrderByAggregateInput
    _avg?: PatientSubsidyAvgOrderByAggregateInput
    _max?: PatientSubsidyMaxOrderByAggregateInput
    _min?: PatientSubsidyMinOrderByAggregateInput
    _sum?: PatientSubsidySumOrderByAggregateInput
  }

  export type PatientSubsidyScalarWhereWithAggregatesInput = {
    AND?: PatientSubsidyScalarWhereWithAggregatesInput | PatientSubsidyScalarWhereWithAggregatesInput[]
    OR?: PatientSubsidyScalarWhereWithAggregatesInput[]
    NOT?: PatientSubsidyScalarWhereWithAggregatesInput | PatientSubsidyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatientSubsidy"> | number
    patientId?: IntWithAggregatesFilter<"PatientSubsidy"> | number
    schemeId?: IntWithAggregatesFilter<"PatientSubsidy"> | number
    enrollmentDate?: DateTimeWithAggregatesFilter<"PatientSubsidy"> | Date | string
    enrollmentNumber?: StringWithAggregatesFilter<"PatientSubsidy"> | string
    cardNumber?: StringNullableWithAggregatesFilter<"PatientSubsidy"> | string | null
    validFrom?: DateTimeWithAggregatesFilter<"PatientSubsidy"> | Date | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"PatientSubsidy"> | Date | string | null
    remainingBalance?: DecimalNullableWithAggregatesFilter<"PatientSubsidy"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"PatientSubsidy"> | string
    verificationStatus?: StringWithAggregatesFilter<"PatientSubsidy"> | string
    verifiedBy?: IntNullableWithAggregatesFilter<"PatientSubsidy"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"PatientSubsidy"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PatientSubsidy"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PatientSubsidy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientSubsidy"> | Date | string
  }

  export type SubsidyClaimWhereInput = {
    AND?: SubsidyClaimWhereInput | SubsidyClaimWhereInput[]
    OR?: SubsidyClaimWhereInput[]
    NOT?: SubsidyClaimWhereInput | SubsidyClaimWhereInput[]
    id?: IntFilter<"SubsidyClaim"> | number
    patientSubsidyId?: IntFilter<"SubsidyClaim"> | number
    schemeId?: IntFilter<"SubsidyClaim"> | number
    invoiceId?: IntNullableFilter<"SubsidyClaim"> | number | null
    claimDate?: DateTimeFilter<"SubsidyClaim"> | Date | string
    claimAmount?: DecimalFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: StringNullableFilter<"SubsidyClaim"> | string | null
    claimStatus?: StringFilter<"SubsidyClaim"> | string
    processedBy?: IntNullableFilter<"SubsidyClaim"> | number | null
    processedAt?: DateTimeNullableFilter<"SubsidyClaim"> | Date | string | null
    reimbursementDate?: DateTimeNullableFilter<"SubsidyClaim"> | Date | string | null
    transactionId?: StringNullableFilter<"SubsidyClaim"> | string | null
    notes?: StringNullableFilter<"SubsidyClaim"> | string | null
    createdAt?: DateTimeFilter<"SubsidyClaim"> | Date | string
    updatedAt?: DateTimeFilter<"SubsidyClaim"> | Date | string
    patientSubsidy?: XOR<PatientSubsidyScalarRelationFilter, PatientSubsidyWhereInput>
    scheme?: XOR<SubsidySchemeScalarRelationFilter, SubsidySchemeWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type SubsidyClaimOrderByWithRelationInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    claimDate?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    claimStatus?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    reimbursementDate?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientSubsidy?: PatientSubsidyOrderByWithRelationInput
    scheme?: SubsidySchemeOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type SubsidyClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubsidyClaimWhereInput | SubsidyClaimWhereInput[]
    OR?: SubsidyClaimWhereInput[]
    NOT?: SubsidyClaimWhereInput | SubsidyClaimWhereInput[]
    patientSubsidyId?: IntFilter<"SubsidyClaim"> | number
    schemeId?: IntFilter<"SubsidyClaim"> | number
    invoiceId?: IntNullableFilter<"SubsidyClaim"> | number | null
    claimDate?: DateTimeFilter<"SubsidyClaim"> | Date | string
    claimAmount?: DecimalFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: StringNullableFilter<"SubsidyClaim"> | string | null
    claimStatus?: StringFilter<"SubsidyClaim"> | string
    processedBy?: IntNullableFilter<"SubsidyClaim"> | number | null
    processedAt?: DateTimeNullableFilter<"SubsidyClaim"> | Date | string | null
    reimbursementDate?: DateTimeNullableFilter<"SubsidyClaim"> | Date | string | null
    transactionId?: StringNullableFilter<"SubsidyClaim"> | string | null
    notes?: StringNullableFilter<"SubsidyClaim"> | string | null
    createdAt?: DateTimeFilter<"SubsidyClaim"> | Date | string
    updatedAt?: DateTimeFilter<"SubsidyClaim"> | Date | string
    patientSubsidy?: XOR<PatientSubsidyScalarRelationFilter, PatientSubsidyWhereInput>
    scheme?: XOR<SubsidySchemeScalarRelationFilter, SubsidySchemeWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type SubsidyClaimOrderByWithAggregationInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    claimDate?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    claimStatus?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    reimbursementDate?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubsidyClaimCountOrderByAggregateInput
    _avg?: SubsidyClaimAvgOrderByAggregateInput
    _max?: SubsidyClaimMaxOrderByAggregateInput
    _min?: SubsidyClaimMinOrderByAggregateInput
    _sum?: SubsidyClaimSumOrderByAggregateInput
  }

  export type SubsidyClaimScalarWhereWithAggregatesInput = {
    AND?: SubsidyClaimScalarWhereWithAggregatesInput | SubsidyClaimScalarWhereWithAggregatesInput[]
    OR?: SubsidyClaimScalarWhereWithAggregatesInput[]
    NOT?: SubsidyClaimScalarWhereWithAggregatesInput | SubsidyClaimScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubsidyClaim"> | number
    patientSubsidyId?: IntWithAggregatesFilter<"SubsidyClaim"> | number
    schemeId?: IntWithAggregatesFilter<"SubsidyClaim"> | number
    invoiceId?: IntNullableWithAggregatesFilter<"SubsidyClaim"> | number | null
    claimDate?: DateTimeWithAggregatesFilter<"SubsidyClaim"> | Date | string
    claimAmount?: DecimalWithAggregatesFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableWithAggregatesFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"SubsidyClaim"> | string | null
    claimStatus?: StringWithAggregatesFilter<"SubsidyClaim"> | string
    processedBy?: IntNullableWithAggregatesFilter<"SubsidyClaim"> | number | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"SubsidyClaim"> | Date | string | null
    reimbursementDate?: DateTimeNullableWithAggregatesFilter<"SubsidyClaim"> | Date | string | null
    transactionId?: StringNullableWithAggregatesFilter<"SubsidyClaim"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SubsidyClaim"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubsidyClaim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubsidyClaim"> | Date | string
  }

  export type HousekeepingAreaWhereInput = {
    AND?: HousekeepingAreaWhereInput | HousekeepingAreaWhereInput[]
    OR?: HousekeepingAreaWhereInput[]
    NOT?: HousekeepingAreaWhereInput | HousekeepingAreaWhereInput[]
    id?: IntFilter<"HousekeepingArea"> | number
    name?: StringFilter<"HousekeepingArea"> | string
    description?: StringNullableFilter<"HousekeepingArea"> | string | null
    floor?: StringNullableFilter<"HousekeepingArea"> | string | null
    buildingSection?: StringNullableFilter<"HousekeepingArea"> | string | null
    priority?: StringFilter<"HousekeepingArea"> | string
    cleaningFrequency?: StringFilter<"HousekeepingArea"> | string
    specialInstructions?: StringNullableFilter<"HousekeepingArea"> | string | null
    status?: StringFilter<"HousekeepingArea"> | string
    createdAt?: DateTimeFilter<"HousekeepingArea"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingArea"> | Date | string
    cleaningTasks?: CleaningTaskListRelationFilter
  }

  export type HousekeepingAreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    buildingSection?: SortOrderInput | SortOrder
    priority?: SortOrder
    cleaningFrequency?: SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningTasks?: CleaningTaskOrderByRelationAggregateInput
  }

  export type HousekeepingAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HousekeepingAreaWhereInput | HousekeepingAreaWhereInput[]
    OR?: HousekeepingAreaWhereInput[]
    NOT?: HousekeepingAreaWhereInput | HousekeepingAreaWhereInput[]
    name?: StringFilter<"HousekeepingArea"> | string
    description?: StringNullableFilter<"HousekeepingArea"> | string | null
    floor?: StringNullableFilter<"HousekeepingArea"> | string | null
    buildingSection?: StringNullableFilter<"HousekeepingArea"> | string | null
    priority?: StringFilter<"HousekeepingArea"> | string
    cleaningFrequency?: StringFilter<"HousekeepingArea"> | string
    specialInstructions?: StringNullableFilter<"HousekeepingArea"> | string | null
    status?: StringFilter<"HousekeepingArea"> | string
    createdAt?: DateTimeFilter<"HousekeepingArea"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingArea"> | Date | string
    cleaningTasks?: CleaningTaskListRelationFilter
  }, "id">

  export type HousekeepingAreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    buildingSection?: SortOrderInput | SortOrder
    priority?: SortOrder
    cleaningFrequency?: SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HousekeepingAreaCountOrderByAggregateInput
    _avg?: HousekeepingAreaAvgOrderByAggregateInput
    _max?: HousekeepingAreaMaxOrderByAggregateInput
    _min?: HousekeepingAreaMinOrderByAggregateInput
    _sum?: HousekeepingAreaSumOrderByAggregateInput
  }

  export type HousekeepingAreaScalarWhereWithAggregatesInput = {
    AND?: HousekeepingAreaScalarWhereWithAggregatesInput | HousekeepingAreaScalarWhereWithAggregatesInput[]
    OR?: HousekeepingAreaScalarWhereWithAggregatesInput[]
    NOT?: HousekeepingAreaScalarWhereWithAggregatesInput | HousekeepingAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HousekeepingArea"> | number
    name?: StringWithAggregatesFilter<"HousekeepingArea"> | string
    description?: StringNullableWithAggregatesFilter<"HousekeepingArea"> | string | null
    floor?: StringNullableWithAggregatesFilter<"HousekeepingArea"> | string | null
    buildingSection?: StringNullableWithAggregatesFilter<"HousekeepingArea"> | string | null
    priority?: StringWithAggregatesFilter<"HousekeepingArea"> | string
    cleaningFrequency?: StringWithAggregatesFilter<"HousekeepingArea"> | string
    specialInstructions?: StringNullableWithAggregatesFilter<"HousekeepingArea"> | string | null
    status?: StringWithAggregatesFilter<"HousekeepingArea"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HousekeepingArea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HousekeepingArea"> | Date | string
  }

  export type HousekeepingStaffWhereInput = {
    AND?: HousekeepingStaffWhereInput | HousekeepingStaffWhereInput[]
    OR?: HousekeepingStaffWhereInput[]
    NOT?: HousekeepingStaffWhereInput | HousekeepingStaffWhereInput[]
    id?: IntFilter<"HousekeepingStaff"> | number
    userId?: IntFilter<"HousekeepingStaff"> | number
    staffId?: StringFilter<"HousekeepingStaff"> | string
    supervisor?: BoolFilter<"HousekeepingStaff"> | boolean
    specializedAreas?: StringNullableFilter<"HousekeepingStaff"> | string | null
    createdAt?: DateTimeFilter<"HousekeepingStaff"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cleaningTasks?: CleaningTaskListRelationFilter
    cleaningVerifications?: CleaningVerificationListRelationFilter
    supplyRequests?: CleaningSupplyRequestListRelationFilter
  }

  export type HousekeepingStaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    supervisor?: SortOrder
    specializedAreas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    cleaningTasks?: CleaningTaskOrderByRelationAggregateInput
    cleaningVerifications?: CleaningVerificationOrderByRelationAggregateInput
    supplyRequests?: CleaningSupplyRequestOrderByRelationAggregateInput
  }

  export type HousekeepingStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    staffId?: string
    AND?: HousekeepingStaffWhereInput | HousekeepingStaffWhereInput[]
    OR?: HousekeepingStaffWhereInput[]
    NOT?: HousekeepingStaffWhereInput | HousekeepingStaffWhereInput[]
    supervisor?: BoolFilter<"HousekeepingStaff"> | boolean
    specializedAreas?: StringNullableFilter<"HousekeepingStaff"> | string | null
    createdAt?: DateTimeFilter<"HousekeepingStaff"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cleaningTasks?: CleaningTaskListRelationFilter
    cleaningVerifications?: CleaningVerificationListRelationFilter
    supplyRequests?: CleaningSupplyRequestListRelationFilter
  }, "id" | "userId" | "staffId">

  export type HousekeepingStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    supervisor?: SortOrder
    specializedAreas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HousekeepingStaffCountOrderByAggregateInput
    _avg?: HousekeepingStaffAvgOrderByAggregateInput
    _max?: HousekeepingStaffMaxOrderByAggregateInput
    _min?: HousekeepingStaffMinOrderByAggregateInput
    _sum?: HousekeepingStaffSumOrderByAggregateInput
  }

  export type HousekeepingStaffScalarWhereWithAggregatesInput = {
    AND?: HousekeepingStaffScalarWhereWithAggregatesInput | HousekeepingStaffScalarWhereWithAggregatesInput[]
    OR?: HousekeepingStaffScalarWhereWithAggregatesInput[]
    NOT?: HousekeepingStaffScalarWhereWithAggregatesInput | HousekeepingStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HousekeepingStaff"> | number
    userId?: IntWithAggregatesFilter<"HousekeepingStaff"> | number
    staffId?: StringWithAggregatesFilter<"HousekeepingStaff"> | string
    supervisor?: BoolWithAggregatesFilter<"HousekeepingStaff"> | boolean
    specializedAreas?: StringNullableWithAggregatesFilter<"HousekeepingStaff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HousekeepingStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HousekeepingStaff"> | Date | string
  }

  export type CleaningTaskWhereInput = {
    AND?: CleaningTaskWhereInput | CleaningTaskWhereInput[]
    OR?: CleaningTaskWhereInput[]
    NOT?: CleaningTaskWhereInput | CleaningTaskWhereInput[]
    id?: IntFilter<"CleaningTask"> | number
    areaId?: IntFilter<"CleaningTask"> | number
    assignedToId?: IntNullableFilter<"CleaningTask"> | number | null
    scheduledDate?: DateTimeFilter<"CleaningTask"> | Date | string
    scheduledTime?: StringFilter<"CleaningTask"> | string
    estimatedDuration?: IntFilter<"CleaningTask"> | number
    priority?: StringFilter<"CleaningTask"> | string
    status?: StringFilter<"CleaningTask"> | string
    startedAt?: DateTimeNullableFilter<"CleaningTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CleaningTask"> | Date | string | null
    notes?: StringNullableFilter<"CleaningTask"> | string | null
    createdAt?: DateTimeFilter<"CleaningTask"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningTask"> | Date | string
    area?: XOR<HousekeepingAreaScalarRelationFilter, HousekeepingAreaWhereInput>
    assignedTo?: XOR<HousekeepingStaffNullableScalarRelationFilter, HousekeepingStaffWhereInput> | null
    verifications?: CleaningVerificationListRelationFilter
  }

  export type CleaningTaskOrderByWithRelationInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    area?: HousekeepingAreaOrderByWithRelationInput
    assignedTo?: HousekeepingStaffOrderByWithRelationInput
    verifications?: CleaningVerificationOrderByRelationAggregateInput
  }

  export type CleaningTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CleaningTaskWhereInput | CleaningTaskWhereInput[]
    OR?: CleaningTaskWhereInput[]
    NOT?: CleaningTaskWhereInput | CleaningTaskWhereInput[]
    areaId?: IntFilter<"CleaningTask"> | number
    assignedToId?: IntNullableFilter<"CleaningTask"> | number | null
    scheduledDate?: DateTimeFilter<"CleaningTask"> | Date | string
    scheduledTime?: StringFilter<"CleaningTask"> | string
    estimatedDuration?: IntFilter<"CleaningTask"> | number
    priority?: StringFilter<"CleaningTask"> | string
    status?: StringFilter<"CleaningTask"> | string
    startedAt?: DateTimeNullableFilter<"CleaningTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CleaningTask"> | Date | string | null
    notes?: StringNullableFilter<"CleaningTask"> | string | null
    createdAt?: DateTimeFilter<"CleaningTask"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningTask"> | Date | string
    area?: XOR<HousekeepingAreaScalarRelationFilter, HousekeepingAreaWhereInput>
    assignedTo?: XOR<HousekeepingStaffNullableScalarRelationFilter, HousekeepingStaffWhereInput> | null
    verifications?: CleaningVerificationListRelationFilter
  }, "id">

  export type CleaningTaskOrderByWithAggregationInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningTaskCountOrderByAggregateInput
    _avg?: CleaningTaskAvgOrderByAggregateInput
    _max?: CleaningTaskMaxOrderByAggregateInput
    _min?: CleaningTaskMinOrderByAggregateInput
    _sum?: CleaningTaskSumOrderByAggregateInput
  }

  export type CleaningTaskScalarWhereWithAggregatesInput = {
    AND?: CleaningTaskScalarWhereWithAggregatesInput | CleaningTaskScalarWhereWithAggregatesInput[]
    OR?: CleaningTaskScalarWhereWithAggregatesInput[]
    NOT?: CleaningTaskScalarWhereWithAggregatesInput | CleaningTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CleaningTask"> | number
    areaId?: IntWithAggregatesFilter<"CleaningTask"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"CleaningTask"> | number | null
    scheduledDate?: DateTimeWithAggregatesFilter<"CleaningTask"> | Date | string
    scheduledTime?: StringWithAggregatesFilter<"CleaningTask"> | string
    estimatedDuration?: IntWithAggregatesFilter<"CleaningTask"> | number
    priority?: StringWithAggregatesFilter<"CleaningTask"> | string
    status?: StringWithAggregatesFilter<"CleaningTask"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"CleaningTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CleaningTask"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"CleaningTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningTask"> | Date | string
  }

  export type CleaningVerificationWhereInput = {
    AND?: CleaningVerificationWhereInput | CleaningVerificationWhereInput[]
    OR?: CleaningVerificationWhereInput[]
    NOT?: CleaningVerificationWhereInput | CleaningVerificationWhereInput[]
    id?: IntFilter<"CleaningVerification"> | number
    taskId?: IntFilter<"CleaningVerification"> | number
    verifiedById?: IntFilter<"CleaningVerification"> | number
    verificationDate?: DateTimeFilter<"CleaningVerification"> | Date | string
    rating?: IntFilter<"CleaningVerification"> | number
    cleanliness?: IntFilter<"CleaningVerification"> | number
    comments?: StringNullableFilter<"CleaningVerification"> | string | null
    photosUrl?: StringNullableFilter<"CleaningVerification"> | string | null
    status?: StringFilter<"CleaningVerification"> | string
    followUpRequired?: BoolFilter<"CleaningVerification"> | boolean
    followUpNotes?: StringNullableFilter<"CleaningVerification"> | string | null
    createdAt?: DateTimeFilter<"CleaningVerification"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningVerification"> | Date | string
    task?: XOR<CleaningTaskScalarRelationFilter, CleaningTaskWhereInput>
    verifiedBy?: XOR<HousekeepingStaffScalarRelationFilter, HousekeepingStaffWhereInput>
  }

  export type CleaningVerificationOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    verificationDate?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
    comments?: SortOrderInput | SortOrder
    photosUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: CleaningTaskOrderByWithRelationInput
    verifiedBy?: HousekeepingStaffOrderByWithRelationInput
  }

  export type CleaningVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CleaningVerificationWhereInput | CleaningVerificationWhereInput[]
    OR?: CleaningVerificationWhereInput[]
    NOT?: CleaningVerificationWhereInput | CleaningVerificationWhereInput[]
    taskId?: IntFilter<"CleaningVerification"> | number
    verifiedById?: IntFilter<"CleaningVerification"> | number
    verificationDate?: DateTimeFilter<"CleaningVerification"> | Date | string
    rating?: IntFilter<"CleaningVerification"> | number
    cleanliness?: IntFilter<"CleaningVerification"> | number
    comments?: StringNullableFilter<"CleaningVerification"> | string | null
    photosUrl?: StringNullableFilter<"CleaningVerification"> | string | null
    status?: StringFilter<"CleaningVerification"> | string
    followUpRequired?: BoolFilter<"CleaningVerification"> | boolean
    followUpNotes?: StringNullableFilter<"CleaningVerification"> | string | null
    createdAt?: DateTimeFilter<"CleaningVerification"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningVerification"> | Date | string
    task?: XOR<CleaningTaskScalarRelationFilter, CleaningTaskWhereInput>
    verifiedBy?: XOR<HousekeepingStaffScalarRelationFilter, HousekeepingStaffWhereInput>
  }, "id">

  export type CleaningVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    verificationDate?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
    comments?: SortOrderInput | SortOrder
    photosUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningVerificationCountOrderByAggregateInput
    _avg?: CleaningVerificationAvgOrderByAggregateInput
    _max?: CleaningVerificationMaxOrderByAggregateInput
    _min?: CleaningVerificationMinOrderByAggregateInput
    _sum?: CleaningVerificationSumOrderByAggregateInput
  }

  export type CleaningVerificationScalarWhereWithAggregatesInput = {
    AND?: CleaningVerificationScalarWhereWithAggregatesInput | CleaningVerificationScalarWhereWithAggregatesInput[]
    OR?: CleaningVerificationScalarWhereWithAggregatesInput[]
    NOT?: CleaningVerificationScalarWhereWithAggregatesInput | CleaningVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CleaningVerification"> | number
    taskId?: IntWithAggregatesFilter<"CleaningVerification"> | number
    verifiedById?: IntWithAggregatesFilter<"CleaningVerification"> | number
    verificationDate?: DateTimeWithAggregatesFilter<"CleaningVerification"> | Date | string
    rating?: IntWithAggregatesFilter<"CleaningVerification"> | number
    cleanliness?: IntWithAggregatesFilter<"CleaningVerification"> | number
    comments?: StringNullableWithAggregatesFilter<"CleaningVerification"> | string | null
    photosUrl?: StringNullableWithAggregatesFilter<"CleaningVerification"> | string | null
    status?: StringWithAggregatesFilter<"CleaningVerification"> | string
    followUpRequired?: BoolWithAggregatesFilter<"CleaningVerification"> | boolean
    followUpNotes?: StringNullableWithAggregatesFilter<"CleaningVerification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningVerification"> | Date | string
  }

  export type CleaningSupplyWhereInput = {
    AND?: CleaningSupplyWhereInput | CleaningSupplyWhereInput[]
    OR?: CleaningSupplyWhereInput[]
    NOT?: CleaningSupplyWhereInput | CleaningSupplyWhereInput[]
    id?: IntFilter<"CleaningSupply"> | number
    name?: StringFilter<"CleaningSupply"> | string
    description?: StringNullableFilter<"CleaningSupply"> | string | null
    unit?: StringFilter<"CleaningSupply"> | string
    currentStock?: IntFilter<"CleaningSupply"> | number
    reorderLevel?: IntFilter<"CleaningSupply"> | number
    location?: StringNullableFilter<"CleaningSupply"> | string | null
    supplier?: StringNullableFilter<"CleaningSupply"> | string | null
    lastPurchaseDate?: DateTimeNullableFilter<"CleaningSupply"> | Date | string | null
    lastPurchasePrice?: DecimalNullableFilter<"CleaningSupply"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"CleaningSupply"> | string
    createdAt?: DateTimeFilter<"CleaningSupply"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupply"> | Date | string
    supplyRequests?: CleaningSupplyRequestItemListRelationFilter
  }

  export type CleaningSupplyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    location?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    lastPurchaseDate?: SortOrderInput | SortOrder
    lastPurchasePrice?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplyRequests?: CleaningSupplyRequestItemOrderByRelationAggregateInput
  }

  export type CleaningSupplyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CleaningSupplyWhereInput | CleaningSupplyWhereInput[]
    OR?: CleaningSupplyWhereInput[]
    NOT?: CleaningSupplyWhereInput | CleaningSupplyWhereInput[]
    name?: StringFilter<"CleaningSupply"> | string
    description?: StringNullableFilter<"CleaningSupply"> | string | null
    unit?: StringFilter<"CleaningSupply"> | string
    currentStock?: IntFilter<"CleaningSupply"> | number
    reorderLevel?: IntFilter<"CleaningSupply"> | number
    location?: StringNullableFilter<"CleaningSupply"> | string | null
    supplier?: StringNullableFilter<"CleaningSupply"> | string | null
    lastPurchaseDate?: DateTimeNullableFilter<"CleaningSupply"> | Date | string | null
    lastPurchasePrice?: DecimalNullableFilter<"CleaningSupply"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"CleaningSupply"> | string
    createdAt?: DateTimeFilter<"CleaningSupply"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupply"> | Date | string
    supplyRequests?: CleaningSupplyRequestItemListRelationFilter
  }, "id">

  export type CleaningSupplyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    location?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    lastPurchaseDate?: SortOrderInput | SortOrder
    lastPurchasePrice?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningSupplyCountOrderByAggregateInput
    _avg?: CleaningSupplyAvgOrderByAggregateInput
    _max?: CleaningSupplyMaxOrderByAggregateInput
    _min?: CleaningSupplyMinOrderByAggregateInput
    _sum?: CleaningSupplySumOrderByAggregateInput
  }

  export type CleaningSupplyScalarWhereWithAggregatesInput = {
    AND?: CleaningSupplyScalarWhereWithAggregatesInput | CleaningSupplyScalarWhereWithAggregatesInput[]
    OR?: CleaningSupplyScalarWhereWithAggregatesInput[]
    NOT?: CleaningSupplyScalarWhereWithAggregatesInput | CleaningSupplyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CleaningSupply"> | number
    name?: StringWithAggregatesFilter<"CleaningSupply"> | string
    description?: StringNullableWithAggregatesFilter<"CleaningSupply"> | string | null
    unit?: StringWithAggregatesFilter<"CleaningSupply"> | string
    currentStock?: IntWithAggregatesFilter<"CleaningSupply"> | number
    reorderLevel?: IntWithAggregatesFilter<"CleaningSupply"> | number
    location?: StringNullableWithAggregatesFilter<"CleaningSupply"> | string | null
    supplier?: StringNullableWithAggregatesFilter<"CleaningSupply"> | string | null
    lastPurchaseDate?: DateTimeNullableWithAggregatesFilter<"CleaningSupply"> | Date | string | null
    lastPurchasePrice?: DecimalNullableWithAggregatesFilter<"CleaningSupply"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"CleaningSupply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CleaningSupply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningSupply"> | Date | string
  }

  export type CleaningSupplyRequestWhereInput = {
    AND?: CleaningSupplyRequestWhereInput | CleaningSupplyRequestWhereInput[]
    OR?: CleaningSupplyRequestWhereInput[]
    NOT?: CleaningSupplyRequestWhereInput | CleaningSupplyRequestWhereInput[]
    id?: IntFilter<"CleaningSupplyRequest"> | number
    requestedById?: IntFilter<"CleaningSupplyRequest"> | number
    requestDate?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    requiredBy?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    status?: StringFilter<"CleaningSupplyRequest"> | string
    approvedById?: IntNullableFilter<"CleaningSupplyRequest"> | number | null
    approvedAt?: DateTimeNullableFilter<"CleaningSupplyRequest"> | Date | string | null
    fulfilledAt?: DateTimeNullableFilter<"CleaningSupplyRequest"> | Date | string | null
    notes?: StringNullableFilter<"CleaningSupplyRequest"> | string | null
    createdAt?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    requestedBy?: XOR<HousekeepingStaffScalarRelationFilter, HousekeepingStaffWhereInput>
    requestItems?: CleaningSupplyRequestItemListRelationFilter
  }

  export type CleaningSupplyRequestOrderByWithRelationInput = {
    id?: SortOrder
    requestedById?: SortOrder
    requestDate?: SortOrder
    requiredBy?: SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    fulfilledAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requestedBy?: HousekeepingStaffOrderByWithRelationInput
    requestItems?: CleaningSupplyRequestItemOrderByRelationAggregateInput
  }

  export type CleaningSupplyRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CleaningSupplyRequestWhereInput | CleaningSupplyRequestWhereInput[]
    OR?: CleaningSupplyRequestWhereInput[]
    NOT?: CleaningSupplyRequestWhereInput | CleaningSupplyRequestWhereInput[]
    requestedById?: IntFilter<"CleaningSupplyRequest"> | number
    requestDate?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    requiredBy?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    status?: StringFilter<"CleaningSupplyRequest"> | string
    approvedById?: IntNullableFilter<"CleaningSupplyRequest"> | number | null
    approvedAt?: DateTimeNullableFilter<"CleaningSupplyRequest"> | Date | string | null
    fulfilledAt?: DateTimeNullableFilter<"CleaningSupplyRequest"> | Date | string | null
    notes?: StringNullableFilter<"CleaningSupplyRequest"> | string | null
    createdAt?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    requestedBy?: XOR<HousekeepingStaffScalarRelationFilter, HousekeepingStaffWhereInput>
    requestItems?: CleaningSupplyRequestItemListRelationFilter
  }, "id">

  export type CleaningSupplyRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requestedById?: SortOrder
    requestDate?: SortOrder
    requiredBy?: SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    fulfilledAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningSupplyRequestCountOrderByAggregateInput
    _avg?: CleaningSupplyRequestAvgOrderByAggregateInput
    _max?: CleaningSupplyRequestMaxOrderByAggregateInput
    _min?: CleaningSupplyRequestMinOrderByAggregateInput
    _sum?: CleaningSupplyRequestSumOrderByAggregateInput
  }

  export type CleaningSupplyRequestScalarWhereWithAggregatesInput = {
    AND?: CleaningSupplyRequestScalarWhereWithAggregatesInput | CleaningSupplyRequestScalarWhereWithAggregatesInput[]
    OR?: CleaningSupplyRequestScalarWhereWithAggregatesInput[]
    NOT?: CleaningSupplyRequestScalarWhereWithAggregatesInput | CleaningSupplyRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CleaningSupplyRequest"> | number
    requestedById?: IntWithAggregatesFilter<"CleaningSupplyRequest"> | number
    requestDate?: DateTimeWithAggregatesFilter<"CleaningSupplyRequest"> | Date | string
    requiredBy?: DateTimeWithAggregatesFilter<"CleaningSupplyRequest"> | Date | string
    status?: StringWithAggregatesFilter<"CleaningSupplyRequest"> | string
    approvedById?: IntNullableWithAggregatesFilter<"CleaningSupplyRequest"> | number | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"CleaningSupplyRequest"> | Date | string | null
    fulfilledAt?: DateTimeNullableWithAggregatesFilter<"CleaningSupplyRequest"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"CleaningSupplyRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningSupplyRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningSupplyRequest"> | Date | string
  }

  export type CleaningSupplyRequestItemWhereInput = {
    AND?: CleaningSupplyRequestItemWhereInput | CleaningSupplyRequestItemWhereInput[]
    OR?: CleaningSupplyRequestItemWhereInput[]
    NOT?: CleaningSupplyRequestItemWhereInput | CleaningSupplyRequestItemWhereInput[]
    id?: IntFilter<"CleaningSupplyRequestItem"> | number
    requestId?: IntFilter<"CleaningSupplyRequestItem"> | number
    supplyId?: IntFilter<"CleaningSupplyRequestItem"> | number
    quantityRequested?: IntFilter<"CleaningSupplyRequestItem"> | number
    quantityApproved?: IntNullableFilter<"CleaningSupplyRequestItem"> | number | null
    quantityFulfilled?: IntNullableFilter<"CleaningSupplyRequestItem"> | number | null
    notes?: StringNullableFilter<"CleaningSupplyRequestItem"> | string | null
    createdAt?: DateTimeFilter<"CleaningSupplyRequestItem"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupplyRequestItem"> | Date | string
    request?: XOR<CleaningSupplyRequestScalarRelationFilter, CleaningSupplyRequestWhereInput>
    supply?: XOR<CleaningSupplyScalarRelationFilter, CleaningSupplyWhereInput>
  }

  export type CleaningSupplyRequestItemOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrderInput | SortOrder
    quantityFulfilled?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    request?: CleaningSupplyRequestOrderByWithRelationInput
    supply?: CleaningSupplyOrderByWithRelationInput
  }

  export type CleaningSupplyRequestItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CleaningSupplyRequestItemWhereInput | CleaningSupplyRequestItemWhereInput[]
    OR?: CleaningSupplyRequestItemWhereInput[]
    NOT?: CleaningSupplyRequestItemWhereInput | CleaningSupplyRequestItemWhereInput[]
    requestId?: IntFilter<"CleaningSupplyRequestItem"> | number
    supplyId?: IntFilter<"CleaningSupplyRequestItem"> | number
    quantityRequested?: IntFilter<"CleaningSupplyRequestItem"> | number
    quantityApproved?: IntNullableFilter<"CleaningSupplyRequestItem"> | number | null
    quantityFulfilled?: IntNullableFilter<"CleaningSupplyRequestItem"> | number | null
    notes?: StringNullableFilter<"CleaningSupplyRequestItem"> | string | null
    createdAt?: DateTimeFilter<"CleaningSupplyRequestItem"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupplyRequestItem"> | Date | string
    request?: XOR<CleaningSupplyRequestScalarRelationFilter, CleaningSupplyRequestWhereInput>
    supply?: XOR<CleaningSupplyScalarRelationFilter, CleaningSupplyWhereInput>
  }, "id">

  export type CleaningSupplyRequestItemOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrderInput | SortOrder
    quantityFulfilled?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningSupplyRequestItemCountOrderByAggregateInput
    _avg?: CleaningSupplyRequestItemAvgOrderByAggregateInput
    _max?: CleaningSupplyRequestItemMaxOrderByAggregateInput
    _min?: CleaningSupplyRequestItemMinOrderByAggregateInput
    _sum?: CleaningSupplyRequestItemSumOrderByAggregateInput
  }

  export type CleaningSupplyRequestItemScalarWhereWithAggregatesInput = {
    AND?: CleaningSupplyRequestItemScalarWhereWithAggregatesInput | CleaningSupplyRequestItemScalarWhereWithAggregatesInput[]
    OR?: CleaningSupplyRequestItemScalarWhereWithAggregatesInput[]
    NOT?: CleaningSupplyRequestItemScalarWhereWithAggregatesInput | CleaningSupplyRequestItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CleaningSupplyRequestItem"> | number
    requestId?: IntWithAggregatesFilter<"CleaningSupplyRequestItem"> | number
    supplyId?: IntWithAggregatesFilter<"CleaningSupplyRequestItem"> | number
    quantityRequested?: IntWithAggregatesFilter<"CleaningSupplyRequestItem"> | number
    quantityApproved?: IntNullableWithAggregatesFilter<"CleaningSupplyRequestItem"> | number | null
    quantityFulfilled?: IntNullableWithAggregatesFilter<"CleaningSupplyRequestItem"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CleaningSupplyRequestItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningSupplyRequestItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningSupplyRequestItem"> | Date | string
  }

  export type PermissionCreateInput = {
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleId: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleId: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorCreateInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    labReports?: LabReportCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorUpdateManyMutationInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCreateInput = {
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNurseInput
    vitalSigns?: VitalSignCreateNestedManyWithoutNurseInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutNurseInput
  }

  export type NurseUncheckedCreateInput = {
    id?: number
    userId: number
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutNurseInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutNurseInput
  }

  export type NurseUpdateInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNurseNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutNurseNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutNurseNestedInput
  }

  export type NurseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutNurseNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type NurseCreateManyInput = {
    id?: number
    userId: number
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NurseUpdateManyMutationInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
    appointment?: AppointmentCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
    appointment?: AppointmentUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionUpdateManyMutationInput = {
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineCreateInput = {
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescription: PrescriptionCreateNestedOneWithoutMedicinesInput
    medicine: MedicineCreateNestedOneWithoutPrescriptionMedicinesInput
  }

  export type PrescriptionMedicineUncheckedCreateInput = {
    id?: number
    prescriptionId: number
    medicineId: number
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionMedicineUpdateInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescription?: PrescriptionUpdateOneRequiredWithoutMedicinesNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutPrescriptionMedicinesNestedInput
  }

  export type PrescriptionMedicineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineCreateManyInput = {
    id?: number
    prescriptionId: number
    medicineId: number
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionMedicineUpdateManyMutationInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineCreateInput = {
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionMedicines?: PrescriptionMedicineCreateNestedManyWithoutMedicineInput
    inventoryLogs?: InventoryLogCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateInput = {
    id?: number
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionMedicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutMedicineInput
    inventoryLogs?: InventoryLogUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionMedicines?: PrescriptionMedicineUpdateManyWithoutMedicineNestedInput
    inventoryLogs?: InventoryLogUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionMedicines?: PrescriptionMedicineUncheckedUpdateManyWithoutMedicineNestedInput
    inventoryLogs?: InventoryLogUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineCreateManyInput = {
    id?: number
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLogCreateInput = {
    quantity: number
    type: string
    reason?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutInventoryLogsInput
  }

  export type InventoryLogUncheckedCreateInput = {
    id?: number
    medicineId: number
    quantity: number
    type: string
    reason?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryLogUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutInventoryLogsNestedInput
  }

  export type InventoryLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLogCreateManyInput = {
    id?: number
    medicineId: number
    quantity: number
    type: string
    reason?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryLogUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportCreateInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutLabReportsInput
    doctor: DoctorCreateNestedOneWithoutLabReportsInput
    appointment?: AppointmentCreateNestedOneWithoutLabReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutLabReportInput
  }

  export type LabReportUncheckedCreateInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutLabReportInput
  }

  export type LabReportUpdateInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutLabReportsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutLabReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutLabReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportCreateManyInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabReportUpdateManyMutationInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyReportCreateInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRadiologyReportsInput
    doctor: DoctorCreateNestedOneWithoutRadiologyReportsInput
    appointment?: AppointmentCreateNestedOneWithoutRadiologyReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportUncheckedCreateInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportUpdateInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRadiologyReportsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutRadiologyReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutRadiologyReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportCreateManyInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyReportUpdateManyMutationInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: UserCreateNestedOneWithoutInvoicesInput
    patientDetails: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    patientId: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    patientDetails?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    patientId: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
    labReport?: LabReportCreateNestedOneWithoutInvoiceItemsInput
    radiologyReport?: RadiologyReportCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    labReportId?: number | null
    radiologyReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateInput = {
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
    labReport?: LabReportUpdateOneWithoutInvoiceItemsNestedInput
    radiologyReport?: RadiologyReportUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    labReportId?: NullableIntFieldUpdateOperationsInput | number | null
    radiologyReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    labReportId?: number | null
    radiologyReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    labReportId?: NullableIntFieldUpdateOperationsInput | number | null
    radiologyReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    patient: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    invoiceId: number
    patientId: number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    patient?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    invoiceId: number
    patientId: number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedCreateInput = {
    bedNumber: string
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ward: WardCreateNestedOneWithoutBedsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateInput = {
    id?: number
    bedNumber: string
    wardId: number
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedUpdateInput = {
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedNumber?: StringFieldUpdateOperationsInput | string
    wardId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedCreateManyInput = {
    id?: number
    bedNumber: string
    wardId: number
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedUpdateManyMutationInput = {
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedNumber?: StringFieldUpdateOperationsInput | string
    wardId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardCreateInput = {
    name: string
    wardType: string
    floor?: string | null
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateInput = {
    id?: number
    name: string
    wardType: string
    floor?: string | null
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    wardType?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    wardType?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardCreateManyInput = {
    id?: number
    name: string
    wardType: string
    floor?: string | null
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    wardType?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    wardType?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationCreateInput = {
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bed: BedCreateNestedOneWithoutBedAllocationsInput
    patient: PatientCreateNestedOneWithoutBedAllocationsInput
    nurse?: NurseCreateNestedOneWithoutBedAllocationsInput
  }

  export type BedAllocationUncheckedCreateInput = {
    id?: number
    bedId: number
    patientId: number
    nurseId?: number | null
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationUpdateInput = {
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bed?: BedUpdateOneRequiredWithoutBedAllocationsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBedAllocationsNestedInput
    nurse?: NurseUpdateOneWithoutBedAllocationsNestedInput
  }

  export type BedAllocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationCreateManyInput = {
    id?: number
    bedId: number
    patientId: number
    nurseId?: number | null
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationUpdateManyMutationInput = {
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignCreateInput = {
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutVitalSignsInput
    nurse: NurseCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignUncheckedCreateInput = {
    id?: number
    patientId: number
    recordedBy: number
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignUpdateInput = {
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutVitalSignsNestedInput
    nurse?: NurseUpdateOneRequiredWithoutVitalSignsNestedInput
  }

  export type VitalSignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    recordedBy?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignCreateManyInput = {
    id?: number
    patientId: number
    recordedBy: number
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignUpdateManyMutationInput = {
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    recordedBy?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterCreateInput = {
    name: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: DoctorCreateNestedOneWithoutOperationTheatersInput
    surgeries?: SurgeryCreateNestedManyWithoutOperationTheaterInput
    equipments?: OperationTheaterEquipmentCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    status?: string
    doctorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutOperationTheaterInput
    equipments?: OperationTheaterEquipmentUncheckedCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneWithoutOperationTheatersNestedInput
    surgeries?: SurgeryUpdateManyWithoutOperationTheaterNestedInput
    equipments?: OperationTheaterEquipmentUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surgeries?: SurgeryUncheckedUpdateManyWithoutOperationTheaterNestedInput
    equipments?: OperationTheaterEquipmentUncheckedUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    status?: string
    doctorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgeryCreateInput = {
    patientId: number
    surgeryDate: Date | string
    startTime: string
    endTime: string
    surgeryType: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    operationTheater: OperationTheaterCreateNestedOneWithoutSurgeriesInput
  }

  export type SurgeryUncheckedCreateInput = {
    id?: number
    patientId: number
    operationTheaterId: number
    surgeryDate: Date | string
    startTime: string
    endTime: string
    surgeryType: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurgeryUpdateInput = {
    patientId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationTheater?: OperationTheaterUpdateOneRequiredWithoutSurgeriesNestedInput
  }

  export type SurgeryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    operationTheaterId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgeryCreateManyInput = {
    id?: number
    patientId: number
    operationTheaterId: number
    surgeryDate: Date | string
    startTime: string
    endTime: string
    surgeryType: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurgeryUpdateManyMutationInput = {
    patientId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgeryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    operationTheaterId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterEquipmentCreateInput = {
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    purchaseDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    operationTheater: OperationTheaterCreateNestedOneWithoutEquipmentsInput
  }

  export type OperationTheaterEquipmentUncheckedCreateInput = {
    id?: number
    operationTheaterId: number
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    purchaseDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterEquipmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationTheater?: OperationTheaterUpdateOneRequiredWithoutEquipmentsNestedInput
  }

  export type OperationTheaterEquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationTheaterId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterEquipmentCreateManyInput = {
    id?: number
    operationTheaterId: number
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    purchaseDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterEquipmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterEquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationTheaterId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalGasCylinderCreateInput = {
    cylinderNumber: string
    gasType: string
    capacity: number
    currentLevel: number
    location?: string | null
    status?: string
    lastRefillDate?: Date | string | null
    nextRefillDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalGasCylinderUncheckedCreateInput = {
    id?: number
    cylinderNumber: string
    gasType: string
    capacity: number
    currentLevel: number
    location?: string | null
    status?: string
    lastRefillDate?: Date | string | null
    nextRefillDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalGasCylinderUpdateInput = {
    cylinderNumber?: StringFieldUpdateOperationsInput | string
    gasType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    currentLevel?: FloatFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalGasCylinderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cylinderNumber?: StringFieldUpdateOperationsInput | string
    gasType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    currentLevel?: FloatFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalGasCylinderCreateManyInput = {
    id?: number
    cylinderNumber: string
    gasType: string
    capacity: number
    currentLevel: number
    location?: string | null
    status?: string
    lastRefillDate?: Date | string | null
    nextRefillDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalGasCylinderUpdateManyMutationInput = {
    cylinderNumber?: StringFieldUpdateOperationsInput | string
    gasType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    currentLevel?: FloatFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalGasCylinderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cylinderNumber?: StringFieldUpdateOperationsInput | string
    gasType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    currentLevel?: FloatFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRefillDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentMaintenanceCreateInput = {
    equipmentType: string
    equipmentId: number
    maintenanceDate: Date | string
    maintenanceType: string
    performedBy: string
    cost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentMaintenanceUncheckedCreateInput = {
    id?: number
    equipmentType: string
    equipmentId: number
    maintenanceDate: Date | string
    maintenanceType: string
    performedBy: string
    cost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentMaintenanceUpdateInput = {
    equipmentType?: StringFieldUpdateOperationsInput | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    maintenanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentMaintenanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentType?: StringFieldUpdateOperationsInput | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    maintenanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentMaintenanceCreateManyInput = {
    id?: number
    equipmentType: string
    equipmentId: number
    maintenanceDate: Date | string
    maintenanceType: string
    performedBy: string
    cost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentMaintenanceUpdateManyMutationInput = {
    equipmentType?: StringFieldUpdateOperationsInput | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    maintenanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentMaintenanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentType?: StringFieldUpdateOperationsInput | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    maintenanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceCreateInput = {
    vehicleNumber: string
    model?: string | null
    type: string
    capacity?: number
    driverName?: string | null
    driverContact?: string | null
    status?: string
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambulanceServices?: AmbulanceServiceCreateNestedManyWithoutAmbulanceInput
  }

  export type AmbulanceUncheckedCreateInput = {
    id?: number
    vehicleNumber: string
    model?: string | null
    type: string
    capacity?: number
    driverName?: string | null
    driverContact?: string | null
    status?: string
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambulanceServices?: AmbulanceServiceUncheckedCreateNestedManyWithoutAmbulanceInput
  }

  export type AmbulanceUpdateInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambulanceServices?: AmbulanceServiceUpdateManyWithoutAmbulanceNestedInput
  }

  export type AmbulanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambulanceServices?: AmbulanceServiceUncheckedUpdateManyWithoutAmbulanceNestedInput
  }

  export type AmbulanceCreateManyInput = {
    id?: number
    vehicleNumber: string
    model?: string | null
    type: string
    capacity?: number
    driverName?: string | null
    driverContact?: string | null
    status?: string
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceUpdateManyMutationInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceServiceCreateInput = {
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date | string
    status?: string
    fare?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambulance: AmbulanceCreateNestedOneWithoutAmbulanceServicesInput
  }

  export type AmbulanceServiceUncheckedCreateInput = {
    id?: number
    ambulanceId: number
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date | string
    status?: string
    fare?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceServiceUpdateInput = {
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambulance?: AmbulanceUpdateOneRequiredWithoutAmbulanceServicesNestedInput
  }

  export type AmbulanceServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ambulanceId?: IntFieldUpdateOperationsInput | number
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceServiceCreateManyInput = {
    id?: number
    ambulanceId: number
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date | string
    status?: string
    fare?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceServiceUpdateManyMutationInput = {
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ambulanceId?: IntFieldUpdateOperationsInput | number
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataCreateInput = {
    biometricId: string
    fingerprint?: string | null
    faceData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiometricDataInput
  }

  export type BiometricDataUncheckedCreateInput = {
    id?: number
    userId: number
    biometricId: string
    fingerprint?: string | null
    faceData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataUpdateInput = {
    biometricId?: StringFieldUpdateOperationsInput | string
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    faceData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiometricDataNestedInput
  }

  export type BiometricDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    biometricId?: StringFieldUpdateOperationsInput | string
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    faceData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataCreateManyInput = {
    id?: number
    userId: number
    biometricId: string
    fingerprint?: string | null
    faceData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataUpdateManyMutationInput = {
    biometricId?: StringFieldUpdateOperationsInput | string
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    faceData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    biometricId?: StringFieldUpdateOperationsInput | string
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    faceData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateInput = {
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status: string
    deviceId?: string | null
    verificationMode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceLogsInput
  }

  export type AttendanceLogUncheckedCreateInput = {
    id?: number
    userId: number
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status: string
    deviceId?: string | null
    verificationMode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUpdateInput = {
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceLogsNestedInput
  }

  export type AttendanceLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateManyInput = {
    id?: number
    userId: number
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status: string
    deviceId?: string | null
    verificationMode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUpdateManyMutationInput = {
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRosterCreateInput = {
    startDate: Date | string
    endDate: Date | string
    shiftStart: string
    shiftEnd: string
    department?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDutyRostersInput
  }

  export type DutyRosterUncheckedCreateInput = {
    id?: number
    userId: number
    startDate: Date | string
    endDate: Date | string
    shiftStart: string
    shiftEnd: string
    department?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyRosterUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDutyRostersNestedInput
  }

  export type DutyRosterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRosterCreateManyInput = {
    id?: number
    userId: number
    startDate: Date | string
    endDate: Date | string
    shiftStart: string
    shiftEnd: string
    department?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyRosterUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRosterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TPACreateInput = {
    name: string
    contactPerson?: string | null
    contactNumber?: string | null
    email?: string | null
    address?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patients?: PatientCreateNestedManyWithoutTpaInput
  }

  export type TPAUncheckedCreateInput = {
    id?: number
    name: string
    contactPerson?: string | null
    contactNumber?: string | null
    email?: string | null
    address?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patients?: PatientUncheckedCreateNestedManyWithoutTpaInput
  }

  export type TPAUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUpdateManyWithoutTpaNestedInput
  }

  export type TPAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUncheckedUpdateManyWithoutTpaNestedInput
  }

  export type TPACreateManyInput = {
    id?: number
    name: string
    contactPerson?: string | null
    contactNumber?: string | null
    email?: string | null
    address?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TPAUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TPAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateInput = {
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: number
    employeeId: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateManyInput = {
    id?: number
    employeeId: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateManyMutationInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentCreateInput = {
    paymentDate: Date | string
    salaryMonth: string
    basicSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    taxDeducted?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSalaryPaymentsInput
  }

  export type SalaryPaymentUncheckedCreateInput = {
    id?: number
    employeeId: number
    paymentDate: Date | string
    salaryMonth: string
    basicSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    taxDeducted?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentUpdateInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSalaryPaymentsNestedInput
  }

  export type SalaryPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentCreateManyInput = {
    id?: number
    employeeId: number
    paymentDate: Date | string
    salaryMonth: string
    basicSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    taxDeducted?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentUpdateManyMutationInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentCreateInput = {
    documentType: string
    documentName: string
    documentUrl: string
    isVerified?: boolean
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutDocumentsInput
  }

  export type EmployeeDocumentUncheckedCreateInput = {
    id?: number
    employeeId: number
    documentType: string
    documentName: string
    documentUrl: string
    isVerified?: boolean
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentUpdateInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type EmployeeDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentCreateManyInput = {
    id?: number
    employeeId: number
    documentType: string
    documentName: string
    documentUrl: string
    isVerified?: boolean
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentUpdateManyMutationInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewCreateInput = {
    reviewDate: Date | string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    reviewedBy: number
    rating: number
    strengths?: string | null
    areasOfImprovement?: string | null
    goals?: string | null
    comments?: string | null
    employeeComments?: string | null
    status?: string
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPerformanceReviewsInput
  }

  export type PerformanceReviewUncheckedCreateInput = {
    id?: number
    employeeId: number
    reviewDate: Date | string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    reviewedBy: number
    rating: number
    strengths?: string | null
    areasOfImprovement?: string | null
    goals?: string | null
    comments?: string | null
    employeeComments?: string | null
    status?: string
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewUpdateInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPerformanceReviewsNestedInput
  }

  export type PerformanceReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewCreateManyInput = {
    id?: number
    employeeId: number
    reviewDate: Date | string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    reviewedBy: number
    rating: number
    strengths?: string | null
    areasOfImprovement?: string | null
    goals?: string | null
    comments?: string | null
    employeeComments?: string | null
    status?: string
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewUpdateManyMutationInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidySchemeCreateInput = {
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutSchemeInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutSchemeInput
  }

  export type SubsidySchemeUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutSchemeInput
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutSchemeInput
  }

  export type SubsidySchemeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidies?: PatientSubsidyUpdateManyWithoutSchemeNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutSchemeNestedInput
  }

  export type SubsidySchemeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutSchemeNestedInput
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutSchemeNestedInput
  }

  export type SubsidySchemeCreateManyInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidySchemeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidySchemeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSubsidyCreateInput = {
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPatientSubsidiesInput
    scheme: SubsidySchemeCreateNestedOneWithoutPatientSubsidiesInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutPatientSubsidyInput
  }

  export type PatientSubsidyUncheckedCreateInput = {
    id?: number
    patientId: number
    schemeId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutPatientSubsidyInput
  }

  export type PatientSubsidyUpdateInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPatientSubsidiesNestedInput
    scheme?: SubsidySchemeUpdateOneRequiredWithoutPatientSubsidiesNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutPatientSubsidyNestedInput
  }

  export type PatientSubsidyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutPatientSubsidyNestedInput
  }

  export type PatientSubsidyCreateManyInput = {
    id?: number
    patientId: number
    schemeId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientSubsidyUpdateManyMutationInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSubsidyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimCreateInput = {
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidy: PatientSubsidyCreateNestedOneWithoutSubsidyClaimsInput
    scheme: SubsidySchemeCreateNestedOneWithoutSubsidyClaimsInput
    invoice?: InvoiceCreateNestedOneWithoutSubsidyClaimsInput
  }

  export type SubsidyClaimUncheckedCreateInput = {
    id?: number
    patientSubsidyId: number
    schemeId: number
    invoiceId?: number | null
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimUpdateInput = {
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidy?: PatientSubsidyUpdateOneRequiredWithoutSubsidyClaimsNestedInput
    scheme?: SubsidySchemeUpdateOneRequiredWithoutSubsidyClaimsNestedInput
    invoice?: InvoiceUpdateOneWithoutSubsidyClaimsNestedInput
  }

  export type SubsidyClaimUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientSubsidyId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimCreateManyInput = {
    id?: number
    patientSubsidyId: number
    schemeId: number
    invoiceId?: number | null
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimUpdateManyMutationInput = {
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientSubsidyId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingAreaCreateInput = {
    name: string
    description?: string | null
    floor?: string | null
    buildingSection?: string | null
    priority?: string
    cleaningFrequency: string
    specialInstructions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskCreateNestedManyWithoutAreaInput
  }

  export type HousekeepingAreaUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    floor?: string | null
    buildingSection?: string | null
    priority?: string
    cleaningFrequency: string
    specialInstructions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskUncheckedCreateNestedManyWithoutAreaInput
  }

  export type HousekeepingAreaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    buildingSection?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    cleaningFrequency?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUpdateManyWithoutAreaNestedInput
  }

  export type HousekeepingAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    buildingSection?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    cleaningFrequency?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type HousekeepingAreaCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    floor?: string | null
    buildingSection?: string | null
    priority?: string
    cleaningFrequency: string
    specialInstructions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingAreaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    buildingSection?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    cleaningFrequency?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    buildingSection?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    cleaningFrequency?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingStaffCreateInput = {
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHousekeepingStaffInput
    cleaningTasks?: CleaningTaskCreateNestedManyWithoutAssignedToInput
    cleaningVerifications?: CleaningVerificationCreateNestedManyWithoutVerifiedByInput
    supplyRequests?: CleaningSupplyRequestCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffUncheckedCreateInput = {
    id?: number
    userId: number
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskUncheckedCreateNestedManyWithoutAssignedToInput
    cleaningVerifications?: CleaningVerificationUncheckedCreateNestedManyWithoutVerifiedByInput
    supplyRequests?: CleaningSupplyRequestUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffUpdateInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHousekeepingStaffNestedInput
    cleaningTasks?: CleaningTaskUpdateManyWithoutAssignedToNestedInput
    cleaningVerifications?: CleaningVerificationUpdateManyWithoutVerifiedByNestedInput
    supplyRequests?: CleaningSupplyRequestUpdateManyWithoutRequestedByNestedInput
  }

  export type HousekeepingStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    cleaningVerifications?: CleaningVerificationUncheckedUpdateManyWithoutVerifiedByNestedInput
    supplyRequests?: CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type HousekeepingStaffCreateManyInput = {
    id?: number
    userId: number
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingStaffUpdateManyMutationInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningTaskCreateInput = {
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    area: HousekeepingAreaCreateNestedOneWithoutCleaningTasksInput
    assignedTo?: HousekeepingStaffCreateNestedOneWithoutCleaningTasksInput
    verifications?: CleaningVerificationCreateNestedManyWithoutTaskInput
  }

  export type CleaningTaskUncheckedCreateInput = {
    id?: number
    areaId: number
    assignedToId?: number | null
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifications?: CleaningVerificationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type CleaningTaskUpdateInput = {
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: HousekeepingAreaUpdateOneRequiredWithoutCleaningTasksNestedInput
    assignedTo?: HousekeepingStaffUpdateOneWithoutCleaningTasksNestedInput
    verifications?: CleaningVerificationUpdateManyWithoutTaskNestedInput
  }

  export type CleaningTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifications?: CleaningVerificationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type CleaningTaskCreateManyInput = {
    id?: number
    areaId: number
    assignedToId?: number | null
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningTaskUpdateManyMutationInput = {
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationCreateInput = {
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task: CleaningTaskCreateNestedOneWithoutVerificationsInput
    verifiedBy: HousekeepingStaffCreateNestedOneWithoutCleaningVerificationsInput
  }

  export type CleaningVerificationUncheckedCreateInput = {
    id?: number
    taskId: number
    verifiedById: number
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningVerificationUpdateInput = {
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: CleaningTaskUpdateOneRequiredWithoutVerificationsNestedInput
    verifiedBy?: HousekeepingStaffUpdateOneRequiredWithoutCleaningVerificationsNestedInput
  }

  export type CleaningVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    verifiedById?: IntFieldUpdateOperationsInput | number
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationCreateManyInput = {
    id?: number
    taskId: number
    verifiedById: number
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningVerificationUpdateManyMutationInput = {
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    verifiedById?: IntFieldUpdateOperationsInput | number
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyCreateInput = {
    name: string
    description?: string | null
    unit: string
    currentStock?: number
    reorderLevel?: number
    location?: string | null
    supplier?: string | null
    lastPurchaseDate?: Date | string | null
    lastPurchasePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplyRequests?: CleaningSupplyRequestItemCreateNestedManyWithoutSupplyInput
  }

  export type CleaningSupplyUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    unit: string
    currentStock?: number
    reorderLevel?: number
    location?: string | null
    supplier?: string | null
    lastPurchaseDate?: Date | string | null
    lastPurchasePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplyRequests?: CleaningSupplyRequestItemUncheckedCreateNestedManyWithoutSupplyInput
  }

  export type CleaningSupplyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPurchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPurchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplyRequests?: CleaningSupplyRequestItemUpdateManyWithoutSupplyNestedInput
  }

  export type CleaningSupplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPurchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPurchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplyRequests?: CleaningSupplyRequestItemUncheckedUpdateManyWithoutSupplyNestedInput
  }

  export type CleaningSupplyCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    unit: string
    currentStock?: number
    reorderLevel?: number
    location?: string | null
    supplier?: string | null
    lastPurchaseDate?: Date | string | null
    lastPurchasePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPurchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPurchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPurchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPurchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestCreateInput = {
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy: HousekeepingStaffCreateNestedOneWithoutSupplyRequestsInput
    requestItems?: CleaningSupplyRequestItemCreateNestedManyWithoutRequestInput
  }

  export type CleaningSupplyRequestUncheckedCreateInput = {
    id?: number
    requestedById: number
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestItems?: CleaningSupplyRequestItemUncheckedCreateNestedManyWithoutRequestInput
  }

  export type CleaningSupplyRequestUpdateInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: HousekeepingStaffUpdateOneRequiredWithoutSupplyRequestsNestedInput
    requestItems?: CleaningSupplyRequestItemUpdateManyWithoutRequestNestedInput
  }

  export type CleaningSupplyRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestItems?: CleaningSupplyRequestItemUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CleaningSupplyRequestCreateManyInput = {
    id?: number
    requestedById: number
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestUpdateManyMutationInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemCreateInput = {
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: CleaningSupplyRequestCreateNestedOneWithoutRequestItemsInput
    supply: CleaningSupplyCreateNestedOneWithoutSupplyRequestsInput
  }

  export type CleaningSupplyRequestItemUncheckedCreateInput = {
    id?: number
    requestId: number
    supplyId: number
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestItemUpdateInput = {
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: CleaningSupplyRequestUpdateOneRequiredWithoutRequestItemsNestedInput
    supply?: CleaningSupplyUpdateOneRequiredWithoutSupplyRequestsNestedInput
  }

  export type CleaningSupplyRequestItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    supplyId?: IntFieldUpdateOperationsInput | number
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemCreateManyInput = {
    id?: number
    requestId: number
    supplyId: number
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestItemUpdateManyMutationInput = {
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    supplyId?: IntFieldUpdateOperationsInput | number
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type PasswordResetNullableScalarRelationFilter = {
    is?: PasswordResetWhereInput | null
    isNot?: PasswordResetWhereInput | null
  }

  export type DoctorNullableScalarRelationFilter = {
    is?: DoctorWhereInput | null
    isNot?: DoctorWhereInput | null
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type NurseNullableScalarRelationFilter = {
    is?: NurseWhereInput | null
    isNot?: NurseWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type BiometricDataNullableScalarRelationFilter = {
    is?: BiometricDataWhereInput | null
    isNot?: BiometricDataWhereInput | null
  }

  export type AttendanceLogListRelationFilter = {
    every?: AttendanceLogWhereInput
    some?: AttendanceLogWhereInput
    none?: AttendanceLogWhereInput
  }

  export type DutyRosterListRelationFilter = {
    every?: DutyRosterWhereInput
    some?: DutyRosterWhereInput
    none?: DutyRosterWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type HousekeepingStaffNullableScalarRelationFilter = {
    is?: HousekeepingStaffWhereInput | null
    isNot?: HousekeepingStaffWhereInput | null
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DutyRosterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    profileImage?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    profileImage?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    profileImage?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type LabReportListRelationFilter = {
    every?: LabReportWhereInput
    some?: LabReportWhereInput
    none?: LabReportWhereInput
  }

  export type RadiologyReportListRelationFilter = {
    every?: RadiologyReportWhereInput
    some?: RadiologyReportWhereInput
    none?: RadiologyReportWhereInput
  }

  export type OperationTheaterListRelationFilter = {
    every?: OperationTheaterWhereInput
    some?: OperationTheaterWhereInput
    none?: OperationTheaterWhereInput
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RadiologyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationTheaterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    consultationFee?: SortOrder
    availableDays?: SortOrder
    availableTimeStart?: SortOrder
    availableTimeEnd?: SortOrder
    department?: SortOrder
    bio?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    experience?: SortOrder
    consultationFee?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    consultationFee?: SortOrder
    availableDays?: SortOrder
    availableTimeStart?: SortOrder
    availableTimeEnd?: SortOrder
    department?: SortOrder
    bio?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    consultationFee?: SortOrder
    availableDays?: SortOrder
    availableTimeStart?: SortOrder
    availableTimeEnd?: SortOrder
    department?: SortOrder
    bio?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    experience?: SortOrder
    consultationFee?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TPANullableScalarRelationFilter = {
    is?: TPAWhereInput | null
    isNot?: TPAWhereInput | null
  }

  export type BedAllocationListRelationFilter = {
    every?: BedAllocationWhereInput
    some?: BedAllocationWhereInput
    none?: BedAllocationWhereInput
  }

  export type VitalSignListRelationFilter = {
    every?: VitalSignWhereInput
    some?: VitalSignWhereInput
    none?: VitalSignWhereInput
  }

  export type PatientSubsidyListRelationFilter = {
    every?: PatientSubsidyWhereInput
    some?: PatientSubsidyWhereInput
    none?: PatientSubsidyWhereInput
  }

  export type BedAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitalSignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientSubsidyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patientId?: SortOrder
    bloodGroup?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    allergies?: SortOrder
    chronicDiseases?: SortOrder
    emergencyContact?: SortOrder
    emergencyName?: SortOrder
    emergencyRelation?: SortOrder
    insuranceProvider?: SortOrder
    insuranceId?: SortOrder
    tpaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    tpaId?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patientId?: SortOrder
    bloodGroup?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    allergies?: SortOrder
    chronicDiseases?: SortOrder
    emergencyContact?: SortOrder
    emergencyName?: SortOrder
    emergencyRelation?: SortOrder
    insuranceProvider?: SortOrder
    insuranceId?: SortOrder
    tpaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patientId?: SortOrder
    bloodGroup?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    allergies?: SortOrder
    chronicDiseases?: SortOrder
    emergencyContact?: SortOrder
    emergencyName?: SortOrder
    emergencyRelation?: SortOrder
    insuranceProvider?: SortOrder
    insuranceId?: SortOrder
    tpaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    tpaId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NurseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NurseAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    experience?: SortOrder
  }

  export type NurseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NurseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NurseSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    experience?: SortOrder
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type DoctorScalarRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    followUp?: SortOrder
    followUpDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    followUp?: SortOrder
    followUpDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    followUp?: SortOrder
    followUpDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type PrescriptionMedicineListRelationFilter = {
    every?: PrescriptionMedicineWhereInput
    some?: PrescriptionMedicineWhereInput
    none?: PrescriptionMedicineWhereInput
  }

  export type PrescriptionMedicineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    prescriptionDate?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    prescriptionDate?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    prescriptionDate?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type PrescriptionScalarRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type MedicineScalarRelationFilter = {
    is?: MedicineWhereInput
    isNot?: MedicineWhereInput
  }

  export type PrescriptionMedicineCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionMedicineAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
  }

  export type PrescriptionMedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionMedicineMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionMedicineSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
  }

  export type InventoryLogListRelationFilter = {
    every?: InventoryLogWhereInput
    some?: InventoryLogWhereInput
    none?: InventoryLogWhereInput
  }

  export type InventoryLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
  }

  export type MedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    reorderLevel?: SortOrder
  }

  export type InventoryLogCountOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryLogAvgOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryLogMaxOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryLogMinOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryLogSumOrderByAggregateInput = {
    id?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabReportCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    testDate?: SortOrder
    reportDate?: SortOrder
    testType?: SortOrder
    testResult?: SortOrder
    normalRange?: SortOrder
    notes?: SortOrder
    attachmentUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabReportAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type LabReportMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    testDate?: SortOrder
    reportDate?: SortOrder
    testType?: SortOrder
    testResult?: SortOrder
    normalRange?: SortOrder
    notes?: SortOrder
    attachmentUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabReportMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    testDate?: SortOrder
    reportDate?: SortOrder
    testType?: SortOrder
    testResult?: SortOrder
    normalRange?: SortOrder
    notes?: SortOrder
    attachmentUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabReportSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type RadiologyReportCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    testDate?: SortOrder
    reportDate?: SortOrder
    testType?: SortOrder
    findings?: SortOrder
    impression?: SortOrder
    notes?: SortOrder
    attachmentUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiologyReportAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type RadiologyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    testDate?: SortOrder
    reportDate?: SortOrder
    testType?: SortOrder
    findings?: SortOrder
    impression?: SortOrder
    notes?: SortOrder
    attachmentUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiologyReportMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    testDate?: SortOrder
    reportDate?: SortOrder
    testType?: SortOrder
    findings?: SortOrder
    impression?: SortOrder
    notes?: SortOrder
    attachmentUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiologyReportSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type SubsidyClaimListRelationFilter = {
    every?: SubsidyClaimWhereInput
    some?: SubsidyClaimWhereInput
    none?: SubsidyClaimWhereInput
  }

  export type SubsidyClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type LabReportNullableScalarRelationFilter = {
    is?: LabReportWhereInput | null
    isNot?: LabReportWhereInput | null
  }

  export type RadiologyReportNullableScalarRelationFilter = {
    is?: RadiologyReportWhereInput | null
    isNot?: RadiologyReportWhereInput | null
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrder
    radiologyReportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrder
    radiologyReportId?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrder
    radiologyReportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrder
    radiologyReportId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    labReportId?: SortOrder
    radiologyReportId?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    patientId?: SortOrder
    amount?: SortOrder
  }

  export type WardScalarRelationFilter = {
    is?: WardWhereInput
    isNot?: WardWhereInput
  }

  export type BedCountOrderByAggregateInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    wardId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedAvgOrderByAggregateInput = {
    id?: SortOrder
    wardId?: SortOrder
    price?: SortOrder
  }

  export type BedMaxOrderByAggregateInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    wardId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedMinOrderByAggregateInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    wardId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedSumOrderByAggregateInput = {
    id?: SortOrder
    wardId?: SortOrder
    price?: SortOrder
  }

  export type BedListRelationFilter = {
    every?: BedWhereInput
    some?: BedWhereInput
    none?: BedWhereInput
  }

  export type BedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    wardType?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type WardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    wardType?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    wardType?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type BedScalarRelationFilter = {
    is?: BedWhereInput
    isNot?: BedWhereInput
  }

  export type BedAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrder
    allocatedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedAllocationAvgOrderByAggregateInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrder
  }

  export type BedAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrder
    allocatedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrder
    allocatedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedAllocationSumOrderByAggregateInput = {
    id?: SortOrder
    bedId?: SortOrder
    patientId?: SortOrder
    nurseId?: SortOrder
  }

  export type NurseScalarRelationFilter = {
    is?: NurseWhereInput
    isNot?: NurseWhereInput
  }

  export type VitalSignCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygenSaturation?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VitalSignAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygenSaturation?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type VitalSignMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygenSaturation?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VitalSignMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygenSaturation?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VitalSignSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    temperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygenSaturation?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type SurgeryListRelationFilter = {
    every?: SurgeryWhereInput
    some?: SurgeryWhereInput
    none?: SurgeryWhereInput
  }

  export type OperationTheaterEquipmentListRelationFilter = {
    every?: OperationTheaterEquipmentWhereInput
    some?: OperationTheaterEquipmentWhereInput
    none?: OperationTheaterEquipmentWhereInput
  }

  export type SurgeryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationTheaterEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationTheaterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    doctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationTheaterAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
  }

  export type OperationTheaterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    doctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationTheaterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    doctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationTheaterSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
  }

  export type OperationTheaterScalarRelationFilter = {
    is?: OperationTheaterWhereInput
    isNot?: OperationTheaterWhereInput
  }

  export type SurgeryCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
    surgeryDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    surgeryType?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurgeryAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
  }

  export type SurgeryMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
    surgeryDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    surgeryType?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurgeryMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
    surgeryDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    surgeryType?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurgerySumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    operationTheaterId?: SortOrder
  }

  export type OperationTheaterEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    purchaseDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationTheaterEquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
  }

  export type OperationTheaterEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    purchaseDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationTheaterEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    purchaseDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationTheaterEquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    operationTheaterId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MedicalGasCylinderCountOrderByAggregateInput = {
    id?: SortOrder
    cylinderNumber?: SortOrder
    gasType?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
    location?: SortOrder
    status?: SortOrder
    lastRefillDate?: SortOrder
    nextRefillDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalGasCylinderAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
  }

  export type MedicalGasCylinderMaxOrderByAggregateInput = {
    id?: SortOrder
    cylinderNumber?: SortOrder
    gasType?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
    location?: SortOrder
    status?: SortOrder
    lastRefillDate?: SortOrder
    nextRefillDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalGasCylinderMinOrderByAggregateInput = {
    id?: SortOrder
    cylinderNumber?: SortOrder
    gasType?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
    location?: SortOrder
    status?: SortOrder
    lastRefillDate?: SortOrder
    nextRefillDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalGasCylinderSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    currentLevel?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EquipmentMaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentType?: SortOrder
    equipmentId?: SortOrder
    maintenanceDate?: SortOrder
    maintenanceType?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMaintenanceAvgOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cost?: SortOrder
  }

  export type EquipmentMaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentType?: SortOrder
    equipmentId?: SortOrder
    maintenanceDate?: SortOrder
    maintenanceType?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentType?: SortOrder
    equipmentId?: SortOrder
    maintenanceDate?: SortOrder
    maintenanceType?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMaintenanceSumOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cost?: SortOrder
  }

  export type AmbulanceServiceListRelationFilter = {
    every?: AmbulanceServiceWhereInput
    some?: AmbulanceServiceWhereInput
    none?: AmbulanceServiceWhereInput
  }

  export type AmbulanceServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmbulanceCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleNumber?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    driverName?: SortOrder
    driverContact?: SortOrder
    status?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmbulanceAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type AmbulanceMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleNumber?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    driverName?: SortOrder
    driverContact?: SortOrder
    status?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmbulanceMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleNumber?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    driverName?: SortOrder
    driverContact?: SortOrder
    status?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmbulanceSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type AmbulanceScalarRelationFilter = {
    is?: AmbulanceWhereInput
    isNot?: AmbulanceWhereInput
  }

  export type AmbulanceServiceCountOrderByAggregateInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    patientName?: SortOrder
    patientContact?: SortOrder
    pickupLocation?: SortOrder
    dropLocation?: SortOrder
    serviceDate?: SortOrder
    status?: SortOrder
    fare?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmbulanceServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    fare?: SortOrder
  }

  export type AmbulanceServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    patientName?: SortOrder
    patientContact?: SortOrder
    pickupLocation?: SortOrder
    dropLocation?: SortOrder
    serviceDate?: SortOrder
    status?: SortOrder
    fare?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmbulanceServiceMinOrderByAggregateInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    patientName?: SortOrder
    patientContact?: SortOrder
    pickupLocation?: SortOrder
    dropLocation?: SortOrder
    serviceDate?: SortOrder
    status?: SortOrder
    fare?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmbulanceServiceSumOrderByAggregateInput = {
    id?: SortOrder
    ambulanceId?: SortOrder
    fare?: SortOrder
  }

  export type BiometricDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biometricId?: SortOrder
    fingerprint?: SortOrder
    faceData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiometricDataAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BiometricDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biometricId?: SortOrder
    fingerprint?: SortOrder
    faceData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiometricDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biometricId?: SortOrder
    fingerprint?: SortOrder
    faceData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiometricDataSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AttendanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    verificationMode?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AttendanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    verificationMode?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    verificationMode?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DutyRosterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    department?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyRosterAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DutyRosterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    department?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyRosterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    department?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyRosterSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TPACountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    contactNumber?: SortOrder
    email?: SortOrder
    address?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TPAAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TPAMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    contactNumber?: SortOrder
    email?: SortOrder
    address?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TPAMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    contactNumber?: SortOrder
    email?: SortOrder
    address?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TPASumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type SalaryPaymentListRelationFilter = {
    every?: SalaryPaymentWhereInput
    some?: SalaryPaymentWhereInput
    none?: SalaryPaymentWhereInput
  }

  export type EmployeeDocumentListRelationFilter = {
    every?: EmployeeDocumentWhereInput
    some?: EmployeeDocumentWhereInput
    none?: EmployeeDocumentWhereInput
  }

  export type PerformanceReviewListRelationFilter = {
    every?: PerformanceReviewWhereInput
    some?: PerformanceReviewWhereInput
    none?: PerformanceReviewWhereInput
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    joiningDate?: SortOrder
    contractType?: SortOrder
    contractEndDate?: SortOrder
    salary?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    panNumber?: SortOrder
    emergencyContact?: SortOrder
    emergencyName?: SortOrder
    emergencyRelation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    joiningDate?: SortOrder
    contractType?: SortOrder
    contractEndDate?: SortOrder
    salary?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    panNumber?: SortOrder
    emergencyContact?: SortOrder
    emergencyName?: SortOrder
    emergencyRelation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    joiningDate?: SortOrder
    contractType?: SortOrder
    contractEndDate?: SortOrder
    salary?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    panNumber?: SortOrder
    emergencyContact?: SortOrder
    emergencyName?: SortOrder
    emergencyRelation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    totalDays?: SortOrder
    approvedBy?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    totalDays?: SortOrder
    approvedBy?: SortOrder
  }

  export type SalaryPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    salaryMonth?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
  }

  export type SalaryPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    salaryMonth?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    salaryMonth?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    taxDeducted?: SortOrder
    netSalary?: SortOrder
  }

  export type EmployeeDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    verifiedBy?: SortOrder
  }

  export type EmployeeDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    verifiedBy?: SortOrder
  }

  export type PerformanceReviewCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
    strengths?: SortOrder
    areasOfImprovement?: SortOrder
    goals?: SortOrder
    comments?: SortOrder
    employeeComments?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
  }

  export type PerformanceReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
    strengths?: SortOrder
    areasOfImprovement?: SortOrder
    goals?: SortOrder
    comments?: SortOrder
    employeeComments?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceReviewMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
    strengths?: SortOrder
    areasOfImprovement?: SortOrder
    goals?: SortOrder
    comments?: SortOrder
    employeeComments?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceReviewSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewedBy?: SortOrder
    rating?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SubsidySchemeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    issuingAuthority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    eligibilityCriteria?: SortOrder
    subsidyType?: SortOrder
    percentageValue?: SortOrder
    fixedAmount?: SortOrder
    maxCoverageAmount?: SortOrder
    maxCoveragePerTreatment?: SortOrder
    applicableServices?: SortOrder
    documentationRequired?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidySchemeAvgOrderByAggregateInput = {
    id?: SortOrder
    percentageValue?: SortOrder
    fixedAmount?: SortOrder
    maxCoverageAmount?: SortOrder
    maxCoveragePerTreatment?: SortOrder
  }

  export type SubsidySchemeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    issuingAuthority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    eligibilityCriteria?: SortOrder
    subsidyType?: SortOrder
    percentageValue?: SortOrder
    fixedAmount?: SortOrder
    maxCoverageAmount?: SortOrder
    maxCoveragePerTreatment?: SortOrder
    applicableServices?: SortOrder
    documentationRequired?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidySchemeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    issuingAuthority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    eligibilityCriteria?: SortOrder
    subsidyType?: SortOrder
    percentageValue?: SortOrder
    fixedAmount?: SortOrder
    maxCoverageAmount?: SortOrder
    maxCoveragePerTreatment?: SortOrder
    applicableServices?: SortOrder
    documentationRequired?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidySchemeSumOrderByAggregateInput = {
    id?: SortOrder
    percentageValue?: SortOrder
    fixedAmount?: SortOrder
    maxCoverageAmount?: SortOrder
    maxCoveragePerTreatment?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type SubsidySchemeScalarRelationFilter = {
    is?: SubsidySchemeWhereInput
    isNot?: SubsidySchemeWhereInput
  }

  export type PatientSubsidyCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    enrollmentDate?: SortOrder
    enrollmentNumber?: SortOrder
    cardNumber?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSubsidyAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    remainingBalance?: SortOrder
    verifiedBy?: SortOrder
  }

  export type PatientSubsidyMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    enrollmentDate?: SortOrder
    enrollmentNumber?: SortOrder
    cardNumber?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSubsidyMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    enrollmentDate?: SortOrder
    enrollmentNumber?: SortOrder
    cardNumber?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSubsidySumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    schemeId?: SortOrder
    remainingBalance?: SortOrder
    verifiedBy?: SortOrder
  }

  export type PatientSubsidyScalarRelationFilter = {
    is?: PatientSubsidyWhereInput
    isNot?: PatientSubsidyWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type SubsidyClaimCountOrderByAggregateInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrder
    claimDate?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    rejectionReason?: SortOrder
    claimStatus?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    reimbursementDate?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidyClaimAvgOrderByAggregateInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    processedBy?: SortOrder
  }

  export type SubsidyClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrder
    claimDate?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    rejectionReason?: SortOrder
    claimStatus?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    reimbursementDate?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidyClaimMinOrderByAggregateInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrder
    claimDate?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    rejectionReason?: SortOrder
    claimStatus?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    reimbursementDate?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubsidyClaimSumOrderByAggregateInput = {
    id?: SortOrder
    patientSubsidyId?: SortOrder
    schemeId?: SortOrder
    invoiceId?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    processedBy?: SortOrder
  }

  export type CleaningTaskListRelationFilter = {
    every?: CleaningTaskWhereInput
    some?: CleaningTaskWhereInput
    none?: CleaningTaskWhereInput
  }

  export type CleaningTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HousekeepingAreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    floor?: SortOrder
    buildingSection?: SortOrder
    priority?: SortOrder
    cleaningFrequency?: SortOrder
    specialInstructions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingAreaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HousekeepingAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    floor?: SortOrder
    buildingSection?: SortOrder
    priority?: SortOrder
    cleaningFrequency?: SortOrder
    specialInstructions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingAreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    floor?: SortOrder
    buildingSection?: SortOrder
    priority?: SortOrder
    cleaningFrequency?: SortOrder
    specialInstructions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingAreaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CleaningVerificationListRelationFilter = {
    every?: CleaningVerificationWhereInput
    some?: CleaningVerificationWhereInput
    none?: CleaningVerificationWhereInput
  }

  export type CleaningSupplyRequestListRelationFilter = {
    every?: CleaningSupplyRequestWhereInput
    some?: CleaningSupplyRequestWhereInput
    none?: CleaningSupplyRequestWhereInput
  }

  export type CleaningVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningSupplyRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HousekeepingStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    supervisor?: SortOrder
    specializedAreas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HousekeepingStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    supervisor?: SortOrder
    specializedAreas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    supervisor?: SortOrder
    specializedAreas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingStaffSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HousekeepingAreaScalarRelationFilter = {
    is?: HousekeepingAreaWhereInput
    isNot?: HousekeepingAreaWhereInput
  }

  export type CleaningTaskCountOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type CleaningTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningTaskMinOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningTaskSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    assignedToId?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type CleaningTaskScalarRelationFilter = {
    is?: CleaningTaskWhereInput
    isNot?: CleaningTaskWhereInput
  }

  export type HousekeepingStaffScalarRelationFilter = {
    is?: HousekeepingStaffWhereInput
    isNot?: HousekeepingStaffWhereInput
  }

  export type CleaningVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    verificationDate?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
    comments?: SortOrder
    photosUrl?: SortOrder
    status?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
  }

  export type CleaningVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    verificationDate?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
    comments?: SortOrder
    photosUrl?: SortOrder
    status?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    verificationDate?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
    comments?: SortOrder
    photosUrl?: SortOrder
    status?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    verifiedById?: SortOrder
    rating?: SortOrder
    cleanliness?: SortOrder
  }

  export type CleaningSupplyRequestItemListRelationFilter = {
    every?: CleaningSupplyRequestItemWhereInput
    some?: CleaningSupplyRequestItemWhereInput
    none?: CleaningSupplyRequestItemWhereInput
  }

  export type CleaningSupplyRequestItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningSupplyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    location?: SortOrder
    supplier?: SortOrder
    lastPurchaseDate?: SortOrder
    lastPurchasePrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyAvgOrderByAggregateInput = {
    id?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    lastPurchasePrice?: SortOrder
  }

  export type CleaningSupplyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    location?: SortOrder
    supplier?: SortOrder
    lastPurchaseDate?: SortOrder
    lastPurchasePrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    location?: SortOrder
    supplier?: SortOrder
    lastPurchaseDate?: SortOrder
    lastPurchasePrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplySumOrderByAggregateInput = {
    id?: SortOrder
    currentStock?: SortOrder
    reorderLevel?: SortOrder
    lastPurchasePrice?: SortOrder
  }

  export type CleaningSupplyRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requestedById?: SortOrder
    requestDate?: SortOrder
    requiredBy?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    fulfilledAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
  }

  export type CleaningSupplyRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requestedById?: SortOrder
    requestDate?: SortOrder
    requiredBy?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    fulfilledAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requestedById?: SortOrder
    requestDate?: SortOrder
    requiredBy?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    fulfilledAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyRequestSumOrderByAggregateInput = {
    id?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
  }

  export type CleaningSupplyRequestScalarRelationFilter = {
    is?: CleaningSupplyRequestWhereInput
    isNot?: CleaningSupplyRequestWhereInput
  }

  export type CleaningSupplyScalarRelationFilter = {
    is?: CleaningSupplyWhereInput
    isNot?: CleaningSupplyWhereInput
  }

  export type CleaningSupplyRequestItemCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrder
    quantityFulfilled?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyRequestItemAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrder
    quantityFulfilled?: SortOrder
  }

  export type CleaningSupplyRequestItemMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrder
    quantityFulfilled?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyRequestItemMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrder
    quantityFulfilled?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningSupplyRequestItemSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    supplyId?: SortOrder
    quantityRequested?: SortOrder
    quantityApproved?: SortOrder
    quantityFulfilled?: SortOrder
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type PasswordResetCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    connect?: PasswordResetWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type NurseCreateNestedOneWithoutUserInput = {
    create?: XOR<NurseCreateWithoutUserInput, NurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: NurseCreateOrConnectWithoutUserInput
    connect?: NurseWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BiometricDataCreateNestedOneWithoutUserInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput
    connect?: BiometricDataWhereUniqueInput
  }

  export type AttendanceLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceLogCreateWithoutUserInput, AttendanceLogUncheckedCreateWithoutUserInput> | AttendanceLogCreateWithoutUserInput[] | AttendanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutUserInput | AttendanceLogCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceLogCreateManyUserInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type DutyRosterCreateNestedManyWithoutUserInput = {
    create?: XOR<DutyRosterCreateWithoutUserInput, DutyRosterUncheckedCreateWithoutUserInput> | DutyRosterCreateWithoutUserInput[] | DutyRosterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DutyRosterCreateOrConnectWithoutUserInput | DutyRosterCreateOrConnectWithoutUserInput[]
    createMany?: DutyRosterCreateManyUserInputEnvelope
    connect?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type HousekeepingStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<HousekeepingStaffCreateWithoutUserInput, HousekeepingStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutUserInput
    connect?: HousekeepingStaffWhereUniqueInput
  }

  export type PasswordResetUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    connect?: PasswordResetWhereUniqueInput
  }

  export type DoctorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type NurseUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NurseCreateWithoutUserInput, NurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: NurseCreateOrConnectWithoutUserInput
    connect?: NurseWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BiometricDataUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput
    connect?: BiometricDataWhereUniqueInput
  }

  export type AttendanceLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceLogCreateWithoutUserInput, AttendanceLogUncheckedCreateWithoutUserInput> | AttendanceLogCreateWithoutUserInput[] | AttendanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutUserInput | AttendanceLogCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceLogCreateManyUserInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type DutyRosterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DutyRosterCreateWithoutUserInput, DutyRosterUncheckedCreateWithoutUserInput> | DutyRosterCreateWithoutUserInput[] | DutyRosterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DutyRosterCreateOrConnectWithoutUserInput | DutyRosterCreateOrConnectWithoutUserInput[]
    createMany?: DutyRosterCreateManyUserInputEnvelope
    connect?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HousekeepingStaffCreateWithoutUserInput, HousekeepingStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutUserInput
    connect?: HousekeepingStaffWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type PasswordResetUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    upsert?: PasswordResetUpsertWithoutUserInput
    disconnect?: PasswordResetWhereInput | boolean
    delete?: PasswordResetWhereInput | boolean
    connect?: PasswordResetWhereUniqueInput
    update?: XOR<XOR<PasswordResetUpdateToOneWithWhereWithoutUserInput, PasswordResetUpdateWithoutUserInput>, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUserInput, PatientUpdateWithoutUserInput>, PatientUncheckedUpdateWithoutUserInput>
  }

  export type NurseUpdateOneWithoutUserNestedInput = {
    create?: XOR<NurseCreateWithoutUserInput, NurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: NurseCreateOrConnectWithoutUserInput
    upsert?: NurseUpsertWithoutUserInput
    disconnect?: NurseWhereInput | boolean
    delete?: NurseWhereInput | boolean
    connect?: NurseWhereUniqueInput
    update?: XOR<XOR<NurseUpdateToOneWithWhereWithoutUserInput, NurseUpdateWithoutUserInput>, NurseUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BiometricDataUpdateOneWithoutUserNestedInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput
    upsert?: BiometricDataUpsertWithoutUserInput
    disconnect?: BiometricDataWhereInput | boolean
    delete?: BiometricDataWhereInput | boolean
    connect?: BiometricDataWhereUniqueInput
    update?: XOR<XOR<BiometricDataUpdateToOneWithWhereWithoutUserInput, BiometricDataUpdateWithoutUserInput>, BiometricDataUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutUserInput, AttendanceLogUncheckedCreateWithoutUserInput> | AttendanceLogCreateWithoutUserInput[] | AttendanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutUserInput | AttendanceLogCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutUserInput | AttendanceLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceLogCreateManyUserInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutUserInput | AttendanceLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutUserInput | AttendanceLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type DutyRosterUpdateManyWithoutUserNestedInput = {
    create?: XOR<DutyRosterCreateWithoutUserInput, DutyRosterUncheckedCreateWithoutUserInput> | DutyRosterCreateWithoutUserInput[] | DutyRosterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DutyRosterCreateOrConnectWithoutUserInput | DutyRosterCreateOrConnectWithoutUserInput[]
    upsert?: DutyRosterUpsertWithWhereUniqueWithoutUserInput | DutyRosterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DutyRosterCreateManyUserInputEnvelope
    set?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    disconnect?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    delete?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    connect?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    update?: DutyRosterUpdateWithWhereUniqueWithoutUserInput | DutyRosterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DutyRosterUpdateManyWithWhereWithoutUserInput | DutyRosterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DutyRosterScalarWhereInput | DutyRosterScalarWhereInput[]
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type HousekeepingStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<HousekeepingStaffCreateWithoutUserInput, HousekeepingStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutUserInput
    upsert?: HousekeepingStaffUpsertWithoutUserInput
    disconnect?: HousekeepingStaffWhereInput | boolean
    delete?: HousekeepingStaffWhereInput | boolean
    connect?: HousekeepingStaffWhereUniqueInput
    update?: XOR<XOR<HousekeepingStaffUpdateToOneWithWhereWithoutUserInput, HousekeepingStaffUpdateWithoutUserInput>, HousekeepingStaffUncheckedUpdateWithoutUserInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PasswordResetUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    upsert?: PasswordResetUpsertWithoutUserInput
    disconnect?: PasswordResetWhereInput | boolean
    delete?: PasswordResetWhereInput | boolean
    connect?: PasswordResetWhereUniqueInput
    update?: XOR<XOR<PasswordResetUpdateToOneWithWhereWithoutUserInput, PasswordResetUpdateWithoutUserInput>, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type PatientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUserInput, PatientUpdateWithoutUserInput>, PatientUncheckedUpdateWithoutUserInput>
  }

  export type NurseUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NurseCreateWithoutUserInput, NurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: NurseCreateOrConnectWithoutUserInput
    upsert?: NurseUpsertWithoutUserInput
    disconnect?: NurseWhereInput | boolean
    delete?: NurseWhereInput | boolean
    connect?: NurseWhereUniqueInput
    update?: XOR<XOR<NurseUpdateToOneWithWhereWithoutUserInput, NurseUpdateWithoutUserInput>, NurseUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BiometricDataUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput
    upsert?: BiometricDataUpsertWithoutUserInput
    disconnect?: BiometricDataWhereInput | boolean
    delete?: BiometricDataWhereInput | boolean
    connect?: BiometricDataWhereUniqueInput
    update?: XOR<XOR<BiometricDataUpdateToOneWithWhereWithoutUserInput, BiometricDataUpdateWithoutUserInput>, BiometricDataUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutUserInput, AttendanceLogUncheckedCreateWithoutUserInput> | AttendanceLogCreateWithoutUserInput[] | AttendanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutUserInput | AttendanceLogCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutUserInput | AttendanceLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceLogCreateManyUserInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutUserInput | AttendanceLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutUserInput | AttendanceLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type DutyRosterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DutyRosterCreateWithoutUserInput, DutyRosterUncheckedCreateWithoutUserInput> | DutyRosterCreateWithoutUserInput[] | DutyRosterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DutyRosterCreateOrConnectWithoutUserInput | DutyRosterCreateOrConnectWithoutUserInput[]
    upsert?: DutyRosterUpsertWithWhereUniqueWithoutUserInput | DutyRosterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DutyRosterCreateManyUserInputEnvelope
    set?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    disconnect?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    delete?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    connect?: DutyRosterWhereUniqueInput | DutyRosterWhereUniqueInput[]
    update?: DutyRosterUpdateWithWhereUniqueWithoutUserInput | DutyRosterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DutyRosterUpdateManyWithWhereWithoutUserInput | DutyRosterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DutyRosterScalarWhereInput | DutyRosterScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HousekeepingStaffCreateWithoutUserInput, HousekeepingStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutUserInput
    upsert?: HousekeepingStaffUpsertWithoutUserInput
    disconnect?: HousekeepingStaffWhereInput | boolean
    delete?: HousekeepingStaffWhereInput | boolean
    connect?: HousekeepingStaffWhereUniqueInput
    update?: XOR<XOR<HousekeepingStaffUpdateToOneWithWhereWithoutUserInput, HousekeepingStaffUpdateWithoutUserInput>, HousekeepingStaffUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetInput = {
    create?: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetInput
    upsert?: UserUpsertWithoutPasswordResetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetInput, UserUpdateWithoutPasswordResetInput>, UserUncheckedUpdateWithoutPasswordResetInput>
  }

  export type UserCreateNestedOneWithoutDoctorInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabReportCreateNestedManyWithoutDoctorInput = {
    create?: XOR<LabReportCreateWithoutDoctorInput, LabReportUncheckedCreateWithoutDoctorInput> | LabReportCreateWithoutDoctorInput[] | LabReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutDoctorInput | LabReportCreateOrConnectWithoutDoctorInput[]
    createMany?: LabReportCreateManyDoctorInputEnvelope
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
  }

  export type RadiologyReportCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RadiologyReportCreateWithoutDoctorInput, RadiologyReportUncheckedCreateWithoutDoctorInput> | RadiologyReportCreateWithoutDoctorInput[] | RadiologyReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutDoctorInput | RadiologyReportCreateOrConnectWithoutDoctorInput[]
    createMany?: RadiologyReportCreateManyDoctorInputEnvelope
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
  }

  export type OperationTheaterCreateNestedManyWithoutDoctorInput = {
    create?: XOR<OperationTheaterCreateWithoutDoctorInput, OperationTheaterUncheckedCreateWithoutDoctorInput> | OperationTheaterCreateWithoutDoctorInput[] | OperationTheaterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutDoctorInput | OperationTheaterCreateOrConnectWithoutDoctorInput[]
    createMany?: OperationTheaterCreateManyDoctorInputEnvelope
    connect?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabReportUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<LabReportCreateWithoutDoctorInput, LabReportUncheckedCreateWithoutDoctorInput> | LabReportCreateWithoutDoctorInput[] | LabReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutDoctorInput | LabReportCreateOrConnectWithoutDoctorInput[]
    createMany?: LabReportCreateManyDoctorInputEnvelope
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
  }

  export type RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RadiologyReportCreateWithoutDoctorInput, RadiologyReportUncheckedCreateWithoutDoctorInput> | RadiologyReportCreateWithoutDoctorInput[] | RadiologyReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutDoctorInput | RadiologyReportCreateOrConnectWithoutDoctorInput[]
    createMany?: RadiologyReportCreateManyDoctorInputEnvelope
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
  }

  export type OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<OperationTheaterCreateWithoutDoctorInput, OperationTheaterUncheckedCreateWithoutDoctorInput> | OperationTheaterCreateWithoutDoctorInput[] | OperationTheaterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutDoctorInput | OperationTheaterCreateOrConnectWithoutDoctorInput[]
    createMany?: OperationTheaterCreateManyDoctorInputEnvelope
    connect?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutDoctorNestedInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput
    upsert?: UserUpsertWithoutDoctorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorInput, UserUpdateWithoutDoctorInput>, UserUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabReportUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<LabReportCreateWithoutDoctorInput, LabReportUncheckedCreateWithoutDoctorInput> | LabReportCreateWithoutDoctorInput[] | LabReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutDoctorInput | LabReportCreateOrConnectWithoutDoctorInput[]
    upsert?: LabReportUpsertWithWhereUniqueWithoutDoctorInput | LabReportUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: LabReportCreateManyDoctorInputEnvelope
    set?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    disconnect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    delete?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    update?: LabReportUpdateWithWhereUniqueWithoutDoctorInput | LabReportUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: LabReportUpdateManyWithWhereWithoutDoctorInput | LabReportUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
  }

  export type RadiologyReportUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutDoctorInput, RadiologyReportUncheckedCreateWithoutDoctorInput> | RadiologyReportCreateWithoutDoctorInput[] | RadiologyReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutDoctorInput | RadiologyReportCreateOrConnectWithoutDoctorInput[]
    upsert?: RadiologyReportUpsertWithWhereUniqueWithoutDoctorInput | RadiologyReportUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RadiologyReportCreateManyDoctorInputEnvelope
    set?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    disconnect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    delete?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    update?: RadiologyReportUpdateWithWhereUniqueWithoutDoctorInput | RadiologyReportUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RadiologyReportUpdateManyWithWhereWithoutDoctorInput | RadiologyReportUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
  }

  export type OperationTheaterUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<OperationTheaterCreateWithoutDoctorInput, OperationTheaterUncheckedCreateWithoutDoctorInput> | OperationTheaterCreateWithoutDoctorInput[] | OperationTheaterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutDoctorInput | OperationTheaterCreateOrConnectWithoutDoctorInput[]
    upsert?: OperationTheaterUpsertWithWhereUniqueWithoutDoctorInput | OperationTheaterUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: OperationTheaterCreateManyDoctorInputEnvelope
    set?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    disconnect?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    delete?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    connect?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    update?: OperationTheaterUpdateWithWhereUniqueWithoutDoctorInput | OperationTheaterUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: OperationTheaterUpdateManyWithWhereWithoutDoctorInput | OperationTheaterUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: OperationTheaterScalarWhereInput | OperationTheaterScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabReportUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<LabReportCreateWithoutDoctorInput, LabReportUncheckedCreateWithoutDoctorInput> | LabReportCreateWithoutDoctorInput[] | LabReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutDoctorInput | LabReportCreateOrConnectWithoutDoctorInput[]
    upsert?: LabReportUpsertWithWhereUniqueWithoutDoctorInput | LabReportUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: LabReportCreateManyDoctorInputEnvelope
    set?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    disconnect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    delete?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    update?: LabReportUpdateWithWhereUniqueWithoutDoctorInput | LabReportUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: LabReportUpdateManyWithWhereWithoutDoctorInput | LabReportUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
  }

  export type RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutDoctorInput, RadiologyReportUncheckedCreateWithoutDoctorInput> | RadiologyReportCreateWithoutDoctorInput[] | RadiologyReportUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutDoctorInput | RadiologyReportCreateOrConnectWithoutDoctorInput[]
    upsert?: RadiologyReportUpsertWithWhereUniqueWithoutDoctorInput | RadiologyReportUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RadiologyReportCreateManyDoctorInputEnvelope
    set?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    disconnect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    delete?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    update?: RadiologyReportUpdateWithWhereUniqueWithoutDoctorInput | RadiologyReportUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RadiologyReportUpdateManyWithWhereWithoutDoctorInput | RadiologyReportUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
  }

  export type OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<OperationTheaterCreateWithoutDoctorInput, OperationTheaterUncheckedCreateWithoutDoctorInput> | OperationTheaterCreateWithoutDoctorInput[] | OperationTheaterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutDoctorInput | OperationTheaterCreateOrConnectWithoutDoctorInput[]
    upsert?: OperationTheaterUpsertWithWhereUniqueWithoutDoctorInput | OperationTheaterUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: OperationTheaterCreateManyDoctorInputEnvelope
    set?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    disconnect?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    delete?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    connect?: OperationTheaterWhereUniqueInput | OperationTheaterWhereUniqueInput[]
    update?: OperationTheaterUpdateWithWhereUniqueWithoutDoctorInput | OperationTheaterUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: OperationTheaterUpdateManyWithWhereWithoutDoctorInput | OperationTheaterUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: OperationTheaterScalarWhereInput | OperationTheaterScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPatientInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    connect?: UserWhereUniqueInput
  }

  export type TPACreateNestedOneWithoutPatientsInput = {
    create?: XOR<TPACreateWithoutPatientsInput, TPAUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: TPACreateOrConnectWithoutPatientsInput
    connect?: TPAWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabReportCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabReportCreateWithoutPatientInput, LabReportUncheckedCreateWithoutPatientInput> | LabReportCreateWithoutPatientInput[] | LabReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutPatientInput | LabReportCreateOrConnectWithoutPatientInput[]
    createMany?: LabReportCreateManyPatientInputEnvelope
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
  }

  export type RadiologyReportCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadiologyReportCreateWithoutPatientInput, RadiologyReportUncheckedCreateWithoutPatientInput> | RadiologyReportCreateWithoutPatientInput[] | RadiologyReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutPatientInput | RadiologyReportCreateOrConnectWithoutPatientInput[]
    createMany?: RadiologyReportCreateManyPatientInputEnvelope
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientDetailsInput = {
    create?: XOR<InvoiceCreateWithoutPatientDetailsInput, InvoiceUncheckedCreateWithoutPatientDetailsInput> | InvoiceCreateWithoutPatientDetailsInput[] | InvoiceUncheckedCreateWithoutPatientDetailsInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientDetailsInput | InvoiceCreateOrConnectWithoutPatientDetailsInput[]
    createMany?: InvoiceCreateManyPatientDetailsInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type BedAllocationCreateNestedManyWithoutPatientInput = {
    create?: XOR<BedAllocationCreateWithoutPatientInput, BedAllocationUncheckedCreateWithoutPatientInput> | BedAllocationCreateWithoutPatientInput[] | BedAllocationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutPatientInput | BedAllocationCreateOrConnectWithoutPatientInput[]
    createMany?: BedAllocationCreateManyPatientInputEnvelope
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
  }

  export type VitalSignCreateNestedManyWithoutPatientInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type PatientSubsidyCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientSubsidyCreateWithoutPatientInput, PatientSubsidyUncheckedCreateWithoutPatientInput> | PatientSubsidyCreateWithoutPatientInput[] | PatientSubsidyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutPatientInput | PatientSubsidyCreateOrConnectWithoutPatientInput[]
    createMany?: PatientSubsidyCreateManyPatientInputEnvelope
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabReportUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabReportCreateWithoutPatientInput, LabReportUncheckedCreateWithoutPatientInput> | LabReportCreateWithoutPatientInput[] | LabReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutPatientInput | LabReportCreateOrConnectWithoutPatientInput[]
    createMany?: LabReportCreateManyPatientInputEnvelope
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
  }

  export type RadiologyReportUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadiologyReportCreateWithoutPatientInput, RadiologyReportUncheckedCreateWithoutPatientInput> | RadiologyReportCreateWithoutPatientInput[] | RadiologyReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutPatientInput | RadiologyReportCreateOrConnectWithoutPatientInput[]
    createMany?: RadiologyReportCreateManyPatientInputEnvelope
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput = {
    create?: XOR<InvoiceCreateWithoutPatientDetailsInput, InvoiceUncheckedCreateWithoutPatientDetailsInput> | InvoiceCreateWithoutPatientDetailsInput[] | InvoiceUncheckedCreateWithoutPatientDetailsInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientDetailsInput | InvoiceCreateOrConnectWithoutPatientDetailsInput[]
    createMany?: InvoiceCreateManyPatientDetailsInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type BedAllocationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<BedAllocationCreateWithoutPatientInput, BedAllocationUncheckedCreateWithoutPatientInput> | BedAllocationCreateWithoutPatientInput[] | BedAllocationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutPatientInput | BedAllocationCreateOrConnectWithoutPatientInput[]
    createMany?: BedAllocationCreateManyPatientInputEnvelope
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
  }

  export type VitalSignUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientSubsidyCreateWithoutPatientInput, PatientSubsidyUncheckedCreateWithoutPatientInput> | PatientSubsidyCreateWithoutPatientInput[] | PatientSubsidyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutPatientInput | PatientSubsidyCreateOrConnectWithoutPatientInput[]
    createMany?: PatientSubsidyCreateManyPatientInputEnvelope
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPatientNestedInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    upsert?: UserUpsertWithoutPatientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientInput, UserUpdateWithoutPatientInput>, UserUncheckedUpdateWithoutPatientInput>
  }

  export type TPAUpdateOneWithoutPatientsNestedInput = {
    create?: XOR<TPACreateWithoutPatientsInput, TPAUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: TPACreateOrConnectWithoutPatientsInput
    upsert?: TPAUpsertWithoutPatientsInput
    disconnect?: TPAWhereInput | boolean
    delete?: TPAWhereInput | boolean
    connect?: TPAWhereUniqueInput
    update?: XOR<XOR<TPAUpdateToOneWithWhereWithoutPatientsInput, TPAUpdateWithoutPatientsInput>, TPAUncheckedUpdateWithoutPatientsInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabReportUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabReportCreateWithoutPatientInput, LabReportUncheckedCreateWithoutPatientInput> | LabReportCreateWithoutPatientInput[] | LabReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutPatientInput | LabReportCreateOrConnectWithoutPatientInput[]
    upsert?: LabReportUpsertWithWhereUniqueWithoutPatientInput | LabReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabReportCreateManyPatientInputEnvelope
    set?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    disconnect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    delete?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    update?: LabReportUpdateWithWhereUniqueWithoutPatientInput | LabReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabReportUpdateManyWithWhereWithoutPatientInput | LabReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
  }

  export type RadiologyReportUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutPatientInput, RadiologyReportUncheckedCreateWithoutPatientInput> | RadiologyReportCreateWithoutPatientInput[] | RadiologyReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutPatientInput | RadiologyReportCreateOrConnectWithoutPatientInput[]
    upsert?: RadiologyReportUpsertWithWhereUniqueWithoutPatientInput | RadiologyReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadiologyReportCreateManyPatientInputEnvelope
    set?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    disconnect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    delete?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    update?: RadiologyReportUpdateWithWhereUniqueWithoutPatientInput | RadiologyReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadiologyReportUpdateManyWithWhereWithoutPatientInput | RadiologyReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientDetailsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientDetailsInput, InvoiceUncheckedCreateWithoutPatientDetailsInput> | InvoiceCreateWithoutPatientDetailsInput[] | InvoiceUncheckedCreateWithoutPatientDetailsInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientDetailsInput | InvoiceCreateOrConnectWithoutPatientDetailsInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientDetailsInput | InvoiceUpsertWithWhereUniqueWithoutPatientDetailsInput[]
    createMany?: InvoiceCreateManyPatientDetailsInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientDetailsInput | InvoiceUpdateWithWhereUniqueWithoutPatientDetailsInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientDetailsInput | InvoiceUpdateManyWithWhereWithoutPatientDetailsInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type BedAllocationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BedAllocationCreateWithoutPatientInput, BedAllocationUncheckedCreateWithoutPatientInput> | BedAllocationCreateWithoutPatientInput[] | BedAllocationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutPatientInput | BedAllocationCreateOrConnectWithoutPatientInput[]
    upsert?: BedAllocationUpsertWithWhereUniqueWithoutPatientInput | BedAllocationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BedAllocationCreateManyPatientInputEnvelope
    set?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    disconnect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    delete?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    update?: BedAllocationUpdateWithWhereUniqueWithoutPatientInput | BedAllocationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BedAllocationUpdateManyWithWhereWithoutPatientInput | BedAllocationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
  }

  export type VitalSignUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutPatientInput | VitalSignUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutPatientInput | VitalSignUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutPatientInput | VitalSignUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type PatientSubsidyUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientSubsidyCreateWithoutPatientInput, PatientSubsidyUncheckedCreateWithoutPatientInput> | PatientSubsidyCreateWithoutPatientInput[] | PatientSubsidyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutPatientInput | PatientSubsidyCreateOrConnectWithoutPatientInput[]
    upsert?: PatientSubsidyUpsertWithWhereUniqueWithoutPatientInput | PatientSubsidyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientSubsidyCreateManyPatientInputEnvelope
    set?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    disconnect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    delete?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    update?: PatientSubsidyUpdateWithWhereUniqueWithoutPatientInput | PatientSubsidyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientSubsidyUpdateManyWithWhereWithoutPatientInput | PatientSubsidyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientSubsidyScalarWhereInput | PatientSubsidyScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabReportUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabReportCreateWithoutPatientInput, LabReportUncheckedCreateWithoutPatientInput> | LabReportCreateWithoutPatientInput[] | LabReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutPatientInput | LabReportCreateOrConnectWithoutPatientInput[]
    upsert?: LabReportUpsertWithWhereUniqueWithoutPatientInput | LabReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabReportCreateManyPatientInputEnvelope
    set?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    disconnect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    delete?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    update?: LabReportUpdateWithWhereUniqueWithoutPatientInput | LabReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabReportUpdateManyWithWhereWithoutPatientInput | LabReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
  }

  export type RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutPatientInput, RadiologyReportUncheckedCreateWithoutPatientInput> | RadiologyReportCreateWithoutPatientInput[] | RadiologyReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutPatientInput | RadiologyReportCreateOrConnectWithoutPatientInput[]
    upsert?: RadiologyReportUpsertWithWhereUniqueWithoutPatientInput | RadiologyReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadiologyReportCreateManyPatientInputEnvelope
    set?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    disconnect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    delete?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    update?: RadiologyReportUpdateWithWhereUniqueWithoutPatientInput | RadiologyReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadiologyReportUpdateManyWithWhereWithoutPatientInput | RadiologyReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientDetailsInput, InvoiceUncheckedCreateWithoutPatientDetailsInput> | InvoiceCreateWithoutPatientDetailsInput[] | InvoiceUncheckedCreateWithoutPatientDetailsInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientDetailsInput | InvoiceCreateOrConnectWithoutPatientDetailsInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientDetailsInput | InvoiceUpsertWithWhereUniqueWithoutPatientDetailsInput[]
    createMany?: InvoiceCreateManyPatientDetailsInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientDetailsInput | InvoiceUpdateWithWhereUniqueWithoutPatientDetailsInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientDetailsInput | InvoiceUpdateManyWithWhereWithoutPatientDetailsInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type BedAllocationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BedAllocationCreateWithoutPatientInput, BedAllocationUncheckedCreateWithoutPatientInput> | BedAllocationCreateWithoutPatientInput[] | BedAllocationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutPatientInput | BedAllocationCreateOrConnectWithoutPatientInput[]
    upsert?: BedAllocationUpsertWithWhereUniqueWithoutPatientInput | BedAllocationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BedAllocationCreateManyPatientInputEnvelope
    set?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    disconnect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    delete?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    update?: BedAllocationUpdateWithWhereUniqueWithoutPatientInput | BedAllocationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BedAllocationUpdateManyWithWhereWithoutPatientInput | BedAllocationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
  }

  export type VitalSignUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutPatientInput | VitalSignUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutPatientInput | VitalSignUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutPatientInput | VitalSignUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientSubsidyCreateWithoutPatientInput, PatientSubsidyUncheckedCreateWithoutPatientInput> | PatientSubsidyCreateWithoutPatientInput[] | PatientSubsidyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutPatientInput | PatientSubsidyCreateOrConnectWithoutPatientInput[]
    upsert?: PatientSubsidyUpsertWithWhereUniqueWithoutPatientInput | PatientSubsidyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientSubsidyCreateManyPatientInputEnvelope
    set?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    disconnect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    delete?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    update?: PatientSubsidyUpdateWithWhereUniqueWithoutPatientInput | PatientSubsidyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientSubsidyUpdateManyWithWhereWithoutPatientInput | PatientSubsidyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientSubsidyScalarWhereInput | PatientSubsidyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNurseInput = {
    create?: XOR<UserCreateWithoutNurseInput, UserUncheckedCreateWithoutNurseInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseInput
    connect?: UserWhereUniqueInput
  }

  export type VitalSignCreateNestedManyWithoutNurseInput = {
    create?: XOR<VitalSignCreateWithoutNurseInput, VitalSignUncheckedCreateWithoutNurseInput> | VitalSignCreateWithoutNurseInput[] | VitalSignUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutNurseInput | VitalSignCreateOrConnectWithoutNurseInput[]
    createMany?: VitalSignCreateManyNurseInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type BedAllocationCreateNestedManyWithoutNurseInput = {
    create?: XOR<BedAllocationCreateWithoutNurseInput, BedAllocationUncheckedCreateWithoutNurseInput> | BedAllocationCreateWithoutNurseInput[] | BedAllocationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutNurseInput | BedAllocationCreateOrConnectWithoutNurseInput[]
    createMany?: BedAllocationCreateManyNurseInputEnvelope
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
  }

  export type VitalSignUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<VitalSignCreateWithoutNurseInput, VitalSignUncheckedCreateWithoutNurseInput> | VitalSignCreateWithoutNurseInput[] | VitalSignUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutNurseInput | VitalSignCreateOrConnectWithoutNurseInput[]
    createMany?: VitalSignCreateManyNurseInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type BedAllocationUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<BedAllocationCreateWithoutNurseInput, BedAllocationUncheckedCreateWithoutNurseInput> | BedAllocationCreateWithoutNurseInput[] | BedAllocationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutNurseInput | BedAllocationCreateOrConnectWithoutNurseInput[]
    createMany?: BedAllocationCreateManyNurseInputEnvelope
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutNurseNestedInput = {
    create?: XOR<UserCreateWithoutNurseInput, UserUncheckedCreateWithoutNurseInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseInput
    upsert?: UserUpsertWithoutNurseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseInput, UserUpdateWithoutNurseInput>, UserUncheckedUpdateWithoutNurseInput>
  }

  export type VitalSignUpdateManyWithoutNurseNestedInput = {
    create?: XOR<VitalSignCreateWithoutNurseInput, VitalSignUncheckedCreateWithoutNurseInput> | VitalSignCreateWithoutNurseInput[] | VitalSignUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutNurseInput | VitalSignCreateOrConnectWithoutNurseInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutNurseInput | VitalSignUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: VitalSignCreateManyNurseInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutNurseInput | VitalSignUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutNurseInput | VitalSignUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type BedAllocationUpdateManyWithoutNurseNestedInput = {
    create?: XOR<BedAllocationCreateWithoutNurseInput, BedAllocationUncheckedCreateWithoutNurseInput> | BedAllocationCreateWithoutNurseInput[] | BedAllocationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutNurseInput | BedAllocationCreateOrConnectWithoutNurseInput[]
    upsert?: BedAllocationUpsertWithWhereUniqueWithoutNurseInput | BedAllocationUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: BedAllocationCreateManyNurseInputEnvelope
    set?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    disconnect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    delete?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    update?: BedAllocationUpdateWithWhereUniqueWithoutNurseInput | BedAllocationUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: BedAllocationUpdateManyWithWhereWithoutNurseInput | BedAllocationUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
  }

  export type VitalSignUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<VitalSignCreateWithoutNurseInput, VitalSignUncheckedCreateWithoutNurseInput> | VitalSignCreateWithoutNurseInput[] | VitalSignUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutNurseInput | VitalSignCreateOrConnectWithoutNurseInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutNurseInput | VitalSignUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: VitalSignCreateManyNurseInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutNurseInput | VitalSignUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutNurseInput | VitalSignUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type BedAllocationUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<BedAllocationCreateWithoutNurseInput, BedAllocationUncheckedCreateWithoutNurseInput> | BedAllocationCreateWithoutNurseInput[] | BedAllocationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutNurseInput | BedAllocationCreateOrConnectWithoutNurseInput[]
    upsert?: BedAllocationUpsertWithWhereUniqueWithoutNurseInput | BedAllocationUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: BedAllocationCreateManyNurseInputEnvelope
    set?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    disconnect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    delete?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    update?: BedAllocationUpdateWithWhereUniqueWithoutNurseInput | BedAllocationUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: BedAllocationUpdateManyWithWhereWithoutNurseInput | BedAllocationUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
  }

  export type PrescriptionCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<PrescriptionCreateWithoutAppointmentInput, PrescriptionUncheckedCreateWithoutAppointmentInput> | PrescriptionCreateWithoutAppointmentInput[] | PrescriptionUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAppointmentInput | PrescriptionCreateOrConnectWithoutAppointmentInput[]
    createMany?: PrescriptionCreateManyAppointmentInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabReportCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<LabReportCreateWithoutAppointmentInput, LabReportUncheckedCreateWithoutAppointmentInput> | LabReportCreateWithoutAppointmentInput[] | LabReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutAppointmentInput | LabReportCreateOrConnectWithoutAppointmentInput[]
    createMany?: LabReportCreateManyAppointmentInputEnvelope
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
  }

  export type RadiologyReportCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<RadiologyReportCreateWithoutAppointmentInput, RadiologyReportUncheckedCreateWithoutAppointmentInput> | RadiologyReportCreateWithoutAppointmentInput[] | RadiologyReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutAppointmentInput | RadiologyReportCreateOrConnectWithoutAppointmentInput[]
    createMany?: RadiologyReportCreateManyAppointmentInputEnvelope
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<PrescriptionCreateWithoutAppointmentInput, PrescriptionUncheckedCreateWithoutAppointmentInput> | PrescriptionCreateWithoutAppointmentInput[] | PrescriptionUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAppointmentInput | PrescriptionCreateOrConnectWithoutAppointmentInput[]
    createMany?: PrescriptionCreateManyAppointmentInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type LabReportUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<LabReportCreateWithoutAppointmentInput, LabReportUncheckedCreateWithoutAppointmentInput> | LabReportCreateWithoutAppointmentInput[] | LabReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutAppointmentInput | LabReportCreateOrConnectWithoutAppointmentInput[]
    createMany?: LabReportCreateManyAppointmentInputEnvelope
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
  }

  export type RadiologyReportUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<RadiologyReportCreateWithoutAppointmentInput, RadiologyReportUncheckedCreateWithoutAppointmentInput> | RadiologyReportCreateWithoutAppointmentInput[] | RadiologyReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutAppointmentInput | RadiologyReportCreateOrConnectWithoutAppointmentInput[]
    createMany?: RadiologyReportCreateManyAppointmentInputEnvelope
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    upsert?: DoctorUpsertWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAppointmentsInput, DoctorUpdateWithoutAppointmentsInput>, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PrescriptionUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<PrescriptionCreateWithoutAppointmentInput, PrescriptionUncheckedCreateWithoutAppointmentInput> | PrescriptionCreateWithoutAppointmentInput[] | PrescriptionUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAppointmentInput | PrescriptionCreateOrConnectWithoutAppointmentInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutAppointmentInput | PrescriptionUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: PrescriptionCreateManyAppointmentInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutAppointmentInput | PrescriptionUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutAppointmentInput | PrescriptionUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabReportUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<LabReportCreateWithoutAppointmentInput, LabReportUncheckedCreateWithoutAppointmentInput> | LabReportCreateWithoutAppointmentInput[] | LabReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutAppointmentInput | LabReportCreateOrConnectWithoutAppointmentInput[]
    upsert?: LabReportUpsertWithWhereUniqueWithoutAppointmentInput | LabReportUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: LabReportCreateManyAppointmentInputEnvelope
    set?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    disconnect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    delete?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    update?: LabReportUpdateWithWhereUniqueWithoutAppointmentInput | LabReportUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: LabReportUpdateManyWithWhereWithoutAppointmentInput | LabReportUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
  }

  export type RadiologyReportUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutAppointmentInput, RadiologyReportUncheckedCreateWithoutAppointmentInput> | RadiologyReportCreateWithoutAppointmentInput[] | RadiologyReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutAppointmentInput | RadiologyReportCreateOrConnectWithoutAppointmentInput[]
    upsert?: RadiologyReportUpsertWithWhereUniqueWithoutAppointmentInput | RadiologyReportUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: RadiologyReportCreateManyAppointmentInputEnvelope
    set?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    disconnect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    delete?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    update?: RadiologyReportUpdateWithWhereUniqueWithoutAppointmentInput | RadiologyReportUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: RadiologyReportUpdateManyWithWhereWithoutAppointmentInput | RadiologyReportUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<PrescriptionCreateWithoutAppointmentInput, PrescriptionUncheckedCreateWithoutAppointmentInput> | PrescriptionCreateWithoutAppointmentInput[] | PrescriptionUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAppointmentInput | PrescriptionCreateOrConnectWithoutAppointmentInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutAppointmentInput | PrescriptionUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: PrescriptionCreateManyAppointmentInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutAppointmentInput | PrescriptionUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutAppointmentInput | PrescriptionUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type LabReportUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<LabReportCreateWithoutAppointmentInput, LabReportUncheckedCreateWithoutAppointmentInput> | LabReportCreateWithoutAppointmentInput[] | LabReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: LabReportCreateOrConnectWithoutAppointmentInput | LabReportCreateOrConnectWithoutAppointmentInput[]
    upsert?: LabReportUpsertWithWhereUniqueWithoutAppointmentInput | LabReportUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: LabReportCreateManyAppointmentInputEnvelope
    set?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    disconnect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    delete?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    connect?: LabReportWhereUniqueInput | LabReportWhereUniqueInput[]
    update?: LabReportUpdateWithWhereUniqueWithoutAppointmentInput | LabReportUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: LabReportUpdateManyWithWhereWithoutAppointmentInput | LabReportUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
  }

  export type RadiologyReportUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutAppointmentInput, RadiologyReportUncheckedCreateWithoutAppointmentInput> | RadiologyReportCreateWithoutAppointmentInput[] | RadiologyReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutAppointmentInput | RadiologyReportCreateOrConnectWithoutAppointmentInput[]
    upsert?: RadiologyReportUpsertWithWhereUniqueWithoutAppointmentInput | RadiologyReportUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: RadiologyReportCreateManyAppointmentInputEnvelope
    set?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    disconnect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    delete?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    connect?: RadiologyReportWhereUniqueInput | RadiologyReportWhereUniqueInput[]
    update?: RadiologyReportUpdateWithWhereUniqueWithoutAppointmentInput | RadiologyReportUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: RadiologyReportUpdateManyWithWhereWithoutAppointmentInput | RadiologyReportUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionsInput
    connect?: DoctorWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<AppointmentCreateWithoutPrescriptionsInput, AppointmentUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutPrescriptionsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
  }

  export type PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionsInput
    upsert?: DoctorUpsertWithoutPrescriptionsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutPrescriptionsInput, DoctorUpdateWithoutPrescriptionsInput>, DoctorUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type AppointmentUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<AppointmentCreateWithoutPrescriptionsInput, AppointmentUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutPrescriptionsInput
    upsert?: AppointmentUpsertWithoutPrescriptionsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutPrescriptionsInput, AppointmentUpdateWithoutPrescriptionsInput>, AppointmentUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    set?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    disconnect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    delete?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    update?: PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
  }

  export type PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    set?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    disconnect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    delete?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    update?: PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutMedicinesInput = {
    create?: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutMedicinesInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MedicineCreateNestedOneWithoutPrescriptionMedicinesInput = {
    create?: XOR<MedicineCreateWithoutPrescriptionMedicinesInput, MedicineUncheckedCreateWithoutPrescriptionMedicinesInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutPrescriptionMedicinesInput
    connect?: MedicineWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutMedicinesNestedInput = {
    create?: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutMedicinesInput
    upsert?: PrescriptionUpsertWithoutMedicinesInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutMedicinesInput, PrescriptionUpdateWithoutMedicinesInput>, PrescriptionUncheckedUpdateWithoutMedicinesInput>
  }

  export type MedicineUpdateOneRequiredWithoutPrescriptionMedicinesNestedInput = {
    create?: XOR<MedicineCreateWithoutPrescriptionMedicinesInput, MedicineUncheckedCreateWithoutPrescriptionMedicinesInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutPrescriptionMedicinesInput
    upsert?: MedicineUpsertWithoutPrescriptionMedicinesInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutPrescriptionMedicinesInput, MedicineUpdateWithoutPrescriptionMedicinesInput>, MedicineUncheckedUpdateWithoutPrescriptionMedicinesInput>
  }

  export type PrescriptionMedicineCreateNestedManyWithoutMedicineInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutMedicineInput, PrescriptionMedicineUncheckedCreateWithoutMedicineInput> | PrescriptionMedicineCreateWithoutMedicineInput[] | PrescriptionMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutMedicineInput | PrescriptionMedicineCreateOrConnectWithoutMedicineInput[]
    createMany?: PrescriptionMedicineCreateManyMedicineInputEnvelope
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
  }

  export type InventoryLogCreateNestedManyWithoutMedicineInput = {
    create?: XOR<InventoryLogCreateWithoutMedicineInput, InventoryLogUncheckedCreateWithoutMedicineInput> | InventoryLogCreateWithoutMedicineInput[] | InventoryLogUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: InventoryLogCreateOrConnectWithoutMedicineInput | InventoryLogCreateOrConnectWithoutMedicineInput[]
    createMany?: InventoryLogCreateManyMedicineInputEnvelope
    connect?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
  }

  export type PrescriptionMedicineUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutMedicineInput, PrescriptionMedicineUncheckedCreateWithoutMedicineInput> | PrescriptionMedicineCreateWithoutMedicineInput[] | PrescriptionMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutMedicineInput | PrescriptionMedicineCreateOrConnectWithoutMedicineInput[]
    createMany?: PrescriptionMedicineCreateManyMedicineInputEnvelope
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
  }

  export type InventoryLogUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<InventoryLogCreateWithoutMedicineInput, InventoryLogUncheckedCreateWithoutMedicineInput> | InventoryLogCreateWithoutMedicineInput[] | InventoryLogUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: InventoryLogCreateOrConnectWithoutMedicineInput | InventoryLogCreateOrConnectWithoutMedicineInput[]
    createMany?: InventoryLogCreateManyMedicineInputEnvelope
    connect?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
  }

  export type PrescriptionMedicineUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutMedicineInput, PrescriptionMedicineUncheckedCreateWithoutMedicineInput> | PrescriptionMedicineCreateWithoutMedicineInput[] | PrescriptionMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutMedicineInput | PrescriptionMedicineCreateOrConnectWithoutMedicineInput[]
    upsert?: PrescriptionMedicineUpsertWithWhereUniqueWithoutMedicineInput | PrescriptionMedicineUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: PrescriptionMedicineCreateManyMedicineInputEnvelope
    set?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    disconnect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    delete?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    update?: PrescriptionMedicineUpdateWithWhereUniqueWithoutMedicineInput | PrescriptionMedicineUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: PrescriptionMedicineUpdateManyWithWhereWithoutMedicineInput | PrescriptionMedicineUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
  }

  export type InventoryLogUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<InventoryLogCreateWithoutMedicineInput, InventoryLogUncheckedCreateWithoutMedicineInput> | InventoryLogCreateWithoutMedicineInput[] | InventoryLogUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: InventoryLogCreateOrConnectWithoutMedicineInput | InventoryLogCreateOrConnectWithoutMedicineInput[]
    upsert?: InventoryLogUpsertWithWhereUniqueWithoutMedicineInput | InventoryLogUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: InventoryLogCreateManyMedicineInputEnvelope
    set?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    disconnect?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    delete?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    connect?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    update?: InventoryLogUpdateWithWhereUniqueWithoutMedicineInput | InventoryLogUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: InventoryLogUpdateManyWithWhereWithoutMedicineInput | InventoryLogUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: InventoryLogScalarWhereInput | InventoryLogScalarWhereInput[]
  }

  export type PrescriptionMedicineUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutMedicineInput, PrescriptionMedicineUncheckedCreateWithoutMedicineInput> | PrescriptionMedicineCreateWithoutMedicineInput[] | PrescriptionMedicineUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutMedicineInput | PrescriptionMedicineCreateOrConnectWithoutMedicineInput[]
    upsert?: PrescriptionMedicineUpsertWithWhereUniqueWithoutMedicineInput | PrescriptionMedicineUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: PrescriptionMedicineCreateManyMedicineInputEnvelope
    set?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    disconnect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    delete?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    update?: PrescriptionMedicineUpdateWithWhereUniqueWithoutMedicineInput | PrescriptionMedicineUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: PrescriptionMedicineUpdateManyWithWhereWithoutMedicineInput | PrescriptionMedicineUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
  }

  export type InventoryLogUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<InventoryLogCreateWithoutMedicineInput, InventoryLogUncheckedCreateWithoutMedicineInput> | InventoryLogCreateWithoutMedicineInput[] | InventoryLogUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: InventoryLogCreateOrConnectWithoutMedicineInput | InventoryLogCreateOrConnectWithoutMedicineInput[]
    upsert?: InventoryLogUpsertWithWhereUniqueWithoutMedicineInput | InventoryLogUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: InventoryLogCreateManyMedicineInputEnvelope
    set?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    disconnect?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    delete?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    connect?: InventoryLogWhereUniqueInput | InventoryLogWhereUniqueInput[]
    update?: InventoryLogUpdateWithWhereUniqueWithoutMedicineInput | InventoryLogUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: InventoryLogUpdateManyWithWhereWithoutMedicineInput | InventoryLogUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: InventoryLogScalarWhereInput | InventoryLogScalarWhereInput[]
  }

  export type MedicineCreateNestedOneWithoutInventoryLogsInput = {
    create?: XOR<MedicineCreateWithoutInventoryLogsInput, MedicineUncheckedCreateWithoutInventoryLogsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutInventoryLogsInput
    connect?: MedicineWhereUniqueInput
  }

  export type MedicineUpdateOneRequiredWithoutInventoryLogsNestedInput = {
    create?: XOR<MedicineCreateWithoutInventoryLogsInput, MedicineUncheckedCreateWithoutInventoryLogsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutInventoryLogsInput
    upsert?: MedicineUpsertWithoutInventoryLogsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutInventoryLogsInput, MedicineUpdateWithoutInventoryLogsInput>, MedicineUncheckedUpdateWithoutInventoryLogsInput>
  }

  export type PatientCreateNestedOneWithoutLabReportsInput = {
    create?: XOR<PatientCreateWithoutLabReportsInput, PatientUncheckedCreateWithoutLabReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabReportsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutLabReportsInput = {
    create?: XOR<DoctorCreateWithoutLabReportsInput, DoctorUncheckedCreateWithoutLabReportsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutLabReportsInput
    connect?: DoctorWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutLabReportsInput = {
    create?: XOR<AppointmentCreateWithoutLabReportsInput, AppointmentUncheckedCreateWithoutLabReportsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutLabReportsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutLabReportInput = {
    create?: XOR<InvoiceItemCreateWithoutLabReportInput, InvoiceItemUncheckedCreateWithoutLabReportInput> | InvoiceItemCreateWithoutLabReportInput[] | InvoiceItemUncheckedCreateWithoutLabReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutLabReportInput | InvoiceItemCreateOrConnectWithoutLabReportInput[]
    createMany?: InvoiceItemCreateManyLabReportInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutLabReportInput = {
    create?: XOR<InvoiceItemCreateWithoutLabReportInput, InvoiceItemUncheckedCreateWithoutLabReportInput> | InvoiceItemCreateWithoutLabReportInput[] | InvoiceItemUncheckedCreateWithoutLabReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutLabReportInput | InvoiceItemCreateOrConnectWithoutLabReportInput[]
    createMany?: InvoiceItemCreateManyLabReportInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutLabReportsNestedInput = {
    create?: XOR<PatientCreateWithoutLabReportsInput, PatientUncheckedCreateWithoutLabReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabReportsInput
    upsert?: PatientUpsertWithoutLabReportsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLabReportsInput, PatientUpdateWithoutLabReportsInput>, PatientUncheckedUpdateWithoutLabReportsInput>
  }

  export type DoctorUpdateOneRequiredWithoutLabReportsNestedInput = {
    create?: XOR<DoctorCreateWithoutLabReportsInput, DoctorUncheckedCreateWithoutLabReportsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutLabReportsInput
    upsert?: DoctorUpsertWithoutLabReportsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutLabReportsInput, DoctorUpdateWithoutLabReportsInput>, DoctorUncheckedUpdateWithoutLabReportsInput>
  }

  export type AppointmentUpdateOneWithoutLabReportsNestedInput = {
    create?: XOR<AppointmentCreateWithoutLabReportsInput, AppointmentUncheckedCreateWithoutLabReportsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutLabReportsInput
    upsert?: AppointmentUpsertWithoutLabReportsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutLabReportsInput, AppointmentUpdateWithoutLabReportsInput>, AppointmentUncheckedUpdateWithoutLabReportsInput>
  }

  export type InvoiceItemUpdateManyWithoutLabReportNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutLabReportInput, InvoiceItemUncheckedCreateWithoutLabReportInput> | InvoiceItemCreateWithoutLabReportInput[] | InvoiceItemUncheckedCreateWithoutLabReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutLabReportInput | InvoiceItemCreateOrConnectWithoutLabReportInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutLabReportInput | InvoiceItemUpsertWithWhereUniqueWithoutLabReportInput[]
    createMany?: InvoiceItemCreateManyLabReportInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutLabReportInput | InvoiceItemUpdateWithWhereUniqueWithoutLabReportInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutLabReportInput | InvoiceItemUpdateManyWithWhereWithoutLabReportInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutLabReportNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutLabReportInput, InvoiceItemUncheckedCreateWithoutLabReportInput> | InvoiceItemCreateWithoutLabReportInput[] | InvoiceItemUncheckedCreateWithoutLabReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutLabReportInput | InvoiceItemCreateOrConnectWithoutLabReportInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutLabReportInput | InvoiceItemUpsertWithWhereUniqueWithoutLabReportInput[]
    createMany?: InvoiceItemCreateManyLabReportInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutLabReportInput | InvoiceItemUpdateWithWhereUniqueWithoutLabReportInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutLabReportInput | InvoiceItemUpdateManyWithWhereWithoutLabReportInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutRadiologyReportsInput = {
    create?: XOR<PatientCreateWithoutRadiologyReportsInput, PatientUncheckedCreateWithoutRadiologyReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiologyReportsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutRadiologyReportsInput = {
    create?: XOR<DoctorCreateWithoutRadiologyReportsInput, DoctorUncheckedCreateWithoutRadiologyReportsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutRadiologyReportsInput
    connect?: DoctorWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutRadiologyReportsInput = {
    create?: XOR<AppointmentCreateWithoutRadiologyReportsInput, AppointmentUncheckedCreateWithoutRadiologyReportsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutRadiologyReportsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutRadiologyReportInput = {
    create?: XOR<InvoiceItemCreateWithoutRadiologyReportInput, InvoiceItemUncheckedCreateWithoutRadiologyReportInput> | InvoiceItemCreateWithoutRadiologyReportInput[] | InvoiceItemUncheckedCreateWithoutRadiologyReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutRadiologyReportInput | InvoiceItemCreateOrConnectWithoutRadiologyReportInput[]
    createMany?: InvoiceItemCreateManyRadiologyReportInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutRadiologyReportInput = {
    create?: XOR<InvoiceItemCreateWithoutRadiologyReportInput, InvoiceItemUncheckedCreateWithoutRadiologyReportInput> | InvoiceItemCreateWithoutRadiologyReportInput[] | InvoiceItemUncheckedCreateWithoutRadiologyReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutRadiologyReportInput | InvoiceItemCreateOrConnectWithoutRadiologyReportInput[]
    createMany?: InvoiceItemCreateManyRadiologyReportInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutRadiologyReportsNestedInput = {
    create?: XOR<PatientCreateWithoutRadiologyReportsInput, PatientUncheckedCreateWithoutRadiologyReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiologyReportsInput
    upsert?: PatientUpsertWithoutRadiologyReportsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRadiologyReportsInput, PatientUpdateWithoutRadiologyReportsInput>, PatientUncheckedUpdateWithoutRadiologyReportsInput>
  }

  export type DoctorUpdateOneRequiredWithoutRadiologyReportsNestedInput = {
    create?: XOR<DoctorCreateWithoutRadiologyReportsInput, DoctorUncheckedCreateWithoutRadiologyReportsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutRadiologyReportsInput
    upsert?: DoctorUpsertWithoutRadiologyReportsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutRadiologyReportsInput, DoctorUpdateWithoutRadiologyReportsInput>, DoctorUncheckedUpdateWithoutRadiologyReportsInput>
  }

  export type AppointmentUpdateOneWithoutRadiologyReportsNestedInput = {
    create?: XOR<AppointmentCreateWithoutRadiologyReportsInput, AppointmentUncheckedCreateWithoutRadiologyReportsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutRadiologyReportsInput
    upsert?: AppointmentUpsertWithoutRadiologyReportsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutRadiologyReportsInput, AppointmentUpdateWithoutRadiologyReportsInput>, AppointmentUncheckedUpdateWithoutRadiologyReportsInput>
  }

  export type InvoiceItemUpdateManyWithoutRadiologyReportNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutRadiologyReportInput, InvoiceItemUncheckedCreateWithoutRadiologyReportInput> | InvoiceItemCreateWithoutRadiologyReportInput[] | InvoiceItemUncheckedCreateWithoutRadiologyReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutRadiologyReportInput | InvoiceItemCreateOrConnectWithoutRadiologyReportInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutRadiologyReportInput | InvoiceItemUpsertWithWhereUniqueWithoutRadiologyReportInput[]
    createMany?: InvoiceItemCreateManyRadiologyReportInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutRadiologyReportInput | InvoiceItemUpdateWithWhereUniqueWithoutRadiologyReportInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutRadiologyReportInput | InvoiceItemUpdateManyWithWhereWithoutRadiologyReportInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutRadiologyReportNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutRadiologyReportInput, InvoiceItemUncheckedCreateWithoutRadiologyReportInput> | InvoiceItemCreateWithoutRadiologyReportInput[] | InvoiceItemUncheckedCreateWithoutRadiologyReportInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutRadiologyReportInput | InvoiceItemCreateOrConnectWithoutRadiologyReportInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutRadiologyReportInput | InvoiceItemUpsertWithWhereUniqueWithoutRadiologyReportInput[]
    createMany?: InvoiceItemCreateManyRadiologyReportInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutRadiologyReportInput | InvoiceItemUpdateWithWhereUniqueWithoutRadiologyReportInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutRadiologyReportInput | InvoiceItemUpdateManyWithWhereWithoutRadiologyReportInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubsidyClaimCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SubsidyClaimCreateWithoutInvoiceInput, SubsidyClaimUncheckedCreateWithoutInvoiceInput> | SubsidyClaimCreateWithoutInvoiceInput[] | SubsidyClaimUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutInvoiceInput | SubsidyClaimCreateOrConnectWithoutInvoiceInput[]
    createMany?: SubsidyClaimCreateManyInvoiceInputEnvelope
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubsidyClaimUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SubsidyClaimCreateWithoutInvoiceInput, SubsidyClaimUncheckedCreateWithoutInvoiceInput> | SubsidyClaimCreateWithoutInvoiceInput[] | SubsidyClaimUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutInvoiceInput | SubsidyClaimCreateOrConnectWithoutInvoiceInput[]
    createMany?: SubsidyClaimCreateManyInvoiceInputEnvelope
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubsidyClaimUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SubsidyClaimCreateWithoutInvoiceInput, SubsidyClaimUncheckedCreateWithoutInvoiceInput> | SubsidyClaimCreateWithoutInvoiceInput[] | SubsidyClaimUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutInvoiceInput | SubsidyClaimCreateOrConnectWithoutInvoiceInput[]
    upsert?: SubsidyClaimUpsertWithWhereUniqueWithoutInvoiceInput | SubsidyClaimUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SubsidyClaimCreateManyInvoiceInputEnvelope
    set?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    disconnect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    delete?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    update?: SubsidyClaimUpdateWithWhereUniqueWithoutInvoiceInput | SubsidyClaimUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SubsidyClaimUpdateManyWithWhereWithoutInvoiceInput | SubsidyClaimUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubsidyClaimUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SubsidyClaimCreateWithoutInvoiceInput, SubsidyClaimUncheckedCreateWithoutInvoiceInput> | SubsidyClaimCreateWithoutInvoiceInput[] | SubsidyClaimUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutInvoiceInput | SubsidyClaimCreateOrConnectWithoutInvoiceInput[]
    upsert?: SubsidyClaimUpsertWithWhereUniqueWithoutInvoiceInput | SubsidyClaimUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SubsidyClaimCreateManyInvoiceInputEnvelope
    set?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    disconnect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    delete?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    update?: SubsidyClaimUpdateWithWhereUniqueWithoutInvoiceInput | SubsidyClaimUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SubsidyClaimUpdateManyWithWhereWithoutInvoiceInput | SubsidyClaimUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type LabReportCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<LabReportCreateWithoutInvoiceItemsInput, LabReportUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: LabReportCreateOrConnectWithoutInvoiceItemsInput
    connect?: LabReportWhereUniqueInput
  }

  export type RadiologyReportCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<RadiologyReportCreateWithoutInvoiceItemsInput, RadiologyReportUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutInvoiceItemsInput
    connect?: RadiologyReportWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: InvoiceUpsertWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutInvoiceItemsInput, InvoiceUpdateWithoutInvoiceItemsInput>, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type LabReportUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<LabReportCreateWithoutInvoiceItemsInput, LabReportUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: LabReportCreateOrConnectWithoutInvoiceItemsInput
    upsert?: LabReportUpsertWithoutInvoiceItemsInput
    disconnect?: LabReportWhereInput | boolean
    delete?: LabReportWhereInput | boolean
    connect?: LabReportWhereUniqueInput
    update?: XOR<XOR<LabReportUpdateToOneWithWhereWithoutInvoiceItemsInput, LabReportUpdateWithoutInvoiceItemsInput>, LabReportUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type RadiologyReportUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<RadiologyReportCreateWithoutInvoiceItemsInput, RadiologyReportUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: RadiologyReportCreateOrConnectWithoutInvoiceItemsInput
    upsert?: RadiologyReportUpsertWithoutInvoiceItemsInput
    disconnect?: RadiologyReportWhereInput | boolean
    delete?: RadiologyReportWhereInput | boolean
    connect?: RadiologyReportWhereUniqueInput
    update?: XOR<XOR<RadiologyReportUpdateToOneWithWhereWithoutInvoiceItemsInput, RadiologyReportUpdateWithoutInvoiceItemsInput>, RadiologyReportUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type WardCreateNestedOneWithoutBedsInput = {
    create?: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    connectOrCreate?: WardCreateOrConnectWithoutBedsInput
    connect?: WardWhereUniqueInput
  }

  export type BedAllocationCreateNestedManyWithoutBedInput = {
    create?: XOR<BedAllocationCreateWithoutBedInput, BedAllocationUncheckedCreateWithoutBedInput> | BedAllocationCreateWithoutBedInput[] | BedAllocationUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutBedInput | BedAllocationCreateOrConnectWithoutBedInput[]
    createMany?: BedAllocationCreateManyBedInputEnvelope
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
  }

  export type BedAllocationUncheckedCreateNestedManyWithoutBedInput = {
    create?: XOR<BedAllocationCreateWithoutBedInput, BedAllocationUncheckedCreateWithoutBedInput> | BedAllocationCreateWithoutBedInput[] | BedAllocationUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutBedInput | BedAllocationCreateOrConnectWithoutBedInput[]
    createMany?: BedAllocationCreateManyBedInputEnvelope
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
  }

  export type WardUpdateOneRequiredWithoutBedsNestedInput = {
    create?: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    connectOrCreate?: WardCreateOrConnectWithoutBedsInput
    upsert?: WardUpsertWithoutBedsInput
    connect?: WardWhereUniqueInput
    update?: XOR<XOR<WardUpdateToOneWithWhereWithoutBedsInput, WardUpdateWithoutBedsInput>, WardUncheckedUpdateWithoutBedsInput>
  }

  export type BedAllocationUpdateManyWithoutBedNestedInput = {
    create?: XOR<BedAllocationCreateWithoutBedInput, BedAllocationUncheckedCreateWithoutBedInput> | BedAllocationCreateWithoutBedInput[] | BedAllocationUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutBedInput | BedAllocationCreateOrConnectWithoutBedInput[]
    upsert?: BedAllocationUpsertWithWhereUniqueWithoutBedInput | BedAllocationUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: BedAllocationCreateManyBedInputEnvelope
    set?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    disconnect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    delete?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    update?: BedAllocationUpdateWithWhereUniqueWithoutBedInput | BedAllocationUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: BedAllocationUpdateManyWithWhereWithoutBedInput | BedAllocationUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
  }

  export type BedAllocationUncheckedUpdateManyWithoutBedNestedInput = {
    create?: XOR<BedAllocationCreateWithoutBedInput, BedAllocationUncheckedCreateWithoutBedInput> | BedAllocationCreateWithoutBedInput[] | BedAllocationUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedAllocationCreateOrConnectWithoutBedInput | BedAllocationCreateOrConnectWithoutBedInput[]
    upsert?: BedAllocationUpsertWithWhereUniqueWithoutBedInput | BedAllocationUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: BedAllocationCreateManyBedInputEnvelope
    set?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    disconnect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    delete?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    connect?: BedAllocationWhereUniqueInput | BedAllocationWhereUniqueInput[]
    update?: BedAllocationUpdateWithWhereUniqueWithoutBedInput | BedAllocationUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: BedAllocationUpdateManyWithWhereWithoutBedInput | BedAllocationUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
  }

  export type BedCreateNestedManyWithoutWardInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUpdateManyWithoutWardNestedInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutWardInput | BedUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutWardInput | BedUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: BedUpdateManyWithWhereWithoutWardInput | BedUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutWardInput | BedUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutWardInput | BedUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: BedUpdateManyWithWhereWithoutWardInput | BedUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedCreateNestedOneWithoutBedAllocationsInput = {
    create?: XOR<BedCreateWithoutBedAllocationsInput, BedUncheckedCreateWithoutBedAllocationsInput>
    connectOrCreate?: BedCreateOrConnectWithoutBedAllocationsInput
    connect?: BedWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutBedAllocationsInput = {
    create?: XOR<PatientCreateWithoutBedAllocationsInput, PatientUncheckedCreateWithoutBedAllocationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBedAllocationsInput
    connect?: PatientWhereUniqueInput
  }

  export type NurseCreateNestedOneWithoutBedAllocationsInput = {
    create?: XOR<NurseCreateWithoutBedAllocationsInput, NurseUncheckedCreateWithoutBedAllocationsInput>
    connectOrCreate?: NurseCreateOrConnectWithoutBedAllocationsInput
    connect?: NurseWhereUniqueInput
  }

  export type BedUpdateOneRequiredWithoutBedAllocationsNestedInput = {
    create?: XOR<BedCreateWithoutBedAllocationsInput, BedUncheckedCreateWithoutBedAllocationsInput>
    connectOrCreate?: BedCreateOrConnectWithoutBedAllocationsInput
    upsert?: BedUpsertWithoutBedAllocationsInput
    connect?: BedWhereUniqueInput
    update?: XOR<XOR<BedUpdateToOneWithWhereWithoutBedAllocationsInput, BedUpdateWithoutBedAllocationsInput>, BedUncheckedUpdateWithoutBedAllocationsInput>
  }

  export type PatientUpdateOneRequiredWithoutBedAllocationsNestedInput = {
    create?: XOR<PatientCreateWithoutBedAllocationsInput, PatientUncheckedCreateWithoutBedAllocationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBedAllocationsInput
    upsert?: PatientUpsertWithoutBedAllocationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutBedAllocationsInput, PatientUpdateWithoutBedAllocationsInput>, PatientUncheckedUpdateWithoutBedAllocationsInput>
  }

  export type NurseUpdateOneWithoutBedAllocationsNestedInput = {
    create?: XOR<NurseCreateWithoutBedAllocationsInput, NurseUncheckedCreateWithoutBedAllocationsInput>
    connectOrCreate?: NurseCreateOrConnectWithoutBedAllocationsInput
    upsert?: NurseUpsertWithoutBedAllocationsInput
    disconnect?: NurseWhereInput | boolean
    delete?: NurseWhereInput | boolean
    connect?: NurseWhereUniqueInput
    update?: XOR<XOR<NurseUpdateToOneWithWhereWithoutBedAllocationsInput, NurseUpdateWithoutBedAllocationsInput>, NurseUncheckedUpdateWithoutBedAllocationsInput>
  }

  export type PatientCreateNestedOneWithoutVitalSignsInput = {
    create?: XOR<PatientCreateWithoutVitalSignsInput, PatientUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVitalSignsInput
    connect?: PatientWhereUniqueInput
  }

  export type NurseCreateNestedOneWithoutVitalSignsInput = {
    create?: XOR<NurseCreateWithoutVitalSignsInput, NurseUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: NurseCreateOrConnectWithoutVitalSignsInput
    connect?: NurseWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutVitalSignsNestedInput = {
    create?: XOR<PatientCreateWithoutVitalSignsInput, PatientUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVitalSignsInput
    upsert?: PatientUpsertWithoutVitalSignsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutVitalSignsInput, PatientUpdateWithoutVitalSignsInput>, PatientUncheckedUpdateWithoutVitalSignsInput>
  }

  export type NurseUpdateOneRequiredWithoutVitalSignsNestedInput = {
    create?: XOR<NurseCreateWithoutVitalSignsInput, NurseUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: NurseCreateOrConnectWithoutVitalSignsInput
    upsert?: NurseUpsertWithoutVitalSignsInput
    connect?: NurseWhereUniqueInput
    update?: XOR<XOR<NurseUpdateToOneWithWhereWithoutVitalSignsInput, NurseUpdateWithoutVitalSignsInput>, NurseUncheckedUpdateWithoutVitalSignsInput>
  }

  export type DoctorCreateNestedOneWithoutOperationTheatersInput = {
    create?: XOR<DoctorCreateWithoutOperationTheatersInput, DoctorUncheckedCreateWithoutOperationTheatersInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutOperationTheatersInput
    connect?: DoctorWhereUniqueInput
  }

  export type SurgeryCreateNestedManyWithoutOperationTheaterInput = {
    create?: XOR<SurgeryCreateWithoutOperationTheaterInput, SurgeryUncheckedCreateWithoutOperationTheaterInput> | SurgeryCreateWithoutOperationTheaterInput[] | SurgeryUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutOperationTheaterInput | SurgeryCreateOrConnectWithoutOperationTheaterInput[]
    createMany?: SurgeryCreateManyOperationTheaterInputEnvelope
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
  }

  export type OperationTheaterEquipmentCreateNestedManyWithoutOperationTheaterInput = {
    create?: XOR<OperationTheaterEquipmentCreateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput> | OperationTheaterEquipmentCreateWithoutOperationTheaterInput[] | OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput | OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput[]
    createMany?: OperationTheaterEquipmentCreateManyOperationTheaterInputEnvelope
    connect?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
  }

  export type SurgeryUncheckedCreateNestedManyWithoutOperationTheaterInput = {
    create?: XOR<SurgeryCreateWithoutOperationTheaterInput, SurgeryUncheckedCreateWithoutOperationTheaterInput> | SurgeryCreateWithoutOperationTheaterInput[] | SurgeryUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutOperationTheaterInput | SurgeryCreateOrConnectWithoutOperationTheaterInput[]
    createMany?: SurgeryCreateManyOperationTheaterInputEnvelope
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
  }

  export type OperationTheaterEquipmentUncheckedCreateNestedManyWithoutOperationTheaterInput = {
    create?: XOR<OperationTheaterEquipmentCreateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput> | OperationTheaterEquipmentCreateWithoutOperationTheaterInput[] | OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput | OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput[]
    createMany?: OperationTheaterEquipmentCreateManyOperationTheaterInputEnvelope
    connect?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
  }

  export type DoctorUpdateOneWithoutOperationTheatersNestedInput = {
    create?: XOR<DoctorCreateWithoutOperationTheatersInput, DoctorUncheckedCreateWithoutOperationTheatersInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutOperationTheatersInput
    upsert?: DoctorUpsertWithoutOperationTheatersInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutOperationTheatersInput, DoctorUpdateWithoutOperationTheatersInput>, DoctorUncheckedUpdateWithoutOperationTheatersInput>
  }

  export type SurgeryUpdateManyWithoutOperationTheaterNestedInput = {
    create?: XOR<SurgeryCreateWithoutOperationTheaterInput, SurgeryUncheckedCreateWithoutOperationTheaterInput> | SurgeryCreateWithoutOperationTheaterInput[] | SurgeryUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutOperationTheaterInput | SurgeryCreateOrConnectWithoutOperationTheaterInput[]
    upsert?: SurgeryUpsertWithWhereUniqueWithoutOperationTheaterInput | SurgeryUpsertWithWhereUniqueWithoutOperationTheaterInput[]
    createMany?: SurgeryCreateManyOperationTheaterInputEnvelope
    set?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    disconnect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    delete?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    update?: SurgeryUpdateWithWhereUniqueWithoutOperationTheaterInput | SurgeryUpdateWithWhereUniqueWithoutOperationTheaterInput[]
    updateMany?: SurgeryUpdateManyWithWhereWithoutOperationTheaterInput | SurgeryUpdateManyWithWhereWithoutOperationTheaterInput[]
    deleteMany?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
  }

  export type OperationTheaterEquipmentUpdateManyWithoutOperationTheaterNestedInput = {
    create?: XOR<OperationTheaterEquipmentCreateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput> | OperationTheaterEquipmentCreateWithoutOperationTheaterInput[] | OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput | OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput[]
    upsert?: OperationTheaterEquipmentUpsertWithWhereUniqueWithoutOperationTheaterInput | OperationTheaterEquipmentUpsertWithWhereUniqueWithoutOperationTheaterInput[]
    createMany?: OperationTheaterEquipmentCreateManyOperationTheaterInputEnvelope
    set?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    disconnect?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    delete?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    connect?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    update?: OperationTheaterEquipmentUpdateWithWhereUniqueWithoutOperationTheaterInput | OperationTheaterEquipmentUpdateWithWhereUniqueWithoutOperationTheaterInput[]
    updateMany?: OperationTheaterEquipmentUpdateManyWithWhereWithoutOperationTheaterInput | OperationTheaterEquipmentUpdateManyWithWhereWithoutOperationTheaterInput[]
    deleteMany?: OperationTheaterEquipmentScalarWhereInput | OperationTheaterEquipmentScalarWhereInput[]
  }

  export type SurgeryUncheckedUpdateManyWithoutOperationTheaterNestedInput = {
    create?: XOR<SurgeryCreateWithoutOperationTheaterInput, SurgeryUncheckedCreateWithoutOperationTheaterInput> | SurgeryCreateWithoutOperationTheaterInput[] | SurgeryUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutOperationTheaterInput | SurgeryCreateOrConnectWithoutOperationTheaterInput[]
    upsert?: SurgeryUpsertWithWhereUniqueWithoutOperationTheaterInput | SurgeryUpsertWithWhereUniqueWithoutOperationTheaterInput[]
    createMany?: SurgeryCreateManyOperationTheaterInputEnvelope
    set?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    disconnect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    delete?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    update?: SurgeryUpdateWithWhereUniqueWithoutOperationTheaterInput | SurgeryUpdateWithWhereUniqueWithoutOperationTheaterInput[]
    updateMany?: SurgeryUpdateManyWithWhereWithoutOperationTheaterInput | SurgeryUpdateManyWithWhereWithoutOperationTheaterInput[]
    deleteMany?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
  }

  export type OperationTheaterEquipmentUncheckedUpdateManyWithoutOperationTheaterNestedInput = {
    create?: XOR<OperationTheaterEquipmentCreateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput> | OperationTheaterEquipmentCreateWithoutOperationTheaterInput[] | OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput[]
    connectOrCreate?: OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput | OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput[]
    upsert?: OperationTheaterEquipmentUpsertWithWhereUniqueWithoutOperationTheaterInput | OperationTheaterEquipmentUpsertWithWhereUniqueWithoutOperationTheaterInput[]
    createMany?: OperationTheaterEquipmentCreateManyOperationTheaterInputEnvelope
    set?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    disconnect?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    delete?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    connect?: OperationTheaterEquipmentWhereUniqueInput | OperationTheaterEquipmentWhereUniqueInput[]
    update?: OperationTheaterEquipmentUpdateWithWhereUniqueWithoutOperationTheaterInput | OperationTheaterEquipmentUpdateWithWhereUniqueWithoutOperationTheaterInput[]
    updateMany?: OperationTheaterEquipmentUpdateManyWithWhereWithoutOperationTheaterInput | OperationTheaterEquipmentUpdateManyWithWhereWithoutOperationTheaterInput[]
    deleteMany?: OperationTheaterEquipmentScalarWhereInput | OperationTheaterEquipmentScalarWhereInput[]
  }

  export type OperationTheaterCreateNestedOneWithoutSurgeriesInput = {
    create?: XOR<OperationTheaterCreateWithoutSurgeriesInput, OperationTheaterUncheckedCreateWithoutSurgeriesInput>
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutSurgeriesInput
    connect?: OperationTheaterWhereUniqueInput
  }

  export type OperationTheaterUpdateOneRequiredWithoutSurgeriesNestedInput = {
    create?: XOR<OperationTheaterCreateWithoutSurgeriesInput, OperationTheaterUncheckedCreateWithoutSurgeriesInput>
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutSurgeriesInput
    upsert?: OperationTheaterUpsertWithoutSurgeriesInput
    connect?: OperationTheaterWhereUniqueInput
    update?: XOR<XOR<OperationTheaterUpdateToOneWithWhereWithoutSurgeriesInput, OperationTheaterUpdateWithoutSurgeriesInput>, OperationTheaterUncheckedUpdateWithoutSurgeriesInput>
  }

  export type OperationTheaterCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<OperationTheaterCreateWithoutEquipmentsInput, OperationTheaterUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutEquipmentsInput
    connect?: OperationTheaterWhereUniqueInput
  }

  export type OperationTheaterUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<OperationTheaterCreateWithoutEquipmentsInput, OperationTheaterUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: OperationTheaterCreateOrConnectWithoutEquipmentsInput
    upsert?: OperationTheaterUpsertWithoutEquipmentsInput
    connect?: OperationTheaterWhereUniqueInput
    update?: XOR<XOR<OperationTheaterUpdateToOneWithWhereWithoutEquipmentsInput, OperationTheaterUpdateWithoutEquipmentsInput>, OperationTheaterUncheckedUpdateWithoutEquipmentsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AmbulanceServiceCreateNestedManyWithoutAmbulanceInput = {
    create?: XOR<AmbulanceServiceCreateWithoutAmbulanceInput, AmbulanceServiceUncheckedCreateWithoutAmbulanceInput> | AmbulanceServiceCreateWithoutAmbulanceInput[] | AmbulanceServiceUncheckedCreateWithoutAmbulanceInput[]
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutAmbulanceInput | AmbulanceServiceCreateOrConnectWithoutAmbulanceInput[]
    createMany?: AmbulanceServiceCreateManyAmbulanceInputEnvelope
    connect?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
  }

  export type AmbulanceServiceUncheckedCreateNestedManyWithoutAmbulanceInput = {
    create?: XOR<AmbulanceServiceCreateWithoutAmbulanceInput, AmbulanceServiceUncheckedCreateWithoutAmbulanceInput> | AmbulanceServiceCreateWithoutAmbulanceInput[] | AmbulanceServiceUncheckedCreateWithoutAmbulanceInput[]
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutAmbulanceInput | AmbulanceServiceCreateOrConnectWithoutAmbulanceInput[]
    createMany?: AmbulanceServiceCreateManyAmbulanceInputEnvelope
    connect?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
  }

  export type AmbulanceServiceUpdateManyWithoutAmbulanceNestedInput = {
    create?: XOR<AmbulanceServiceCreateWithoutAmbulanceInput, AmbulanceServiceUncheckedCreateWithoutAmbulanceInput> | AmbulanceServiceCreateWithoutAmbulanceInput[] | AmbulanceServiceUncheckedCreateWithoutAmbulanceInput[]
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutAmbulanceInput | AmbulanceServiceCreateOrConnectWithoutAmbulanceInput[]
    upsert?: AmbulanceServiceUpsertWithWhereUniqueWithoutAmbulanceInput | AmbulanceServiceUpsertWithWhereUniqueWithoutAmbulanceInput[]
    createMany?: AmbulanceServiceCreateManyAmbulanceInputEnvelope
    set?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    disconnect?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    delete?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    connect?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    update?: AmbulanceServiceUpdateWithWhereUniqueWithoutAmbulanceInput | AmbulanceServiceUpdateWithWhereUniqueWithoutAmbulanceInput[]
    updateMany?: AmbulanceServiceUpdateManyWithWhereWithoutAmbulanceInput | AmbulanceServiceUpdateManyWithWhereWithoutAmbulanceInput[]
    deleteMany?: AmbulanceServiceScalarWhereInput | AmbulanceServiceScalarWhereInput[]
  }

  export type AmbulanceServiceUncheckedUpdateManyWithoutAmbulanceNestedInput = {
    create?: XOR<AmbulanceServiceCreateWithoutAmbulanceInput, AmbulanceServiceUncheckedCreateWithoutAmbulanceInput> | AmbulanceServiceCreateWithoutAmbulanceInput[] | AmbulanceServiceUncheckedCreateWithoutAmbulanceInput[]
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutAmbulanceInput | AmbulanceServiceCreateOrConnectWithoutAmbulanceInput[]
    upsert?: AmbulanceServiceUpsertWithWhereUniqueWithoutAmbulanceInput | AmbulanceServiceUpsertWithWhereUniqueWithoutAmbulanceInput[]
    createMany?: AmbulanceServiceCreateManyAmbulanceInputEnvelope
    set?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    disconnect?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    delete?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    connect?: AmbulanceServiceWhereUniqueInput | AmbulanceServiceWhereUniqueInput[]
    update?: AmbulanceServiceUpdateWithWhereUniqueWithoutAmbulanceInput | AmbulanceServiceUpdateWithWhereUniqueWithoutAmbulanceInput[]
    updateMany?: AmbulanceServiceUpdateManyWithWhereWithoutAmbulanceInput | AmbulanceServiceUpdateManyWithWhereWithoutAmbulanceInput[]
    deleteMany?: AmbulanceServiceScalarWhereInput | AmbulanceServiceScalarWhereInput[]
  }

  export type AmbulanceCreateNestedOneWithoutAmbulanceServicesInput = {
    create?: XOR<AmbulanceCreateWithoutAmbulanceServicesInput, AmbulanceUncheckedCreateWithoutAmbulanceServicesInput>
    connectOrCreate?: AmbulanceCreateOrConnectWithoutAmbulanceServicesInput
    connect?: AmbulanceWhereUniqueInput
  }

  export type AmbulanceUpdateOneRequiredWithoutAmbulanceServicesNestedInput = {
    create?: XOR<AmbulanceCreateWithoutAmbulanceServicesInput, AmbulanceUncheckedCreateWithoutAmbulanceServicesInput>
    connectOrCreate?: AmbulanceCreateOrConnectWithoutAmbulanceServicesInput
    upsert?: AmbulanceUpsertWithoutAmbulanceServicesInput
    connect?: AmbulanceWhereUniqueInput
    update?: XOR<XOR<AmbulanceUpdateToOneWithWhereWithoutAmbulanceServicesInput, AmbulanceUpdateWithoutAmbulanceServicesInput>, AmbulanceUncheckedUpdateWithoutAmbulanceServicesInput>
  }

  export type UserCreateNestedOneWithoutBiometricDataInput = {
    create?: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiometricDataInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBiometricDataNestedInput = {
    create?: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiometricDataInput
    upsert?: UserUpsertWithoutBiometricDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBiometricDataInput, UserUpdateWithoutBiometricDataInput>, UserUncheckedUpdateWithoutBiometricDataInput>
  }

  export type UserCreateNestedOneWithoutAttendanceLogsInput = {
    create?: XOR<UserCreateWithoutAttendanceLogsInput, UserUncheckedCreateWithoutAttendanceLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendanceLogsNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceLogsInput, UserUncheckedCreateWithoutAttendanceLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceLogsInput
    upsert?: UserUpsertWithoutAttendanceLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceLogsInput, UserUpdateWithoutAttendanceLogsInput>, UserUncheckedUpdateWithoutAttendanceLogsInput>
  }

  export type UserCreateNestedOneWithoutDutyRostersInput = {
    create?: XOR<UserCreateWithoutDutyRostersInput, UserUncheckedCreateWithoutDutyRostersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDutyRostersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDutyRostersNestedInput = {
    create?: XOR<UserCreateWithoutDutyRostersInput, UserUncheckedCreateWithoutDutyRostersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDutyRostersInput
    upsert?: UserUpsertWithoutDutyRostersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDutyRostersInput, UserUpdateWithoutDutyRostersInput>, UserUncheckedUpdateWithoutDutyRostersInput>
  }

  export type PatientCreateNestedManyWithoutTpaInput = {
    create?: XOR<PatientCreateWithoutTpaInput, PatientUncheckedCreateWithoutTpaInput> | PatientCreateWithoutTpaInput[] | PatientUncheckedCreateWithoutTpaInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTpaInput | PatientCreateOrConnectWithoutTpaInput[]
    createMany?: PatientCreateManyTpaInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutTpaInput = {
    create?: XOR<PatientCreateWithoutTpaInput, PatientUncheckedCreateWithoutTpaInput> | PatientCreateWithoutTpaInput[] | PatientUncheckedCreateWithoutTpaInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTpaInput | PatientCreateOrConnectWithoutTpaInput[]
    createMany?: PatientCreateManyTpaInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PatientUpdateManyWithoutTpaNestedInput = {
    create?: XOR<PatientCreateWithoutTpaInput, PatientUncheckedCreateWithoutTpaInput> | PatientCreateWithoutTpaInput[] | PatientUncheckedCreateWithoutTpaInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTpaInput | PatientCreateOrConnectWithoutTpaInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutTpaInput | PatientUpsertWithWhereUniqueWithoutTpaInput[]
    createMany?: PatientCreateManyTpaInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutTpaInput | PatientUpdateWithWhereUniqueWithoutTpaInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutTpaInput | PatientUpdateManyWithWhereWithoutTpaInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutTpaNestedInput = {
    create?: XOR<PatientCreateWithoutTpaInput, PatientUncheckedCreateWithoutTpaInput> | PatientCreateWithoutTpaInput[] | PatientUncheckedCreateWithoutTpaInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTpaInput | PatientCreateOrConnectWithoutTpaInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutTpaInput | PatientUpsertWithWhereUniqueWithoutTpaInput[]
    createMany?: PatientCreateManyTpaInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutTpaInput | PatientUpdateWithWhereUniqueWithoutTpaInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutTpaInput | PatientUpdateManyWithWhereWithoutTpaInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type SalaryPaymentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type EmployeeDocumentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
  }

  export type PerformanceReviewCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
  }

  export type PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type SalaryPaymentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type EmployeeDocumentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    set?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    disconnect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    delete?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    update?: EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput | EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
  }

  export type PerformanceReviewUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput | PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    set?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    disconnect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    delete?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    update?: EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput | EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput | PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeCreateNestedOneWithoutSalaryPaymentsInput = {
    create?: XOR<EmployeeCreateWithoutSalaryPaymentsInput, EmployeeUncheckedCreateWithoutSalaryPaymentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalaryPaymentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutSalaryPaymentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutSalaryPaymentsInput, EmployeeUncheckedCreateWithoutSalaryPaymentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalaryPaymentsInput
    upsert?: EmployeeUpsertWithoutSalaryPaymentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSalaryPaymentsInput, EmployeeUpdateWithoutSalaryPaymentsInput>, EmployeeUncheckedUpdateWithoutSalaryPaymentsInput>
  }

  export type EmployeeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    upsert?: EmployeeUpsertWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDocumentsInput, EmployeeUpdateWithoutDocumentsInput>, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeCreateNestedOneWithoutPerformanceReviewsInput = {
    create?: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPerformanceReviewsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutPerformanceReviewsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPerformanceReviewsInput
    upsert?: EmployeeUpsertWithoutPerformanceReviewsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPerformanceReviewsInput, EmployeeUpdateWithoutPerformanceReviewsInput>, EmployeeUncheckedUpdateWithoutPerformanceReviewsInput>
  }

  export type PatientSubsidyCreateNestedManyWithoutSchemeInput = {
    create?: XOR<PatientSubsidyCreateWithoutSchemeInput, PatientSubsidyUncheckedCreateWithoutSchemeInput> | PatientSubsidyCreateWithoutSchemeInput[] | PatientSubsidyUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutSchemeInput | PatientSubsidyCreateOrConnectWithoutSchemeInput[]
    createMany?: PatientSubsidyCreateManySchemeInputEnvelope
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
  }

  export type SubsidyClaimCreateNestedManyWithoutSchemeInput = {
    create?: XOR<SubsidyClaimCreateWithoutSchemeInput, SubsidyClaimUncheckedCreateWithoutSchemeInput> | SubsidyClaimCreateWithoutSchemeInput[] | SubsidyClaimUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutSchemeInput | SubsidyClaimCreateOrConnectWithoutSchemeInput[]
    createMany?: SubsidyClaimCreateManySchemeInputEnvelope
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
  }

  export type PatientSubsidyUncheckedCreateNestedManyWithoutSchemeInput = {
    create?: XOR<PatientSubsidyCreateWithoutSchemeInput, PatientSubsidyUncheckedCreateWithoutSchemeInput> | PatientSubsidyCreateWithoutSchemeInput[] | PatientSubsidyUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutSchemeInput | PatientSubsidyCreateOrConnectWithoutSchemeInput[]
    createMany?: PatientSubsidyCreateManySchemeInputEnvelope
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
  }

  export type SubsidyClaimUncheckedCreateNestedManyWithoutSchemeInput = {
    create?: XOR<SubsidyClaimCreateWithoutSchemeInput, SubsidyClaimUncheckedCreateWithoutSchemeInput> | SubsidyClaimCreateWithoutSchemeInput[] | SubsidyClaimUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutSchemeInput | SubsidyClaimCreateOrConnectWithoutSchemeInput[]
    createMany?: SubsidyClaimCreateManySchemeInputEnvelope
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PatientSubsidyUpdateManyWithoutSchemeNestedInput = {
    create?: XOR<PatientSubsidyCreateWithoutSchemeInput, PatientSubsidyUncheckedCreateWithoutSchemeInput> | PatientSubsidyCreateWithoutSchemeInput[] | PatientSubsidyUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutSchemeInput | PatientSubsidyCreateOrConnectWithoutSchemeInput[]
    upsert?: PatientSubsidyUpsertWithWhereUniqueWithoutSchemeInput | PatientSubsidyUpsertWithWhereUniqueWithoutSchemeInput[]
    createMany?: PatientSubsidyCreateManySchemeInputEnvelope
    set?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    disconnect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    delete?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    update?: PatientSubsidyUpdateWithWhereUniqueWithoutSchemeInput | PatientSubsidyUpdateWithWhereUniqueWithoutSchemeInput[]
    updateMany?: PatientSubsidyUpdateManyWithWhereWithoutSchemeInput | PatientSubsidyUpdateManyWithWhereWithoutSchemeInput[]
    deleteMany?: PatientSubsidyScalarWhereInput | PatientSubsidyScalarWhereInput[]
  }

  export type SubsidyClaimUpdateManyWithoutSchemeNestedInput = {
    create?: XOR<SubsidyClaimCreateWithoutSchemeInput, SubsidyClaimUncheckedCreateWithoutSchemeInput> | SubsidyClaimCreateWithoutSchemeInput[] | SubsidyClaimUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutSchemeInput | SubsidyClaimCreateOrConnectWithoutSchemeInput[]
    upsert?: SubsidyClaimUpsertWithWhereUniqueWithoutSchemeInput | SubsidyClaimUpsertWithWhereUniqueWithoutSchemeInput[]
    createMany?: SubsidyClaimCreateManySchemeInputEnvelope
    set?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    disconnect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    delete?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    update?: SubsidyClaimUpdateWithWhereUniqueWithoutSchemeInput | SubsidyClaimUpdateWithWhereUniqueWithoutSchemeInput[]
    updateMany?: SubsidyClaimUpdateManyWithWhereWithoutSchemeInput | SubsidyClaimUpdateManyWithWhereWithoutSchemeInput[]
    deleteMany?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
  }

  export type PatientSubsidyUncheckedUpdateManyWithoutSchemeNestedInput = {
    create?: XOR<PatientSubsidyCreateWithoutSchemeInput, PatientSubsidyUncheckedCreateWithoutSchemeInput> | PatientSubsidyCreateWithoutSchemeInput[] | PatientSubsidyUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutSchemeInput | PatientSubsidyCreateOrConnectWithoutSchemeInput[]
    upsert?: PatientSubsidyUpsertWithWhereUniqueWithoutSchemeInput | PatientSubsidyUpsertWithWhereUniqueWithoutSchemeInput[]
    createMany?: PatientSubsidyCreateManySchemeInputEnvelope
    set?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    disconnect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    delete?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    connect?: PatientSubsidyWhereUniqueInput | PatientSubsidyWhereUniqueInput[]
    update?: PatientSubsidyUpdateWithWhereUniqueWithoutSchemeInput | PatientSubsidyUpdateWithWhereUniqueWithoutSchemeInput[]
    updateMany?: PatientSubsidyUpdateManyWithWhereWithoutSchemeInput | PatientSubsidyUpdateManyWithWhereWithoutSchemeInput[]
    deleteMany?: PatientSubsidyScalarWhereInput | PatientSubsidyScalarWhereInput[]
  }

  export type SubsidyClaimUncheckedUpdateManyWithoutSchemeNestedInput = {
    create?: XOR<SubsidyClaimCreateWithoutSchemeInput, SubsidyClaimUncheckedCreateWithoutSchemeInput> | SubsidyClaimCreateWithoutSchemeInput[] | SubsidyClaimUncheckedCreateWithoutSchemeInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutSchemeInput | SubsidyClaimCreateOrConnectWithoutSchemeInput[]
    upsert?: SubsidyClaimUpsertWithWhereUniqueWithoutSchemeInput | SubsidyClaimUpsertWithWhereUniqueWithoutSchemeInput[]
    createMany?: SubsidyClaimCreateManySchemeInputEnvelope
    set?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    disconnect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    delete?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    update?: SubsidyClaimUpdateWithWhereUniqueWithoutSchemeInput | SubsidyClaimUpdateWithWhereUniqueWithoutSchemeInput[]
    updateMany?: SubsidyClaimUpdateManyWithWhereWithoutSchemeInput | SubsidyClaimUpdateManyWithWhereWithoutSchemeInput[]
    deleteMany?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPatientSubsidiesInput = {
    create?: XOR<PatientCreateWithoutPatientSubsidiesInput, PatientUncheckedCreateWithoutPatientSubsidiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientSubsidiesInput
    connect?: PatientWhereUniqueInput
  }

  export type SubsidySchemeCreateNestedOneWithoutPatientSubsidiesInput = {
    create?: XOR<SubsidySchemeCreateWithoutPatientSubsidiesInput, SubsidySchemeUncheckedCreateWithoutPatientSubsidiesInput>
    connectOrCreate?: SubsidySchemeCreateOrConnectWithoutPatientSubsidiesInput
    connect?: SubsidySchemeWhereUniqueInput
  }

  export type SubsidyClaimCreateNestedManyWithoutPatientSubsidyInput = {
    create?: XOR<SubsidyClaimCreateWithoutPatientSubsidyInput, SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput> | SubsidyClaimCreateWithoutPatientSubsidyInput[] | SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput | SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput[]
    createMany?: SubsidyClaimCreateManyPatientSubsidyInputEnvelope
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
  }

  export type SubsidyClaimUncheckedCreateNestedManyWithoutPatientSubsidyInput = {
    create?: XOR<SubsidyClaimCreateWithoutPatientSubsidyInput, SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput> | SubsidyClaimCreateWithoutPatientSubsidyInput[] | SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput | SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput[]
    createMany?: SubsidyClaimCreateManyPatientSubsidyInputEnvelope
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutPatientSubsidiesNestedInput = {
    create?: XOR<PatientCreateWithoutPatientSubsidiesInput, PatientUncheckedCreateWithoutPatientSubsidiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientSubsidiesInput
    upsert?: PatientUpsertWithoutPatientSubsidiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPatientSubsidiesInput, PatientUpdateWithoutPatientSubsidiesInput>, PatientUncheckedUpdateWithoutPatientSubsidiesInput>
  }

  export type SubsidySchemeUpdateOneRequiredWithoutPatientSubsidiesNestedInput = {
    create?: XOR<SubsidySchemeCreateWithoutPatientSubsidiesInput, SubsidySchemeUncheckedCreateWithoutPatientSubsidiesInput>
    connectOrCreate?: SubsidySchemeCreateOrConnectWithoutPatientSubsidiesInput
    upsert?: SubsidySchemeUpsertWithoutPatientSubsidiesInput
    connect?: SubsidySchemeWhereUniqueInput
    update?: XOR<XOR<SubsidySchemeUpdateToOneWithWhereWithoutPatientSubsidiesInput, SubsidySchemeUpdateWithoutPatientSubsidiesInput>, SubsidySchemeUncheckedUpdateWithoutPatientSubsidiesInput>
  }

  export type SubsidyClaimUpdateManyWithoutPatientSubsidyNestedInput = {
    create?: XOR<SubsidyClaimCreateWithoutPatientSubsidyInput, SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput> | SubsidyClaimCreateWithoutPatientSubsidyInput[] | SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput | SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput[]
    upsert?: SubsidyClaimUpsertWithWhereUniqueWithoutPatientSubsidyInput | SubsidyClaimUpsertWithWhereUniqueWithoutPatientSubsidyInput[]
    createMany?: SubsidyClaimCreateManyPatientSubsidyInputEnvelope
    set?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    disconnect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    delete?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    update?: SubsidyClaimUpdateWithWhereUniqueWithoutPatientSubsidyInput | SubsidyClaimUpdateWithWhereUniqueWithoutPatientSubsidyInput[]
    updateMany?: SubsidyClaimUpdateManyWithWhereWithoutPatientSubsidyInput | SubsidyClaimUpdateManyWithWhereWithoutPatientSubsidyInput[]
    deleteMany?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
  }

  export type SubsidyClaimUncheckedUpdateManyWithoutPatientSubsidyNestedInput = {
    create?: XOR<SubsidyClaimCreateWithoutPatientSubsidyInput, SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput> | SubsidyClaimCreateWithoutPatientSubsidyInput[] | SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput[]
    connectOrCreate?: SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput | SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput[]
    upsert?: SubsidyClaimUpsertWithWhereUniqueWithoutPatientSubsidyInput | SubsidyClaimUpsertWithWhereUniqueWithoutPatientSubsidyInput[]
    createMany?: SubsidyClaimCreateManyPatientSubsidyInputEnvelope
    set?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    disconnect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    delete?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    connect?: SubsidyClaimWhereUniqueInput | SubsidyClaimWhereUniqueInput[]
    update?: SubsidyClaimUpdateWithWhereUniqueWithoutPatientSubsidyInput | SubsidyClaimUpdateWithWhereUniqueWithoutPatientSubsidyInput[]
    updateMany?: SubsidyClaimUpdateManyWithWhereWithoutPatientSubsidyInput | SubsidyClaimUpdateManyWithWhereWithoutPatientSubsidyInput[]
    deleteMany?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
  }

  export type PatientSubsidyCreateNestedOneWithoutSubsidyClaimsInput = {
    create?: XOR<PatientSubsidyCreateWithoutSubsidyClaimsInput, PatientSubsidyUncheckedCreateWithoutSubsidyClaimsInput>
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutSubsidyClaimsInput
    connect?: PatientSubsidyWhereUniqueInput
  }

  export type SubsidySchemeCreateNestedOneWithoutSubsidyClaimsInput = {
    create?: XOR<SubsidySchemeCreateWithoutSubsidyClaimsInput, SubsidySchemeUncheckedCreateWithoutSubsidyClaimsInput>
    connectOrCreate?: SubsidySchemeCreateOrConnectWithoutSubsidyClaimsInput
    connect?: SubsidySchemeWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutSubsidyClaimsInput = {
    create?: XOR<InvoiceCreateWithoutSubsidyClaimsInput, InvoiceUncheckedCreateWithoutSubsidyClaimsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubsidyClaimsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PatientSubsidyUpdateOneRequiredWithoutSubsidyClaimsNestedInput = {
    create?: XOR<PatientSubsidyCreateWithoutSubsidyClaimsInput, PatientSubsidyUncheckedCreateWithoutSubsidyClaimsInput>
    connectOrCreate?: PatientSubsidyCreateOrConnectWithoutSubsidyClaimsInput
    upsert?: PatientSubsidyUpsertWithoutSubsidyClaimsInput
    connect?: PatientSubsidyWhereUniqueInput
    update?: XOR<XOR<PatientSubsidyUpdateToOneWithWhereWithoutSubsidyClaimsInput, PatientSubsidyUpdateWithoutSubsidyClaimsInput>, PatientSubsidyUncheckedUpdateWithoutSubsidyClaimsInput>
  }

  export type SubsidySchemeUpdateOneRequiredWithoutSubsidyClaimsNestedInput = {
    create?: XOR<SubsidySchemeCreateWithoutSubsidyClaimsInput, SubsidySchemeUncheckedCreateWithoutSubsidyClaimsInput>
    connectOrCreate?: SubsidySchemeCreateOrConnectWithoutSubsidyClaimsInput
    upsert?: SubsidySchemeUpsertWithoutSubsidyClaimsInput
    connect?: SubsidySchemeWhereUniqueInput
    update?: XOR<XOR<SubsidySchemeUpdateToOneWithWhereWithoutSubsidyClaimsInput, SubsidySchemeUpdateWithoutSubsidyClaimsInput>, SubsidySchemeUncheckedUpdateWithoutSubsidyClaimsInput>
  }

  export type InvoiceUpdateOneWithoutSubsidyClaimsNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubsidyClaimsInput, InvoiceUncheckedCreateWithoutSubsidyClaimsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubsidyClaimsInput
    upsert?: InvoiceUpsertWithoutSubsidyClaimsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutSubsidyClaimsInput, InvoiceUpdateWithoutSubsidyClaimsInput>, InvoiceUncheckedUpdateWithoutSubsidyClaimsInput>
  }

  export type CleaningTaskCreateNestedManyWithoutAreaInput = {
    create?: XOR<CleaningTaskCreateWithoutAreaInput, CleaningTaskUncheckedCreateWithoutAreaInput> | CleaningTaskCreateWithoutAreaInput[] | CleaningTaskUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAreaInput | CleaningTaskCreateOrConnectWithoutAreaInput[]
    createMany?: CleaningTaskCreateManyAreaInputEnvelope
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
  }

  export type CleaningTaskUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<CleaningTaskCreateWithoutAreaInput, CleaningTaskUncheckedCreateWithoutAreaInput> | CleaningTaskCreateWithoutAreaInput[] | CleaningTaskUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAreaInput | CleaningTaskCreateOrConnectWithoutAreaInput[]
    createMany?: CleaningTaskCreateManyAreaInputEnvelope
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
  }

  export type CleaningTaskUpdateManyWithoutAreaNestedInput = {
    create?: XOR<CleaningTaskCreateWithoutAreaInput, CleaningTaskUncheckedCreateWithoutAreaInput> | CleaningTaskCreateWithoutAreaInput[] | CleaningTaskUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAreaInput | CleaningTaskCreateOrConnectWithoutAreaInput[]
    upsert?: CleaningTaskUpsertWithWhereUniqueWithoutAreaInput | CleaningTaskUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: CleaningTaskCreateManyAreaInputEnvelope
    set?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    disconnect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    delete?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    update?: CleaningTaskUpdateWithWhereUniqueWithoutAreaInput | CleaningTaskUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: CleaningTaskUpdateManyWithWhereWithoutAreaInput | CleaningTaskUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: CleaningTaskScalarWhereInput | CleaningTaskScalarWhereInput[]
  }

  export type CleaningTaskUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<CleaningTaskCreateWithoutAreaInput, CleaningTaskUncheckedCreateWithoutAreaInput> | CleaningTaskCreateWithoutAreaInput[] | CleaningTaskUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAreaInput | CleaningTaskCreateOrConnectWithoutAreaInput[]
    upsert?: CleaningTaskUpsertWithWhereUniqueWithoutAreaInput | CleaningTaskUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: CleaningTaskCreateManyAreaInputEnvelope
    set?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    disconnect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    delete?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    update?: CleaningTaskUpdateWithWhereUniqueWithoutAreaInput | CleaningTaskUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: CleaningTaskUpdateManyWithWhereWithoutAreaInput | CleaningTaskUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: CleaningTaskScalarWhereInput | CleaningTaskScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHousekeepingStaffInput = {
    create?: XOR<UserCreateWithoutHousekeepingStaffInput, UserUncheckedCreateWithoutHousekeepingStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutHousekeepingStaffInput
    connect?: UserWhereUniqueInput
  }

  export type CleaningTaskCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<CleaningTaskCreateWithoutAssignedToInput, CleaningTaskUncheckedCreateWithoutAssignedToInput> | CleaningTaskCreateWithoutAssignedToInput[] | CleaningTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAssignedToInput | CleaningTaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: CleaningTaskCreateManyAssignedToInputEnvelope
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
  }

  export type CleaningVerificationCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<CleaningVerificationCreateWithoutVerifiedByInput, CleaningVerificationUncheckedCreateWithoutVerifiedByInput> | CleaningVerificationCreateWithoutVerifiedByInput[] | CleaningVerificationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutVerifiedByInput | CleaningVerificationCreateOrConnectWithoutVerifiedByInput[]
    createMany?: CleaningVerificationCreateManyVerifiedByInputEnvelope
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
  }

  export type CleaningSupplyRequestCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<CleaningSupplyRequestCreateWithoutRequestedByInput, CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput> | CleaningSupplyRequestCreateWithoutRequestedByInput[] | CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput | CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: CleaningSupplyRequestCreateManyRequestedByInputEnvelope
    connect?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
  }

  export type CleaningTaskUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<CleaningTaskCreateWithoutAssignedToInput, CleaningTaskUncheckedCreateWithoutAssignedToInput> | CleaningTaskCreateWithoutAssignedToInput[] | CleaningTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAssignedToInput | CleaningTaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: CleaningTaskCreateManyAssignedToInputEnvelope
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
  }

  export type CleaningVerificationUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<CleaningVerificationCreateWithoutVerifiedByInput, CleaningVerificationUncheckedCreateWithoutVerifiedByInput> | CleaningVerificationCreateWithoutVerifiedByInput[] | CleaningVerificationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutVerifiedByInput | CleaningVerificationCreateOrConnectWithoutVerifiedByInput[]
    createMany?: CleaningVerificationCreateManyVerifiedByInputEnvelope
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
  }

  export type CleaningSupplyRequestUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<CleaningSupplyRequestCreateWithoutRequestedByInput, CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput> | CleaningSupplyRequestCreateWithoutRequestedByInput[] | CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput | CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: CleaningSupplyRequestCreateManyRequestedByInputEnvelope
    connect?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHousekeepingStaffNestedInput = {
    create?: XOR<UserCreateWithoutHousekeepingStaffInput, UserUncheckedCreateWithoutHousekeepingStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutHousekeepingStaffInput
    upsert?: UserUpsertWithoutHousekeepingStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHousekeepingStaffInput, UserUpdateWithoutHousekeepingStaffInput>, UserUncheckedUpdateWithoutHousekeepingStaffInput>
  }

  export type CleaningTaskUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<CleaningTaskCreateWithoutAssignedToInput, CleaningTaskUncheckedCreateWithoutAssignedToInput> | CleaningTaskCreateWithoutAssignedToInput[] | CleaningTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAssignedToInput | CleaningTaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: CleaningTaskUpsertWithWhereUniqueWithoutAssignedToInput | CleaningTaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: CleaningTaskCreateManyAssignedToInputEnvelope
    set?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    disconnect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    delete?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    update?: CleaningTaskUpdateWithWhereUniqueWithoutAssignedToInput | CleaningTaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: CleaningTaskUpdateManyWithWhereWithoutAssignedToInput | CleaningTaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: CleaningTaskScalarWhereInput | CleaningTaskScalarWhereInput[]
  }

  export type CleaningVerificationUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<CleaningVerificationCreateWithoutVerifiedByInput, CleaningVerificationUncheckedCreateWithoutVerifiedByInput> | CleaningVerificationCreateWithoutVerifiedByInput[] | CleaningVerificationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutVerifiedByInput | CleaningVerificationCreateOrConnectWithoutVerifiedByInput[]
    upsert?: CleaningVerificationUpsertWithWhereUniqueWithoutVerifiedByInput | CleaningVerificationUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: CleaningVerificationCreateManyVerifiedByInputEnvelope
    set?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    disconnect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    delete?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    update?: CleaningVerificationUpdateWithWhereUniqueWithoutVerifiedByInput | CleaningVerificationUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: CleaningVerificationUpdateManyWithWhereWithoutVerifiedByInput | CleaningVerificationUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: CleaningVerificationScalarWhereInput | CleaningVerificationScalarWhereInput[]
  }

  export type CleaningSupplyRequestUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<CleaningSupplyRequestCreateWithoutRequestedByInput, CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput> | CleaningSupplyRequestCreateWithoutRequestedByInput[] | CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput | CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: CleaningSupplyRequestUpsertWithWhereUniqueWithoutRequestedByInput | CleaningSupplyRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: CleaningSupplyRequestCreateManyRequestedByInputEnvelope
    set?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    disconnect?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    delete?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    connect?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    update?: CleaningSupplyRequestUpdateWithWhereUniqueWithoutRequestedByInput | CleaningSupplyRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: CleaningSupplyRequestUpdateManyWithWhereWithoutRequestedByInput | CleaningSupplyRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: CleaningSupplyRequestScalarWhereInput | CleaningSupplyRequestScalarWhereInput[]
  }

  export type CleaningTaskUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<CleaningTaskCreateWithoutAssignedToInput, CleaningTaskUncheckedCreateWithoutAssignedToInput> | CleaningTaskCreateWithoutAssignedToInput[] | CleaningTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutAssignedToInput | CleaningTaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: CleaningTaskUpsertWithWhereUniqueWithoutAssignedToInput | CleaningTaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: CleaningTaskCreateManyAssignedToInputEnvelope
    set?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    disconnect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    delete?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    connect?: CleaningTaskWhereUniqueInput | CleaningTaskWhereUniqueInput[]
    update?: CleaningTaskUpdateWithWhereUniqueWithoutAssignedToInput | CleaningTaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: CleaningTaskUpdateManyWithWhereWithoutAssignedToInput | CleaningTaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: CleaningTaskScalarWhereInput | CleaningTaskScalarWhereInput[]
  }

  export type CleaningVerificationUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<CleaningVerificationCreateWithoutVerifiedByInput, CleaningVerificationUncheckedCreateWithoutVerifiedByInput> | CleaningVerificationCreateWithoutVerifiedByInput[] | CleaningVerificationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutVerifiedByInput | CleaningVerificationCreateOrConnectWithoutVerifiedByInput[]
    upsert?: CleaningVerificationUpsertWithWhereUniqueWithoutVerifiedByInput | CleaningVerificationUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: CleaningVerificationCreateManyVerifiedByInputEnvelope
    set?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    disconnect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    delete?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    update?: CleaningVerificationUpdateWithWhereUniqueWithoutVerifiedByInput | CleaningVerificationUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: CleaningVerificationUpdateManyWithWhereWithoutVerifiedByInput | CleaningVerificationUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: CleaningVerificationScalarWhereInput | CleaningVerificationScalarWhereInput[]
  }

  export type CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<CleaningSupplyRequestCreateWithoutRequestedByInput, CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput> | CleaningSupplyRequestCreateWithoutRequestedByInput[] | CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput | CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: CleaningSupplyRequestUpsertWithWhereUniqueWithoutRequestedByInput | CleaningSupplyRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: CleaningSupplyRequestCreateManyRequestedByInputEnvelope
    set?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    disconnect?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    delete?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    connect?: CleaningSupplyRequestWhereUniqueInput | CleaningSupplyRequestWhereUniqueInput[]
    update?: CleaningSupplyRequestUpdateWithWhereUniqueWithoutRequestedByInput | CleaningSupplyRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: CleaningSupplyRequestUpdateManyWithWhereWithoutRequestedByInput | CleaningSupplyRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: CleaningSupplyRequestScalarWhereInput | CleaningSupplyRequestScalarWhereInput[]
  }

  export type HousekeepingAreaCreateNestedOneWithoutCleaningTasksInput = {
    create?: XOR<HousekeepingAreaCreateWithoutCleaningTasksInput, HousekeepingAreaUncheckedCreateWithoutCleaningTasksInput>
    connectOrCreate?: HousekeepingAreaCreateOrConnectWithoutCleaningTasksInput
    connect?: HousekeepingAreaWhereUniqueInput
  }

  export type HousekeepingStaffCreateNestedOneWithoutCleaningTasksInput = {
    create?: XOR<HousekeepingStaffCreateWithoutCleaningTasksInput, HousekeepingStaffUncheckedCreateWithoutCleaningTasksInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutCleaningTasksInput
    connect?: HousekeepingStaffWhereUniqueInput
  }

  export type CleaningVerificationCreateNestedManyWithoutTaskInput = {
    create?: XOR<CleaningVerificationCreateWithoutTaskInput, CleaningVerificationUncheckedCreateWithoutTaskInput> | CleaningVerificationCreateWithoutTaskInput[] | CleaningVerificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutTaskInput | CleaningVerificationCreateOrConnectWithoutTaskInput[]
    createMany?: CleaningVerificationCreateManyTaskInputEnvelope
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
  }

  export type CleaningVerificationUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CleaningVerificationCreateWithoutTaskInput, CleaningVerificationUncheckedCreateWithoutTaskInput> | CleaningVerificationCreateWithoutTaskInput[] | CleaningVerificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutTaskInput | CleaningVerificationCreateOrConnectWithoutTaskInput[]
    createMany?: CleaningVerificationCreateManyTaskInputEnvelope
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
  }

  export type HousekeepingAreaUpdateOneRequiredWithoutCleaningTasksNestedInput = {
    create?: XOR<HousekeepingAreaCreateWithoutCleaningTasksInput, HousekeepingAreaUncheckedCreateWithoutCleaningTasksInput>
    connectOrCreate?: HousekeepingAreaCreateOrConnectWithoutCleaningTasksInput
    upsert?: HousekeepingAreaUpsertWithoutCleaningTasksInput
    connect?: HousekeepingAreaWhereUniqueInput
    update?: XOR<XOR<HousekeepingAreaUpdateToOneWithWhereWithoutCleaningTasksInput, HousekeepingAreaUpdateWithoutCleaningTasksInput>, HousekeepingAreaUncheckedUpdateWithoutCleaningTasksInput>
  }

  export type HousekeepingStaffUpdateOneWithoutCleaningTasksNestedInput = {
    create?: XOR<HousekeepingStaffCreateWithoutCleaningTasksInput, HousekeepingStaffUncheckedCreateWithoutCleaningTasksInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutCleaningTasksInput
    upsert?: HousekeepingStaffUpsertWithoutCleaningTasksInput
    disconnect?: HousekeepingStaffWhereInput | boolean
    delete?: HousekeepingStaffWhereInput | boolean
    connect?: HousekeepingStaffWhereUniqueInput
    update?: XOR<XOR<HousekeepingStaffUpdateToOneWithWhereWithoutCleaningTasksInput, HousekeepingStaffUpdateWithoutCleaningTasksInput>, HousekeepingStaffUncheckedUpdateWithoutCleaningTasksInput>
  }

  export type CleaningVerificationUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CleaningVerificationCreateWithoutTaskInput, CleaningVerificationUncheckedCreateWithoutTaskInput> | CleaningVerificationCreateWithoutTaskInput[] | CleaningVerificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutTaskInput | CleaningVerificationCreateOrConnectWithoutTaskInput[]
    upsert?: CleaningVerificationUpsertWithWhereUniqueWithoutTaskInput | CleaningVerificationUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CleaningVerificationCreateManyTaskInputEnvelope
    set?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    disconnect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    delete?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    update?: CleaningVerificationUpdateWithWhereUniqueWithoutTaskInput | CleaningVerificationUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CleaningVerificationUpdateManyWithWhereWithoutTaskInput | CleaningVerificationUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CleaningVerificationScalarWhereInput | CleaningVerificationScalarWhereInput[]
  }

  export type CleaningVerificationUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CleaningVerificationCreateWithoutTaskInput, CleaningVerificationUncheckedCreateWithoutTaskInput> | CleaningVerificationCreateWithoutTaskInput[] | CleaningVerificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CleaningVerificationCreateOrConnectWithoutTaskInput | CleaningVerificationCreateOrConnectWithoutTaskInput[]
    upsert?: CleaningVerificationUpsertWithWhereUniqueWithoutTaskInput | CleaningVerificationUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CleaningVerificationCreateManyTaskInputEnvelope
    set?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    disconnect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    delete?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    connect?: CleaningVerificationWhereUniqueInput | CleaningVerificationWhereUniqueInput[]
    update?: CleaningVerificationUpdateWithWhereUniqueWithoutTaskInput | CleaningVerificationUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CleaningVerificationUpdateManyWithWhereWithoutTaskInput | CleaningVerificationUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CleaningVerificationScalarWhereInput | CleaningVerificationScalarWhereInput[]
  }

  export type CleaningTaskCreateNestedOneWithoutVerificationsInput = {
    create?: XOR<CleaningTaskCreateWithoutVerificationsInput, CleaningTaskUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutVerificationsInput
    connect?: CleaningTaskWhereUniqueInput
  }

  export type HousekeepingStaffCreateNestedOneWithoutCleaningVerificationsInput = {
    create?: XOR<HousekeepingStaffCreateWithoutCleaningVerificationsInput, HousekeepingStaffUncheckedCreateWithoutCleaningVerificationsInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutCleaningVerificationsInput
    connect?: HousekeepingStaffWhereUniqueInput
  }

  export type CleaningTaskUpdateOneRequiredWithoutVerificationsNestedInput = {
    create?: XOR<CleaningTaskCreateWithoutVerificationsInput, CleaningTaskUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: CleaningTaskCreateOrConnectWithoutVerificationsInput
    upsert?: CleaningTaskUpsertWithoutVerificationsInput
    connect?: CleaningTaskWhereUniqueInput
    update?: XOR<XOR<CleaningTaskUpdateToOneWithWhereWithoutVerificationsInput, CleaningTaskUpdateWithoutVerificationsInput>, CleaningTaskUncheckedUpdateWithoutVerificationsInput>
  }

  export type HousekeepingStaffUpdateOneRequiredWithoutCleaningVerificationsNestedInput = {
    create?: XOR<HousekeepingStaffCreateWithoutCleaningVerificationsInput, HousekeepingStaffUncheckedCreateWithoutCleaningVerificationsInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutCleaningVerificationsInput
    upsert?: HousekeepingStaffUpsertWithoutCleaningVerificationsInput
    connect?: HousekeepingStaffWhereUniqueInput
    update?: XOR<XOR<HousekeepingStaffUpdateToOneWithWhereWithoutCleaningVerificationsInput, HousekeepingStaffUpdateWithoutCleaningVerificationsInput>, HousekeepingStaffUncheckedUpdateWithoutCleaningVerificationsInput>
  }

  export type CleaningSupplyRequestItemCreateNestedManyWithoutSupplyInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput> | CleaningSupplyRequestItemCreateWithoutSupplyInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput | CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput[]
    createMany?: CleaningSupplyRequestItemCreateManySupplyInputEnvelope
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
  }

  export type CleaningSupplyRequestItemUncheckedCreateNestedManyWithoutSupplyInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput> | CleaningSupplyRequestItemCreateWithoutSupplyInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput | CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput[]
    createMany?: CleaningSupplyRequestItemCreateManySupplyInputEnvelope
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
  }

  export type CleaningSupplyRequestItemUpdateManyWithoutSupplyNestedInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput> | CleaningSupplyRequestItemCreateWithoutSupplyInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput | CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput[]
    upsert?: CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutSupplyInput | CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutSupplyInput[]
    createMany?: CleaningSupplyRequestItemCreateManySupplyInputEnvelope
    set?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    disconnect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    delete?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    update?: CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutSupplyInput | CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutSupplyInput[]
    updateMany?: CleaningSupplyRequestItemUpdateManyWithWhereWithoutSupplyInput | CleaningSupplyRequestItemUpdateManyWithWhereWithoutSupplyInput[]
    deleteMany?: CleaningSupplyRequestItemScalarWhereInput | CleaningSupplyRequestItemScalarWhereInput[]
  }

  export type CleaningSupplyRequestItemUncheckedUpdateManyWithoutSupplyNestedInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput> | CleaningSupplyRequestItemCreateWithoutSupplyInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput | CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput[]
    upsert?: CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutSupplyInput | CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutSupplyInput[]
    createMany?: CleaningSupplyRequestItemCreateManySupplyInputEnvelope
    set?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    disconnect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    delete?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    update?: CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutSupplyInput | CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutSupplyInput[]
    updateMany?: CleaningSupplyRequestItemUpdateManyWithWhereWithoutSupplyInput | CleaningSupplyRequestItemUpdateManyWithWhereWithoutSupplyInput[]
    deleteMany?: CleaningSupplyRequestItemScalarWhereInput | CleaningSupplyRequestItemScalarWhereInput[]
  }

  export type HousekeepingStaffCreateNestedOneWithoutSupplyRequestsInput = {
    create?: XOR<HousekeepingStaffCreateWithoutSupplyRequestsInput, HousekeepingStaffUncheckedCreateWithoutSupplyRequestsInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutSupplyRequestsInput
    connect?: HousekeepingStaffWhereUniqueInput
  }

  export type CleaningSupplyRequestItemCreateNestedManyWithoutRequestInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutRequestInput, CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput> | CleaningSupplyRequestItemCreateWithoutRequestInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput | CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput[]
    createMany?: CleaningSupplyRequestItemCreateManyRequestInputEnvelope
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
  }

  export type CleaningSupplyRequestItemUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutRequestInput, CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput> | CleaningSupplyRequestItemCreateWithoutRequestInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput | CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput[]
    createMany?: CleaningSupplyRequestItemCreateManyRequestInputEnvelope
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
  }

  export type HousekeepingStaffUpdateOneRequiredWithoutSupplyRequestsNestedInput = {
    create?: XOR<HousekeepingStaffCreateWithoutSupplyRequestsInput, HousekeepingStaffUncheckedCreateWithoutSupplyRequestsInput>
    connectOrCreate?: HousekeepingStaffCreateOrConnectWithoutSupplyRequestsInput
    upsert?: HousekeepingStaffUpsertWithoutSupplyRequestsInput
    connect?: HousekeepingStaffWhereUniqueInput
    update?: XOR<XOR<HousekeepingStaffUpdateToOneWithWhereWithoutSupplyRequestsInput, HousekeepingStaffUpdateWithoutSupplyRequestsInput>, HousekeepingStaffUncheckedUpdateWithoutSupplyRequestsInput>
  }

  export type CleaningSupplyRequestItemUpdateManyWithoutRequestNestedInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutRequestInput, CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput> | CleaningSupplyRequestItemCreateWithoutRequestInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput | CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput[]
    upsert?: CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutRequestInput | CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: CleaningSupplyRequestItemCreateManyRequestInputEnvelope
    set?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    disconnect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    delete?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    update?: CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutRequestInput | CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: CleaningSupplyRequestItemUpdateManyWithWhereWithoutRequestInput | CleaningSupplyRequestItemUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: CleaningSupplyRequestItemScalarWhereInput | CleaningSupplyRequestItemScalarWhereInput[]
  }

  export type CleaningSupplyRequestItemUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<CleaningSupplyRequestItemCreateWithoutRequestInput, CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput> | CleaningSupplyRequestItemCreateWithoutRequestInput[] | CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput | CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput[]
    upsert?: CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutRequestInput | CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: CleaningSupplyRequestItemCreateManyRequestInputEnvelope
    set?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    disconnect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    delete?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    connect?: CleaningSupplyRequestItemWhereUniqueInput | CleaningSupplyRequestItemWhereUniqueInput[]
    update?: CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutRequestInput | CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: CleaningSupplyRequestItemUpdateManyWithWhereWithoutRequestInput | CleaningSupplyRequestItemUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: CleaningSupplyRequestItemScalarWhereInput | CleaningSupplyRequestItemScalarWhereInput[]
  }

  export type CleaningSupplyRequestCreateNestedOneWithoutRequestItemsInput = {
    create?: XOR<CleaningSupplyRequestCreateWithoutRequestItemsInput, CleaningSupplyRequestUncheckedCreateWithoutRequestItemsInput>
    connectOrCreate?: CleaningSupplyRequestCreateOrConnectWithoutRequestItemsInput
    connect?: CleaningSupplyRequestWhereUniqueInput
  }

  export type CleaningSupplyCreateNestedOneWithoutSupplyRequestsInput = {
    create?: XOR<CleaningSupplyCreateWithoutSupplyRequestsInput, CleaningSupplyUncheckedCreateWithoutSupplyRequestsInput>
    connectOrCreate?: CleaningSupplyCreateOrConnectWithoutSupplyRequestsInput
    connect?: CleaningSupplyWhereUniqueInput
  }

  export type CleaningSupplyRequestUpdateOneRequiredWithoutRequestItemsNestedInput = {
    create?: XOR<CleaningSupplyRequestCreateWithoutRequestItemsInput, CleaningSupplyRequestUncheckedCreateWithoutRequestItemsInput>
    connectOrCreate?: CleaningSupplyRequestCreateOrConnectWithoutRequestItemsInput
    upsert?: CleaningSupplyRequestUpsertWithoutRequestItemsInput
    connect?: CleaningSupplyRequestWhereUniqueInput
    update?: XOR<XOR<CleaningSupplyRequestUpdateToOneWithWhereWithoutRequestItemsInput, CleaningSupplyRequestUpdateWithoutRequestItemsInput>, CleaningSupplyRequestUncheckedUpdateWithoutRequestItemsInput>
  }

  export type CleaningSupplyUpdateOneRequiredWithoutSupplyRequestsNestedInput = {
    create?: XOR<CleaningSupplyCreateWithoutSupplyRequestsInput, CleaningSupplyUncheckedCreateWithoutSupplyRequestsInput>
    connectOrCreate?: CleaningSupplyCreateOrConnectWithoutSupplyRequestsInput
    upsert?: CleaningSupplyUpsertWithoutSupplyRequestsInput
    connect?: CleaningSupplyWhereUniqueInput
    update?: XOR<XOR<CleaningSupplyUpdateToOneWithWhereWithoutSupplyRequestsInput, CleaningSupplyUpdateWithoutSupplyRequestsInput>, CleaningSupplyUncheckedUpdateWithoutSupplyRequestsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserCreateWithoutRoleInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    roleId?: IntNullableFilter<"User"> | number | null
    status?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    provider?: StringNullableFilter<"User"> | string | null
    providerId?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type PasswordResetCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type DoctorCreateWithoutUserInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    labReports?: LabReportCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutUserInput = {
    id?: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutUserInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
  }

  export type PatientCreateWithoutUserInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutUserInput = {
    id?: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUserInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type NurseCreateWithoutUserInput = {
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vitalSigns?: VitalSignCreateNestedManyWithoutNurseInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutNurseInput
  }

  export type NurseUncheckedCreateWithoutUserInput = {
    id?: number
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutNurseInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutNurseInput
  }

  export type NurseCreateOrConnectWithoutUserInput = {
    where: NurseWhereUniqueInput
    create: XOR<NurseCreateWithoutUserInput, NurseUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateWithoutPatientInput = {
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientDetails: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPatientInput = {
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPatientInput = {
    id?: number
    invoiceId: number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentCreateManyPatientInputEnvelope = {
    data: PaymentCreateManyPatientInput | PaymentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BiometricDataCreateWithoutUserInput = {
    biometricId: string
    fingerprint?: string | null
    faceData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataUncheckedCreateWithoutUserInput = {
    id?: number
    biometricId: string
    fingerprint?: string | null
    faceData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataCreateOrConnectWithoutUserInput = {
    where: BiometricDataWhereUniqueInput
    create: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
  }

  export type AttendanceLogCreateWithoutUserInput = {
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status: string
    deviceId?: string | null
    verificationMode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUncheckedCreateWithoutUserInput = {
    id?: number
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status: string
    deviceId?: string | null
    verificationMode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogCreateOrConnectWithoutUserInput = {
    where: AttendanceLogWhereUniqueInput
    create: XOR<AttendanceLogCreateWithoutUserInput, AttendanceLogUncheckedCreateWithoutUserInput>
  }

  export type AttendanceLogCreateManyUserInputEnvelope = {
    data: AttendanceLogCreateManyUserInput | AttendanceLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DutyRosterCreateWithoutUserInput = {
    startDate: Date | string
    endDate: Date | string
    shiftStart: string
    shiftEnd: string
    department?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyRosterUncheckedCreateWithoutUserInput = {
    id?: number
    startDate: Date | string
    endDate: Date | string
    shiftStart: string
    shiftEnd: string
    department?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyRosterCreateOrConnectWithoutUserInput = {
    where: DutyRosterWhereUniqueInput
    create: XOR<DutyRosterCreateWithoutUserInput, DutyRosterUncheckedCreateWithoutUserInput>
  }

  export type DutyRosterCreateManyUserInputEnvelope = {
    data: DutyRosterCreateManyUserInput | DutyRosterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutUserInput = {
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type HousekeepingStaffCreateWithoutUserInput = {
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskCreateNestedManyWithoutAssignedToInput
    cleaningVerifications?: CleaningVerificationCreateNestedManyWithoutVerifiedByInput
    supplyRequests?: CleaningSupplyRequestCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffUncheckedCreateWithoutUserInput = {
    id?: number
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskUncheckedCreateNestedManyWithoutAssignedToInput
    cleaningVerifications?: CleaningVerificationUncheckedCreateNestedManyWithoutVerifiedByInput
    supplyRequests?: CleaningSupplyRequestUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffCreateOrConnectWithoutUserInput = {
    where: HousekeepingStaffWhereUniqueInput
    create: XOR<HousekeepingStaffCreateWithoutUserInput, HousekeepingStaffUncheckedCreateWithoutUserInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PasswordResetUpsertWithoutUserInput = {
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    where?: PasswordResetWhereInput
  }

  export type PasswordResetUpdateToOneWithWhereWithoutUserInput = {
    where?: PasswordResetWhereInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUpsertWithoutUserInput = {
    update: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutUserInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUpdateWithoutUserInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientUpsertWithoutUserInput = {
    update: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutUserInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateWithoutUserInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type NurseUpsertWithoutUserInput = {
    update: XOR<NurseUpdateWithoutUserInput, NurseUncheckedUpdateWithoutUserInput>
    create: XOR<NurseCreateWithoutUserInput, NurseUncheckedCreateWithoutUserInput>
    where?: NurseWhereInput
  }

  export type NurseUpdateToOneWithWhereWithoutUserInput = {
    where?: NurseWhereInput
    data: XOR<NurseUpdateWithoutUserInput, NurseUncheckedUpdateWithoutUserInput>
  }

  export type NurseUpdateWithoutUserInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vitalSigns?: VitalSignUpdateManyWithoutNurseNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutNurseNestedInput
  }

  export type NurseUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutNurseNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    patientId?: IntFilter<"Invoice"> | number
    invoiceNumber?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPatientInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    patientId?: IntFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type BiometricDataUpsertWithoutUserInput = {
    update: XOR<BiometricDataUpdateWithoutUserInput, BiometricDataUncheckedUpdateWithoutUserInput>
    create: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
    where?: BiometricDataWhereInput
  }

  export type BiometricDataUpdateToOneWithWhereWithoutUserInput = {
    where?: BiometricDataWhereInput
    data: XOR<BiometricDataUpdateWithoutUserInput, BiometricDataUncheckedUpdateWithoutUserInput>
  }

  export type BiometricDataUpdateWithoutUserInput = {
    biometricId?: StringFieldUpdateOperationsInput | string
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    faceData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    biometricId?: StringFieldUpdateOperationsInput | string
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    faceData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceLogWhereUniqueInput
    update: XOR<AttendanceLogUpdateWithoutUserInput, AttendanceLogUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceLogCreateWithoutUserInput, AttendanceLogUncheckedCreateWithoutUserInput>
  }

  export type AttendanceLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceLogWhereUniqueInput
    data: XOR<AttendanceLogUpdateWithoutUserInput, AttendanceLogUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceLogUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceLogScalarWhereInput
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceLogScalarWhereInput = {
    AND?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    OR?: AttendanceLogScalarWhereInput[]
    NOT?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    id?: IntFilter<"AttendanceLog"> | number
    userId?: IntFilter<"AttendanceLog"> | number
    checkInTime?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    status?: StringFilter<"AttendanceLog"> | string
    deviceId?: StringNullableFilter<"AttendanceLog"> | string | null
    verificationMode?: StringNullableFilter<"AttendanceLog"> | string | null
    notes?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceLog"> | Date | string
  }

  export type DutyRosterUpsertWithWhereUniqueWithoutUserInput = {
    where: DutyRosterWhereUniqueInput
    update: XOR<DutyRosterUpdateWithoutUserInput, DutyRosterUncheckedUpdateWithoutUserInput>
    create: XOR<DutyRosterCreateWithoutUserInput, DutyRosterUncheckedCreateWithoutUserInput>
  }

  export type DutyRosterUpdateWithWhereUniqueWithoutUserInput = {
    where: DutyRosterWhereUniqueInput
    data: XOR<DutyRosterUpdateWithoutUserInput, DutyRosterUncheckedUpdateWithoutUserInput>
  }

  export type DutyRosterUpdateManyWithWhereWithoutUserInput = {
    where: DutyRosterScalarWhereInput
    data: XOR<DutyRosterUpdateManyMutationInput, DutyRosterUncheckedUpdateManyWithoutUserInput>
  }

  export type DutyRosterScalarWhereInput = {
    AND?: DutyRosterScalarWhereInput | DutyRosterScalarWhereInput[]
    OR?: DutyRosterScalarWhereInput[]
    NOT?: DutyRosterScalarWhereInput | DutyRosterScalarWhereInput[]
    id?: IntFilter<"DutyRoster"> | number
    userId?: IntFilter<"DutyRoster"> | number
    startDate?: DateTimeFilter<"DutyRoster"> | Date | string
    endDate?: DateTimeFilter<"DutyRoster"> | Date | string
    shiftStart?: StringFilter<"DutyRoster"> | string
    shiftEnd?: StringFilter<"DutyRoster"> | string
    department?: StringNullableFilter<"DutyRoster"> | string | null
    notes?: StringNullableFilter<"DutyRoster"> | string | null
    createdAt?: DateTimeFilter<"DutyRoster"> | Date | string
    updatedAt?: DateTimeFilter<"DutyRoster"> | Date | string
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type HousekeepingStaffUpsertWithoutUserInput = {
    update: XOR<HousekeepingStaffUpdateWithoutUserInput, HousekeepingStaffUncheckedUpdateWithoutUserInput>
    create: XOR<HousekeepingStaffCreateWithoutUserInput, HousekeepingStaffUncheckedCreateWithoutUserInput>
    where?: HousekeepingStaffWhereInput
  }

  export type HousekeepingStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: HousekeepingStaffWhereInput
    data: XOR<HousekeepingStaffUpdateWithoutUserInput, HousekeepingStaffUncheckedUpdateWithoutUserInput>
  }

  export type HousekeepingStaffUpdateWithoutUserInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUpdateManyWithoutAssignedToNestedInput
    cleaningVerifications?: CleaningVerificationUpdateManyWithoutVerifiedByNestedInput
    supplyRequests?: CleaningSupplyRequestUpdateManyWithoutRequestedByNestedInput
  }

  export type HousekeepingStaffUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    cleaningVerifications?: CleaningVerificationUncheckedUpdateManyWithoutVerifiedByNestedInput
    supplyRequests?: CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserCreateWithoutPasswordResetInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
  }

  export type UserUpsertWithoutPasswordResetInput = {
    update: XOR<UserUpdateWithoutPasswordResetInput, UserUncheckedUpdateWithoutPasswordResetInput>
    create: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetInput, UserUncheckedUpdateWithoutPasswordResetInput>
  }

  export type UserUpdateWithoutPasswordResetInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutDoctorInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateWithoutDoctorInput = {
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutDoctorInput = {
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    appointment?: AppointmentCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateManyDoctorInputEnvelope = {
    data: PrescriptionCreateManyDoctorInput | PrescriptionCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type LabReportCreateWithoutDoctorInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutLabReportsInput
    appointment?: AppointmentCreateNestedOneWithoutLabReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutLabReportInput
  }

  export type LabReportUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutLabReportInput
  }

  export type LabReportCreateOrConnectWithoutDoctorInput = {
    where: LabReportWhereUniqueInput
    create: XOR<LabReportCreateWithoutDoctorInput, LabReportUncheckedCreateWithoutDoctorInput>
  }

  export type LabReportCreateManyDoctorInputEnvelope = {
    data: LabReportCreateManyDoctorInput | LabReportCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyReportCreateWithoutDoctorInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRadiologyReportsInput
    appointment?: AppointmentCreateNestedOneWithoutRadiologyReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportCreateOrConnectWithoutDoctorInput = {
    where: RadiologyReportWhereUniqueInput
    create: XOR<RadiologyReportCreateWithoutDoctorInput, RadiologyReportUncheckedCreateWithoutDoctorInput>
  }

  export type RadiologyReportCreateManyDoctorInputEnvelope = {
    data: RadiologyReportCreateManyDoctorInput | RadiologyReportCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type OperationTheaterCreateWithoutDoctorInput = {
    name: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surgeries?: SurgeryCreateNestedManyWithoutOperationTheaterInput
    equipments?: OperationTheaterEquipmentCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterUncheckedCreateWithoutDoctorInput = {
    id?: number
    name: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutOperationTheaterInput
    equipments?: OperationTheaterEquipmentUncheckedCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterCreateOrConnectWithoutDoctorInput = {
    where: OperationTheaterWhereUniqueInput
    create: XOR<OperationTheaterCreateWithoutDoctorInput, OperationTheaterUncheckedCreateWithoutDoctorInput>
  }

  export type OperationTheaterCreateManyDoctorInputEnvelope = {
    data: OperationTheaterCreateManyDoctorInput | OperationTheaterCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDoctorInput = {
    update: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>
  }

  export type UserUpdateWithoutDoctorInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntFilter<"Appointment"> | number
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    startTime?: StringFilter<"Appointment"> | string
    endTime?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    followUp?: BoolFilter<"Appointment"> | boolean
    followUpDate?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: IntFilter<"Prescription"> | number
    patientId?: IntFilter<"Prescription"> | number
    doctorId?: IntFilter<"Prescription"> | number
    appointmentId?: IntNullableFilter<"Prescription"> | number | null
    prescriptionDate?: DateTimeFilter<"Prescription"> | Date | string
    diagnosis?: StringFilter<"Prescription"> | string
    notes?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
  }

  export type LabReportUpsertWithWhereUniqueWithoutDoctorInput = {
    where: LabReportWhereUniqueInput
    update: XOR<LabReportUpdateWithoutDoctorInput, LabReportUncheckedUpdateWithoutDoctorInput>
    create: XOR<LabReportCreateWithoutDoctorInput, LabReportUncheckedCreateWithoutDoctorInput>
  }

  export type LabReportUpdateWithWhereUniqueWithoutDoctorInput = {
    where: LabReportWhereUniqueInput
    data: XOR<LabReportUpdateWithoutDoctorInput, LabReportUncheckedUpdateWithoutDoctorInput>
  }

  export type LabReportUpdateManyWithWhereWithoutDoctorInput = {
    where: LabReportScalarWhereInput
    data: XOR<LabReportUpdateManyMutationInput, LabReportUncheckedUpdateManyWithoutDoctorInput>
  }

  export type LabReportScalarWhereInput = {
    AND?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
    OR?: LabReportScalarWhereInput[]
    NOT?: LabReportScalarWhereInput | LabReportScalarWhereInput[]
    id?: IntFilter<"LabReport"> | number
    patientId?: IntFilter<"LabReport"> | number
    doctorId?: IntFilter<"LabReport"> | number
    appointmentId?: IntNullableFilter<"LabReport"> | number | null
    testDate?: DateTimeFilter<"LabReport"> | Date | string
    reportDate?: DateTimeNullableFilter<"LabReport"> | Date | string | null
    testType?: StringFilter<"LabReport"> | string
    testResult?: StringNullableFilter<"LabReport"> | string | null
    normalRange?: StringNullableFilter<"LabReport"> | string | null
    notes?: StringNullableFilter<"LabReport"> | string | null
    attachmentUrl?: StringNullableFilter<"LabReport"> | string | null
    status?: StringFilter<"LabReport"> | string
    createdAt?: DateTimeFilter<"LabReport"> | Date | string
    updatedAt?: DateTimeFilter<"LabReport"> | Date | string
  }

  export type RadiologyReportUpsertWithWhereUniqueWithoutDoctorInput = {
    where: RadiologyReportWhereUniqueInput
    update: XOR<RadiologyReportUpdateWithoutDoctorInput, RadiologyReportUncheckedUpdateWithoutDoctorInput>
    create: XOR<RadiologyReportCreateWithoutDoctorInput, RadiologyReportUncheckedCreateWithoutDoctorInput>
  }

  export type RadiologyReportUpdateWithWhereUniqueWithoutDoctorInput = {
    where: RadiologyReportWhereUniqueInput
    data: XOR<RadiologyReportUpdateWithoutDoctorInput, RadiologyReportUncheckedUpdateWithoutDoctorInput>
  }

  export type RadiologyReportUpdateManyWithWhereWithoutDoctorInput = {
    where: RadiologyReportScalarWhereInput
    data: XOR<RadiologyReportUpdateManyMutationInput, RadiologyReportUncheckedUpdateManyWithoutDoctorInput>
  }

  export type RadiologyReportScalarWhereInput = {
    AND?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
    OR?: RadiologyReportScalarWhereInput[]
    NOT?: RadiologyReportScalarWhereInput | RadiologyReportScalarWhereInput[]
    id?: IntFilter<"RadiologyReport"> | number
    patientId?: IntFilter<"RadiologyReport"> | number
    doctorId?: IntFilter<"RadiologyReport"> | number
    appointmentId?: IntNullableFilter<"RadiologyReport"> | number | null
    testDate?: DateTimeFilter<"RadiologyReport"> | Date | string
    reportDate?: DateTimeNullableFilter<"RadiologyReport"> | Date | string | null
    testType?: StringFilter<"RadiologyReport"> | string
    findings?: StringNullableFilter<"RadiologyReport"> | string | null
    impression?: StringNullableFilter<"RadiologyReport"> | string | null
    notes?: StringNullableFilter<"RadiologyReport"> | string | null
    attachmentUrl?: StringNullableFilter<"RadiologyReport"> | string | null
    status?: StringFilter<"RadiologyReport"> | string
    createdAt?: DateTimeFilter<"RadiologyReport"> | Date | string
    updatedAt?: DateTimeFilter<"RadiologyReport"> | Date | string
  }

  export type OperationTheaterUpsertWithWhereUniqueWithoutDoctorInput = {
    where: OperationTheaterWhereUniqueInput
    update: XOR<OperationTheaterUpdateWithoutDoctorInput, OperationTheaterUncheckedUpdateWithoutDoctorInput>
    create: XOR<OperationTheaterCreateWithoutDoctorInput, OperationTheaterUncheckedCreateWithoutDoctorInput>
  }

  export type OperationTheaterUpdateWithWhereUniqueWithoutDoctorInput = {
    where: OperationTheaterWhereUniqueInput
    data: XOR<OperationTheaterUpdateWithoutDoctorInput, OperationTheaterUncheckedUpdateWithoutDoctorInput>
  }

  export type OperationTheaterUpdateManyWithWhereWithoutDoctorInput = {
    where: OperationTheaterScalarWhereInput
    data: XOR<OperationTheaterUpdateManyMutationInput, OperationTheaterUncheckedUpdateManyWithoutDoctorInput>
  }

  export type OperationTheaterScalarWhereInput = {
    AND?: OperationTheaterScalarWhereInput | OperationTheaterScalarWhereInput[]
    OR?: OperationTheaterScalarWhereInput[]
    NOT?: OperationTheaterScalarWhereInput | OperationTheaterScalarWhereInput[]
    id?: IntFilter<"OperationTheater"> | number
    name?: StringFilter<"OperationTheater"> | string
    location?: StringNullableFilter<"OperationTheater"> | string | null
    status?: StringFilter<"OperationTheater"> | string
    doctorId?: IntNullableFilter<"OperationTheater"> | number | null
    createdAt?: DateTimeFilter<"OperationTheater"> | Date | string
    updatedAt?: DateTimeFilter<"OperationTheater"> | Date | string
  }

  export type UserCreateWithoutPatientInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatientInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
  }

  export type TPACreateWithoutPatientsInput = {
    name: string
    contactPerson?: string | null
    contactNumber?: string | null
    email?: string | null
    address?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TPAUncheckedCreateWithoutPatientsInput = {
    id?: number
    name: string
    contactPerson?: string | null
    contactNumber?: string | null
    email?: string | null
    address?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TPACreateOrConnectWithoutPatientsInput = {
    where: TPAWhereUniqueInput
    create: XOR<TPACreateWithoutPatientsInput, TPAUncheckedCreateWithoutPatientsInput>
  }

  export type AppointmentCreateWithoutPatientInput = {
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
    appointment?: AppointmentCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LabReportCreateWithoutPatientInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutLabReportsInput
    appointment?: AppointmentCreateNestedOneWithoutLabReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutLabReportInput
  }

  export type LabReportUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutLabReportInput
  }

  export type LabReportCreateOrConnectWithoutPatientInput = {
    where: LabReportWhereUniqueInput
    create: XOR<LabReportCreateWithoutPatientInput, LabReportUncheckedCreateWithoutPatientInput>
  }

  export type LabReportCreateManyPatientInputEnvelope = {
    data: LabReportCreateManyPatientInput | LabReportCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyReportCreateWithoutPatientInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutRadiologyReportsInput
    appointment?: AppointmentCreateNestedOneWithoutRadiologyReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportCreateOrConnectWithoutPatientInput = {
    where: RadiologyReportWhereUniqueInput
    create: XOR<RadiologyReportCreateWithoutPatientInput, RadiologyReportUncheckedCreateWithoutPatientInput>
  }

  export type RadiologyReportCreateManyPatientInputEnvelope = {
    data: RadiologyReportCreateManyPatientInput | RadiologyReportCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientDetailsInput = {
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: UserCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientDetailsInput = {
    id?: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientDetailsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientDetailsInput, InvoiceUncheckedCreateWithoutPatientDetailsInput>
  }

  export type InvoiceCreateManyPatientDetailsInputEnvelope = {
    data: InvoiceCreateManyPatientDetailsInput | InvoiceCreateManyPatientDetailsInput[]
    skipDuplicates?: boolean
  }

  export type BedAllocationCreateWithoutPatientInput = {
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bed: BedCreateNestedOneWithoutBedAllocationsInput
    nurse?: NurseCreateNestedOneWithoutBedAllocationsInput
  }

  export type BedAllocationUncheckedCreateWithoutPatientInput = {
    id?: number
    bedId: number
    nurseId?: number | null
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationCreateOrConnectWithoutPatientInput = {
    where: BedAllocationWhereUniqueInput
    create: XOR<BedAllocationCreateWithoutPatientInput, BedAllocationUncheckedCreateWithoutPatientInput>
  }

  export type BedAllocationCreateManyPatientInputEnvelope = {
    data: BedAllocationCreateManyPatientInput | BedAllocationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type VitalSignCreateWithoutPatientInput = {
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    nurse: NurseCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignUncheckedCreateWithoutPatientInput = {
    id?: number
    recordedBy: number
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateOrConnectWithoutPatientInput = {
    where: VitalSignWhereUniqueInput
    create: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput>
  }

  export type VitalSignCreateManyPatientInputEnvelope = {
    data: VitalSignCreateManyPatientInput | VitalSignCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientSubsidyCreateWithoutPatientInput = {
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scheme: SubsidySchemeCreateNestedOneWithoutPatientSubsidiesInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutPatientSubsidyInput
  }

  export type PatientSubsidyUncheckedCreateWithoutPatientInput = {
    id?: number
    schemeId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutPatientSubsidyInput
  }

  export type PatientSubsidyCreateOrConnectWithoutPatientInput = {
    where: PatientSubsidyWhereUniqueInput
    create: XOR<PatientSubsidyCreateWithoutPatientInput, PatientSubsidyUncheckedCreateWithoutPatientInput>
  }

  export type PatientSubsidyCreateManyPatientInputEnvelope = {
    data: PatientSubsidyCreateManyPatientInput | PatientSubsidyCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatientInput = {
    update: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
  }

  export type UserUpdateWithoutPatientInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TPAUpsertWithoutPatientsInput = {
    update: XOR<TPAUpdateWithoutPatientsInput, TPAUncheckedUpdateWithoutPatientsInput>
    create: XOR<TPACreateWithoutPatientsInput, TPAUncheckedCreateWithoutPatientsInput>
    where?: TPAWhereInput
  }

  export type TPAUpdateToOneWithWhereWithoutPatientsInput = {
    where?: TPAWhereInput
    data: XOR<TPAUpdateWithoutPatientsInput, TPAUncheckedUpdateWithoutPatientsInput>
  }

  export type TPAUpdateWithoutPatientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TPAUncheckedUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type LabReportUpsertWithWhereUniqueWithoutPatientInput = {
    where: LabReportWhereUniqueInput
    update: XOR<LabReportUpdateWithoutPatientInput, LabReportUncheckedUpdateWithoutPatientInput>
    create: XOR<LabReportCreateWithoutPatientInput, LabReportUncheckedCreateWithoutPatientInput>
  }

  export type LabReportUpdateWithWhereUniqueWithoutPatientInput = {
    where: LabReportWhereUniqueInput
    data: XOR<LabReportUpdateWithoutPatientInput, LabReportUncheckedUpdateWithoutPatientInput>
  }

  export type LabReportUpdateManyWithWhereWithoutPatientInput = {
    where: LabReportScalarWhereInput
    data: XOR<LabReportUpdateManyMutationInput, LabReportUncheckedUpdateManyWithoutPatientInput>
  }

  export type RadiologyReportUpsertWithWhereUniqueWithoutPatientInput = {
    where: RadiologyReportWhereUniqueInput
    update: XOR<RadiologyReportUpdateWithoutPatientInput, RadiologyReportUncheckedUpdateWithoutPatientInput>
    create: XOR<RadiologyReportCreateWithoutPatientInput, RadiologyReportUncheckedCreateWithoutPatientInput>
  }

  export type RadiologyReportUpdateWithWhereUniqueWithoutPatientInput = {
    where: RadiologyReportWhereUniqueInput
    data: XOR<RadiologyReportUpdateWithoutPatientInput, RadiologyReportUncheckedUpdateWithoutPatientInput>
  }

  export type RadiologyReportUpdateManyWithWhereWithoutPatientInput = {
    where: RadiologyReportScalarWhereInput
    data: XOR<RadiologyReportUpdateManyMutationInput, RadiologyReportUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientDetailsInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientDetailsInput, InvoiceUncheckedUpdateWithoutPatientDetailsInput>
    create: XOR<InvoiceCreateWithoutPatientDetailsInput, InvoiceUncheckedCreateWithoutPatientDetailsInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientDetailsInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientDetailsInput, InvoiceUncheckedUpdateWithoutPatientDetailsInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientDetailsInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientDetailsInput>
  }

  export type BedAllocationUpsertWithWhereUniqueWithoutPatientInput = {
    where: BedAllocationWhereUniqueInput
    update: XOR<BedAllocationUpdateWithoutPatientInput, BedAllocationUncheckedUpdateWithoutPatientInput>
    create: XOR<BedAllocationCreateWithoutPatientInput, BedAllocationUncheckedCreateWithoutPatientInput>
  }

  export type BedAllocationUpdateWithWhereUniqueWithoutPatientInput = {
    where: BedAllocationWhereUniqueInput
    data: XOR<BedAllocationUpdateWithoutPatientInput, BedAllocationUncheckedUpdateWithoutPatientInput>
  }

  export type BedAllocationUpdateManyWithWhereWithoutPatientInput = {
    where: BedAllocationScalarWhereInput
    data: XOR<BedAllocationUpdateManyMutationInput, BedAllocationUncheckedUpdateManyWithoutPatientInput>
  }

  export type BedAllocationScalarWhereInput = {
    AND?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
    OR?: BedAllocationScalarWhereInput[]
    NOT?: BedAllocationScalarWhereInput | BedAllocationScalarWhereInput[]
    id?: IntFilter<"BedAllocation"> | number
    bedId?: IntFilter<"BedAllocation"> | number
    patientId?: IntFilter<"BedAllocation"> | number
    nurseId?: IntNullableFilter<"BedAllocation"> | number | null
    allocatedAt?: DateTimeFilter<"BedAllocation"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"BedAllocation"> | Date | string | null
    status?: StringFilter<"BedAllocation"> | string
    notes?: StringNullableFilter<"BedAllocation"> | string | null
    createdAt?: DateTimeFilter<"BedAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"BedAllocation"> | Date | string
  }

  export type VitalSignUpsertWithWhereUniqueWithoutPatientInput = {
    where: VitalSignWhereUniqueInput
    update: XOR<VitalSignUpdateWithoutPatientInput, VitalSignUncheckedUpdateWithoutPatientInput>
    create: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput>
  }

  export type VitalSignUpdateWithWhereUniqueWithoutPatientInput = {
    where: VitalSignWhereUniqueInput
    data: XOR<VitalSignUpdateWithoutPatientInput, VitalSignUncheckedUpdateWithoutPatientInput>
  }

  export type VitalSignUpdateManyWithWhereWithoutPatientInput = {
    where: VitalSignScalarWhereInput
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyWithoutPatientInput>
  }

  export type VitalSignScalarWhereInput = {
    AND?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
    OR?: VitalSignScalarWhereInput[]
    NOT?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
    id?: IntFilter<"VitalSign"> | number
    patientId?: IntFilter<"VitalSign"> | number
    recordedBy?: IntFilter<"VitalSign"> | number
    temperature?: FloatNullableFilter<"VitalSign"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"VitalSign"> | number | null
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSign"> | number | null
    oxygenSaturation?: FloatNullableFilter<"VitalSign"> | number | null
    height?: FloatNullableFilter<"VitalSign"> | number | null
    weight?: FloatNullableFilter<"VitalSign"> | number | null
    notes?: StringNullableFilter<"VitalSign"> | string | null
    recordedAt?: DateTimeFilter<"VitalSign"> | Date | string
    createdAt?: DateTimeFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeFilter<"VitalSign"> | Date | string
  }

  export type PatientSubsidyUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientSubsidyWhereUniqueInput
    update: XOR<PatientSubsidyUpdateWithoutPatientInput, PatientSubsidyUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientSubsidyCreateWithoutPatientInput, PatientSubsidyUncheckedCreateWithoutPatientInput>
  }

  export type PatientSubsidyUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientSubsidyWhereUniqueInput
    data: XOR<PatientSubsidyUpdateWithoutPatientInput, PatientSubsidyUncheckedUpdateWithoutPatientInput>
  }

  export type PatientSubsidyUpdateManyWithWhereWithoutPatientInput = {
    where: PatientSubsidyScalarWhereInput
    data: XOR<PatientSubsidyUpdateManyMutationInput, PatientSubsidyUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientSubsidyScalarWhereInput = {
    AND?: PatientSubsidyScalarWhereInput | PatientSubsidyScalarWhereInput[]
    OR?: PatientSubsidyScalarWhereInput[]
    NOT?: PatientSubsidyScalarWhereInput | PatientSubsidyScalarWhereInput[]
    id?: IntFilter<"PatientSubsidy"> | number
    patientId?: IntFilter<"PatientSubsidy"> | number
    schemeId?: IntFilter<"PatientSubsidy"> | number
    enrollmentDate?: DateTimeFilter<"PatientSubsidy"> | Date | string
    enrollmentNumber?: StringFilter<"PatientSubsidy"> | string
    cardNumber?: StringNullableFilter<"PatientSubsidy"> | string | null
    validFrom?: DateTimeFilter<"PatientSubsidy"> | Date | string
    validUntil?: DateTimeNullableFilter<"PatientSubsidy"> | Date | string | null
    remainingBalance?: DecimalNullableFilter<"PatientSubsidy"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"PatientSubsidy"> | string
    verificationStatus?: StringFilter<"PatientSubsidy"> | string
    verifiedBy?: IntNullableFilter<"PatientSubsidy"> | number | null
    verifiedAt?: DateTimeNullableFilter<"PatientSubsidy"> | Date | string | null
    notes?: StringNullableFilter<"PatientSubsidy"> | string | null
    createdAt?: DateTimeFilter<"PatientSubsidy"> | Date | string
    updatedAt?: DateTimeFilter<"PatientSubsidy"> | Date | string
  }

  export type UserCreateWithoutNurseInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNurseInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNurseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseInput, UserUncheckedCreateWithoutNurseInput>
  }

  export type VitalSignCreateWithoutNurseInput = {
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignUncheckedCreateWithoutNurseInput = {
    id?: number
    patientId: number
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateOrConnectWithoutNurseInput = {
    where: VitalSignWhereUniqueInput
    create: XOR<VitalSignCreateWithoutNurseInput, VitalSignUncheckedCreateWithoutNurseInput>
  }

  export type VitalSignCreateManyNurseInputEnvelope = {
    data: VitalSignCreateManyNurseInput | VitalSignCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type BedAllocationCreateWithoutNurseInput = {
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bed: BedCreateNestedOneWithoutBedAllocationsInput
    patient: PatientCreateNestedOneWithoutBedAllocationsInput
  }

  export type BedAllocationUncheckedCreateWithoutNurseInput = {
    id?: number
    bedId: number
    patientId: number
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationCreateOrConnectWithoutNurseInput = {
    where: BedAllocationWhereUniqueInput
    create: XOR<BedAllocationCreateWithoutNurseInput, BedAllocationUncheckedCreateWithoutNurseInput>
  }

  export type BedAllocationCreateManyNurseInputEnvelope = {
    data: BedAllocationCreateManyNurseInput | BedAllocationCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNurseInput = {
    update: XOR<UserUpdateWithoutNurseInput, UserUncheckedUpdateWithoutNurseInput>
    create: XOR<UserCreateWithoutNurseInput, UserUncheckedCreateWithoutNurseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseInput, UserUncheckedUpdateWithoutNurseInput>
  }

  export type UserUpdateWithoutNurseInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VitalSignUpsertWithWhereUniqueWithoutNurseInput = {
    where: VitalSignWhereUniqueInput
    update: XOR<VitalSignUpdateWithoutNurseInput, VitalSignUncheckedUpdateWithoutNurseInput>
    create: XOR<VitalSignCreateWithoutNurseInput, VitalSignUncheckedCreateWithoutNurseInput>
  }

  export type VitalSignUpdateWithWhereUniqueWithoutNurseInput = {
    where: VitalSignWhereUniqueInput
    data: XOR<VitalSignUpdateWithoutNurseInput, VitalSignUncheckedUpdateWithoutNurseInput>
  }

  export type VitalSignUpdateManyWithWhereWithoutNurseInput = {
    where: VitalSignScalarWhereInput
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyWithoutNurseInput>
  }

  export type BedAllocationUpsertWithWhereUniqueWithoutNurseInput = {
    where: BedAllocationWhereUniqueInput
    update: XOR<BedAllocationUpdateWithoutNurseInput, BedAllocationUncheckedUpdateWithoutNurseInput>
    create: XOR<BedAllocationCreateWithoutNurseInput, BedAllocationUncheckedCreateWithoutNurseInput>
  }

  export type BedAllocationUpdateWithWhereUniqueWithoutNurseInput = {
    where: BedAllocationWhereUniqueInput
    data: XOR<BedAllocationUpdateWithoutNurseInput, BedAllocationUncheckedUpdateWithoutNurseInput>
  }

  export type BedAllocationUpdateManyWithWhereWithoutNurseInput = {
    where: BedAllocationScalarWhereInput
    data: XOR<BedAllocationUpdateManyMutationInput, BedAllocationUncheckedUpdateManyWithoutNurseInput>
  }

  export type PatientCreateWithoutAppointmentsInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type DoctorCreateWithoutAppointmentsInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    labReports?: LabReportCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutAppointmentsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
  }

  export type PrescriptionCreateWithoutAppointmentInput = {
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutAppointmentInput = {
    id?: number
    patientId: number
    doctorId: number
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutAppointmentInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutAppointmentInput, PrescriptionUncheckedCreateWithoutAppointmentInput>
  }

  export type PrescriptionCreateManyAppointmentInputEnvelope = {
    data: PrescriptionCreateManyAppointmentInput | PrescriptionCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type LabReportCreateWithoutAppointmentInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutLabReportsInput
    doctor: DoctorCreateNestedOneWithoutLabReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutLabReportInput
  }

  export type LabReportUncheckedCreateWithoutAppointmentInput = {
    id?: number
    patientId: number
    doctorId: number
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutLabReportInput
  }

  export type LabReportCreateOrConnectWithoutAppointmentInput = {
    where: LabReportWhereUniqueInput
    create: XOR<LabReportCreateWithoutAppointmentInput, LabReportUncheckedCreateWithoutAppointmentInput>
  }

  export type LabReportCreateManyAppointmentInputEnvelope = {
    data: LabReportCreateManyAppointmentInput | LabReportCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyReportCreateWithoutAppointmentInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRadiologyReportsInput
    doctor: DoctorCreateNestedOneWithoutRadiologyReportsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportUncheckedCreateWithoutAppointmentInput = {
    id?: number
    patientId: number
    doctorId: number
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutRadiologyReportInput
  }

  export type RadiologyReportCreateOrConnectWithoutAppointmentInput = {
    where: RadiologyReportWhereUniqueInput
    create: XOR<RadiologyReportCreateWithoutAppointmentInput, RadiologyReportUncheckedCreateWithoutAppointmentInput>
  }

  export type RadiologyReportCreateManyAppointmentInputEnvelope = {
    data: RadiologyReportCreateManyAppointmentInput | RadiologyReportCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutAppointmentsInput = {
    update: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateWithoutAppointmentsInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutAppointmentInput, PrescriptionUncheckedUpdateWithoutAppointmentInput>
    create: XOR<PrescriptionCreateWithoutAppointmentInput, PrescriptionUncheckedCreateWithoutAppointmentInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutAppointmentInput, PrescriptionUncheckedUpdateWithoutAppointmentInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutAppointmentInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type LabReportUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: LabReportWhereUniqueInput
    update: XOR<LabReportUpdateWithoutAppointmentInput, LabReportUncheckedUpdateWithoutAppointmentInput>
    create: XOR<LabReportCreateWithoutAppointmentInput, LabReportUncheckedCreateWithoutAppointmentInput>
  }

  export type LabReportUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: LabReportWhereUniqueInput
    data: XOR<LabReportUpdateWithoutAppointmentInput, LabReportUncheckedUpdateWithoutAppointmentInput>
  }

  export type LabReportUpdateManyWithWhereWithoutAppointmentInput = {
    where: LabReportScalarWhereInput
    data: XOR<LabReportUpdateManyMutationInput, LabReportUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type RadiologyReportUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: RadiologyReportWhereUniqueInput
    update: XOR<RadiologyReportUpdateWithoutAppointmentInput, RadiologyReportUncheckedUpdateWithoutAppointmentInput>
    create: XOR<RadiologyReportCreateWithoutAppointmentInput, RadiologyReportUncheckedCreateWithoutAppointmentInput>
  }

  export type RadiologyReportUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: RadiologyReportWhereUniqueInput
    data: XOR<RadiologyReportUpdateWithoutAppointmentInput, RadiologyReportUncheckedUpdateWithoutAppointmentInput>
  }

  export type RadiologyReportUpdateManyWithWhereWithoutAppointmentInput = {
    where: RadiologyReportScalarWhereInput
    data: XOR<RadiologyReportUpdateManyMutationInput, RadiologyReportUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type DoctorCreateWithoutPrescriptionsInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    labReports?: LabReportCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutPrescriptionsInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutPrescriptionsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
  }

  export type AppointmentCreateWithoutPrescriptionsInput = {
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    labReports?: LabReportCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPrescriptionsInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    labReports?: LabReportUncheckedCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPrescriptionsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPrescriptionsInput, AppointmentUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PrescriptionMedicineCreateWithoutPrescriptionInput = {
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicine: MedicineCreateNestedOneWithoutPrescriptionMedicinesInput
  }

  export type PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    medicineId: number
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionMedicineWhereUniqueInput
    create: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionMedicineCreateManyPrescriptionInput | PrescriptionMedicineCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutPrescriptionsInput = {
    update: XOR<DoctorUpdateWithoutPrescriptionsInput, DoctorUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutPrescriptionsInput, DoctorUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type DoctorUpdateWithoutPrescriptionsInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutPrescriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type AppointmentUpsertWithoutPrescriptionsInput = {
    update: XOR<AppointmentUpdateWithoutPrescriptionsInput, AppointmentUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<AppointmentCreateWithoutPrescriptionsInput, AppointmentUncheckedCreateWithoutPrescriptionsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutPrescriptionsInput, AppointmentUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type AppointmentUpdateWithoutPrescriptionsInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    labReports?: LabReportUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPrescriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labReports?: LabReportUncheckedUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionMedicineWhereUniqueInput
    update: XOR<PrescriptionMedicineUpdateWithoutPrescriptionInput, PrescriptionMedicineUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionMedicineWhereUniqueInput
    data: XOR<PrescriptionMedicineUpdateWithoutPrescriptionInput, PrescriptionMedicineUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionMedicineScalarWhereInput
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineScalarWhereInput = {
    AND?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
    OR?: PrescriptionMedicineScalarWhereInput[]
    NOT?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
    id?: IntFilter<"PrescriptionMedicine"> | number
    prescriptionId?: IntFilter<"PrescriptionMedicine"> | number
    medicineId?: IntFilter<"PrescriptionMedicine"> | number
    dosage?: StringFilter<"PrescriptionMedicine"> | string
    frequency?: StringFilter<"PrescriptionMedicine"> | string
    duration?: StringFilter<"PrescriptionMedicine"> | string
    instructions?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    createdAt?: DateTimeFilter<"PrescriptionMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"PrescriptionMedicine"> | Date | string
  }

  export type PrescriptionCreateWithoutMedicinesInput = {
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: DoctorCreateNestedOneWithoutPrescriptionsInput
    appointment?: AppointmentCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutMedicinesInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionCreateOrConnectWithoutMedicinesInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
  }

  export type MedicineCreateWithoutPrescriptionMedicinesInput = {
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryLogs?: InventoryLogCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutPrescriptionMedicinesInput = {
    id?: number
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryLogs?: InventoryLogUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutPrescriptionMedicinesInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutPrescriptionMedicinesInput, MedicineUncheckedCreateWithoutPrescriptionMedicinesInput>
  }

  export type PrescriptionUpsertWithoutMedicinesInput = {
    update: XOR<PrescriptionUpdateWithoutMedicinesInput, PrescriptionUncheckedUpdateWithoutMedicinesInput>
    create: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutMedicinesInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutMedicinesInput, PrescriptionUncheckedUpdateWithoutMedicinesInput>
  }

  export type PrescriptionUpdateWithoutMedicinesInput = {
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
    appointment?: AppointmentUpdateOneWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutMedicinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUpsertWithoutPrescriptionMedicinesInput = {
    update: XOR<MedicineUpdateWithoutPrescriptionMedicinesInput, MedicineUncheckedUpdateWithoutPrescriptionMedicinesInput>
    create: XOR<MedicineCreateWithoutPrescriptionMedicinesInput, MedicineUncheckedCreateWithoutPrescriptionMedicinesInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutPrescriptionMedicinesInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutPrescriptionMedicinesInput, MedicineUncheckedUpdateWithoutPrescriptionMedicinesInput>
  }

  export type MedicineUpdateWithoutPrescriptionMedicinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryLogs?: InventoryLogUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutPrescriptionMedicinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryLogs?: InventoryLogUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type PrescriptionMedicineCreateWithoutMedicineInput = {
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescription: PrescriptionCreateNestedOneWithoutMedicinesInput
  }

  export type PrescriptionMedicineUncheckedCreateWithoutMedicineInput = {
    id?: number
    prescriptionId: number
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionMedicineCreateOrConnectWithoutMedicineInput = {
    where: PrescriptionMedicineWhereUniqueInput
    create: XOR<PrescriptionMedicineCreateWithoutMedicineInput, PrescriptionMedicineUncheckedCreateWithoutMedicineInput>
  }

  export type PrescriptionMedicineCreateManyMedicineInputEnvelope = {
    data: PrescriptionMedicineCreateManyMedicineInput | PrescriptionMedicineCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type InventoryLogCreateWithoutMedicineInput = {
    quantity: number
    type: string
    reason?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryLogUncheckedCreateWithoutMedicineInput = {
    id?: number
    quantity: number
    type: string
    reason?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryLogCreateOrConnectWithoutMedicineInput = {
    where: InventoryLogWhereUniqueInput
    create: XOR<InventoryLogCreateWithoutMedicineInput, InventoryLogUncheckedCreateWithoutMedicineInput>
  }

  export type InventoryLogCreateManyMedicineInputEnvelope = {
    data: InventoryLogCreateManyMedicineInput | InventoryLogCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionMedicineUpsertWithWhereUniqueWithoutMedicineInput = {
    where: PrescriptionMedicineWhereUniqueInput
    update: XOR<PrescriptionMedicineUpdateWithoutMedicineInput, PrescriptionMedicineUncheckedUpdateWithoutMedicineInput>
    create: XOR<PrescriptionMedicineCreateWithoutMedicineInput, PrescriptionMedicineUncheckedCreateWithoutMedicineInput>
  }

  export type PrescriptionMedicineUpdateWithWhereUniqueWithoutMedicineInput = {
    where: PrescriptionMedicineWhereUniqueInput
    data: XOR<PrescriptionMedicineUpdateWithoutMedicineInput, PrescriptionMedicineUncheckedUpdateWithoutMedicineInput>
  }

  export type PrescriptionMedicineUpdateManyWithWhereWithoutMedicineInput = {
    where: PrescriptionMedicineScalarWhereInput
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyWithoutMedicineInput>
  }

  export type InventoryLogUpsertWithWhereUniqueWithoutMedicineInput = {
    where: InventoryLogWhereUniqueInput
    update: XOR<InventoryLogUpdateWithoutMedicineInput, InventoryLogUncheckedUpdateWithoutMedicineInput>
    create: XOR<InventoryLogCreateWithoutMedicineInput, InventoryLogUncheckedCreateWithoutMedicineInput>
  }

  export type InventoryLogUpdateWithWhereUniqueWithoutMedicineInput = {
    where: InventoryLogWhereUniqueInput
    data: XOR<InventoryLogUpdateWithoutMedicineInput, InventoryLogUncheckedUpdateWithoutMedicineInput>
  }

  export type InventoryLogUpdateManyWithWhereWithoutMedicineInput = {
    where: InventoryLogScalarWhereInput
    data: XOR<InventoryLogUpdateManyMutationInput, InventoryLogUncheckedUpdateManyWithoutMedicineInput>
  }

  export type InventoryLogScalarWhereInput = {
    AND?: InventoryLogScalarWhereInput | InventoryLogScalarWhereInput[]
    OR?: InventoryLogScalarWhereInput[]
    NOT?: InventoryLogScalarWhereInput | InventoryLogScalarWhereInput[]
    id?: IntFilter<"InventoryLog"> | number
    medicineId?: IntFilter<"InventoryLog"> | number
    quantity?: IntFilter<"InventoryLog"> | number
    type?: StringFilter<"InventoryLog"> | string
    reason?: StringNullableFilter<"InventoryLog"> | string | null
    referenceId?: StringNullableFilter<"InventoryLog"> | string | null
    createdAt?: DateTimeFilter<"InventoryLog"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryLog"> | Date | string
  }

  export type MedicineCreateWithoutInventoryLogsInput = {
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionMedicines?: PrescriptionMedicineCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutInventoryLogsInput = {
    id?: number
    name: string
    genericName?: string | null
    category?: string | null
    manufacturer?: string | null
    description?: string | null
    dosageForm?: string | null
    strength?: string | null
    price?: Decimal | DecimalJsLike | number | string
    stock?: number
    reorderLevel?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionMedicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutInventoryLogsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutInventoryLogsInput, MedicineUncheckedCreateWithoutInventoryLogsInput>
  }

  export type MedicineUpsertWithoutInventoryLogsInput = {
    update: XOR<MedicineUpdateWithoutInventoryLogsInput, MedicineUncheckedUpdateWithoutInventoryLogsInput>
    create: XOR<MedicineCreateWithoutInventoryLogsInput, MedicineUncheckedCreateWithoutInventoryLogsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutInventoryLogsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutInventoryLogsInput, MedicineUncheckedUpdateWithoutInventoryLogsInput>
  }

  export type MedicineUpdateWithoutInventoryLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionMedicines?: PrescriptionMedicineUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutInventoryLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionMedicines?: PrescriptionMedicineUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type PatientCreateWithoutLabReportsInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutLabReportsInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLabReportsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLabReportsInput, PatientUncheckedCreateWithoutLabReportsInput>
  }

  export type DoctorCreateWithoutLabReportsInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutLabReportsInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutLabReportsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutLabReportsInput, DoctorUncheckedCreateWithoutLabReportsInput>
  }

  export type AppointmentCreateWithoutLabReportsInput = {
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutLabReportsInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAppointmentInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutLabReportsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutLabReportsInput, AppointmentUncheckedCreateWithoutLabReportsInput>
  }

  export type InvoiceItemCreateWithoutLabReportInput = {
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
    radiologyReport?: RadiologyReportCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutLabReportInput = {
    id?: number
    invoiceId: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    radiologyReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutLabReportInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutLabReportInput, InvoiceItemUncheckedCreateWithoutLabReportInput>
  }

  export type InvoiceItemCreateManyLabReportInputEnvelope = {
    data: InvoiceItemCreateManyLabReportInput | InvoiceItemCreateManyLabReportInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutLabReportsInput = {
    update: XOR<PatientUpdateWithoutLabReportsInput, PatientUncheckedUpdateWithoutLabReportsInput>
    create: XOR<PatientCreateWithoutLabReportsInput, PatientUncheckedCreateWithoutLabReportsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLabReportsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLabReportsInput, PatientUncheckedUpdateWithoutLabReportsInput>
  }

  export type PatientUpdateWithoutLabReportsInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutLabReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutLabReportsInput = {
    update: XOR<DoctorUpdateWithoutLabReportsInput, DoctorUncheckedUpdateWithoutLabReportsInput>
    create: XOR<DoctorCreateWithoutLabReportsInput, DoctorUncheckedCreateWithoutLabReportsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutLabReportsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutLabReportsInput, DoctorUncheckedUpdateWithoutLabReportsInput>
  }

  export type DoctorUpdateWithoutLabReportsInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutLabReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type AppointmentUpsertWithoutLabReportsInput = {
    update: XOR<AppointmentUpdateWithoutLabReportsInput, AppointmentUncheckedUpdateWithoutLabReportsInput>
    create: XOR<AppointmentCreateWithoutLabReportsInput, AppointmentUncheckedCreateWithoutLabReportsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutLabReportsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutLabReportsInput, AppointmentUncheckedUpdateWithoutLabReportsInput>
  }

  export type AppointmentUpdateWithoutLabReportsInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutLabReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutLabReportInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutLabReportInput, InvoiceItemUncheckedUpdateWithoutLabReportInput>
    create: XOR<InvoiceItemCreateWithoutLabReportInput, InvoiceItemUncheckedCreateWithoutLabReportInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutLabReportInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutLabReportInput, InvoiceItemUncheckedUpdateWithoutLabReportInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutLabReportInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutLabReportInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: StringFilter<"InvoiceItem"> | string
    itemId?: IntNullableFilter<"InvoiceItem"> | number | null
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    labReportId?: IntNullableFilter<"InvoiceItem"> | number | null
    radiologyReportId?: IntNullableFilter<"InvoiceItem"> | number | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type PatientCreateWithoutRadiologyReportsInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRadiologyReportsInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRadiologyReportsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRadiologyReportsInput, PatientUncheckedCreateWithoutRadiologyReportsInput>
  }

  export type DoctorCreateWithoutRadiologyReportsInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    labReports?: LabReportCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutRadiologyReportsInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutDoctorInput
    operationTheaters?: OperationTheaterUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutRadiologyReportsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutRadiologyReportsInput, DoctorUncheckedCreateWithoutRadiologyReportsInput>
  }

  export type AppointmentCreateWithoutRadiologyReportsInput = {
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutRadiologyReportsInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAppointmentInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutRadiologyReportsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutRadiologyReportsInput, AppointmentUncheckedCreateWithoutRadiologyReportsInput>
  }

  export type InvoiceItemCreateWithoutRadiologyReportInput = {
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
    labReport?: LabReportCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutRadiologyReportInput = {
    id?: number
    invoiceId: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    labReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutRadiologyReportInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutRadiologyReportInput, InvoiceItemUncheckedCreateWithoutRadiologyReportInput>
  }

  export type InvoiceItemCreateManyRadiologyReportInputEnvelope = {
    data: InvoiceItemCreateManyRadiologyReportInput | InvoiceItemCreateManyRadiologyReportInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutRadiologyReportsInput = {
    update: XOR<PatientUpdateWithoutRadiologyReportsInput, PatientUncheckedUpdateWithoutRadiologyReportsInput>
    create: XOR<PatientCreateWithoutRadiologyReportsInput, PatientUncheckedCreateWithoutRadiologyReportsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRadiologyReportsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRadiologyReportsInput, PatientUncheckedUpdateWithoutRadiologyReportsInput>
  }

  export type PatientUpdateWithoutRadiologyReportsInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRadiologyReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutRadiologyReportsInput = {
    update: XOR<DoctorUpdateWithoutRadiologyReportsInput, DoctorUncheckedUpdateWithoutRadiologyReportsInput>
    create: XOR<DoctorCreateWithoutRadiologyReportsInput, DoctorUncheckedCreateWithoutRadiologyReportsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutRadiologyReportsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutRadiologyReportsInput, DoctorUncheckedUpdateWithoutRadiologyReportsInput>
  }

  export type DoctorUpdateWithoutRadiologyReportsInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutRadiologyReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutDoctorNestedInput
    operationTheaters?: OperationTheaterUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type AppointmentUpsertWithoutRadiologyReportsInput = {
    update: XOR<AppointmentUpdateWithoutRadiologyReportsInput, AppointmentUncheckedUpdateWithoutRadiologyReportsInput>
    create: XOR<AppointmentCreateWithoutRadiologyReportsInput, AppointmentUncheckedCreateWithoutRadiologyReportsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutRadiologyReportsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutRadiologyReportsInput, AppointmentUncheckedUpdateWithoutRadiologyReportsInput>
  }

  export type AppointmentUpdateWithoutRadiologyReportsInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutRadiologyReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutRadiologyReportInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutRadiologyReportInput, InvoiceItemUncheckedUpdateWithoutRadiologyReportInput>
    create: XOR<InvoiceItemCreateWithoutRadiologyReportInput, InvoiceItemUncheckedCreateWithoutRadiologyReportInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutRadiologyReportInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutRadiologyReportInput, InvoiceItemUncheckedUpdateWithoutRadiologyReportInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutRadiologyReportInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutRadiologyReportInput>
  }

  export type UserCreateWithoutInvoicesInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type PatientCreateWithoutInvoicesInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    labReport?: LabReportCreateNestedOneWithoutInvoiceItemsInput
    radiologyReport?: RadiologyReportCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    labReportId?: number | null
    radiologyReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    patientId: number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type SubsidyClaimCreateWithoutInvoiceInput = {
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidy: PatientSubsidyCreateNestedOneWithoutSubsidyClaimsInput
    scheme: SubsidySchemeCreateNestedOneWithoutSubsidyClaimsInput
  }

  export type SubsidyClaimUncheckedCreateWithoutInvoiceInput = {
    id?: number
    patientSubsidyId: number
    schemeId: number
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimCreateOrConnectWithoutInvoiceInput = {
    where: SubsidyClaimWhereUniqueInput
    create: XOR<SubsidyClaimCreateWithoutInvoiceInput, SubsidyClaimUncheckedCreateWithoutInvoiceInput>
  }

  export type SubsidyClaimCreateManyInvoiceInputEnvelope = {
    data: SubsidyClaimCreateManyInvoiceInput | SubsidyClaimCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type SubsidyClaimUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: SubsidyClaimWhereUniqueInput
    update: XOR<SubsidyClaimUpdateWithoutInvoiceInput, SubsidyClaimUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SubsidyClaimCreateWithoutInvoiceInput, SubsidyClaimUncheckedCreateWithoutInvoiceInput>
  }

  export type SubsidyClaimUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: SubsidyClaimWhereUniqueInput
    data: XOR<SubsidyClaimUpdateWithoutInvoiceInput, SubsidyClaimUncheckedUpdateWithoutInvoiceInput>
  }

  export type SubsidyClaimUpdateManyWithWhereWithoutInvoiceInput = {
    where: SubsidyClaimScalarWhereInput
    data: XOR<SubsidyClaimUpdateManyMutationInput, SubsidyClaimUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type SubsidyClaimScalarWhereInput = {
    AND?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
    OR?: SubsidyClaimScalarWhereInput[]
    NOT?: SubsidyClaimScalarWhereInput | SubsidyClaimScalarWhereInput[]
    id?: IntFilter<"SubsidyClaim"> | number
    patientSubsidyId?: IntFilter<"SubsidyClaim"> | number
    schemeId?: IntFilter<"SubsidyClaim"> | number
    invoiceId?: IntNullableFilter<"SubsidyClaim"> | number | null
    claimDate?: DateTimeFilter<"SubsidyClaim"> | Date | string
    claimAmount?: DecimalFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"SubsidyClaim"> | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: StringNullableFilter<"SubsidyClaim"> | string | null
    claimStatus?: StringFilter<"SubsidyClaim"> | string
    processedBy?: IntNullableFilter<"SubsidyClaim"> | number | null
    processedAt?: DateTimeNullableFilter<"SubsidyClaim"> | Date | string | null
    reimbursementDate?: DateTimeNullableFilter<"SubsidyClaim"> | Date | string | null
    transactionId?: StringNullableFilter<"SubsidyClaim"> | string | null
    notes?: StringNullableFilter<"SubsidyClaim"> | string | null
    createdAt?: DateTimeFilter<"SubsidyClaim"> | Date | string
    updatedAt?: DateTimeFilter<"SubsidyClaim"> | Date | string
  }

  export type InvoiceCreateWithoutInvoiceItemsInput = {
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: UserCreateNestedOneWithoutInvoicesInput
    patientDetails: PatientCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    patientId: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type LabReportCreateWithoutInvoiceItemsInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutLabReportsInput
    doctor: DoctorCreateNestedOneWithoutLabReportsInput
    appointment?: AppointmentCreateNestedOneWithoutLabReportsInput
  }

  export type LabReportUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabReportCreateOrConnectWithoutInvoiceItemsInput = {
    where: LabReportWhereUniqueInput
    create: XOR<LabReportCreateWithoutInvoiceItemsInput, LabReportUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type RadiologyReportCreateWithoutInvoiceItemsInput = {
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRadiologyReportsInput
    doctor: DoctorCreateNestedOneWithoutRadiologyReportsInput
    appointment?: AppointmentCreateNestedOneWithoutRadiologyReportsInput
  }

  export type RadiologyReportUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    patientId: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyReportCreateOrConnectWithoutInvoiceItemsInput = {
    where: RadiologyReportWhereUniqueInput
    create: XOR<RadiologyReportCreateWithoutInvoiceItemsInput, RadiologyReportUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateWithoutInvoiceItemsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    patientDetails?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LabReportUpsertWithoutInvoiceItemsInput = {
    update: XOR<LabReportUpdateWithoutInvoiceItemsInput, LabReportUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<LabReportCreateWithoutInvoiceItemsInput, LabReportUncheckedCreateWithoutInvoiceItemsInput>
    where?: LabReportWhereInput
  }

  export type LabReportUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: LabReportWhereInput
    data: XOR<LabReportUpdateWithoutInvoiceItemsInput, LabReportUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type LabReportUpdateWithoutInvoiceItemsInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutLabReportsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutLabReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutLabReportsNestedInput
  }

  export type LabReportUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyReportUpsertWithoutInvoiceItemsInput = {
    update: XOR<RadiologyReportUpdateWithoutInvoiceItemsInput, RadiologyReportUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<RadiologyReportCreateWithoutInvoiceItemsInput, RadiologyReportUncheckedCreateWithoutInvoiceItemsInput>
    where?: RadiologyReportWhereInput
  }

  export type RadiologyReportUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: RadiologyReportWhereInput
    data: XOR<RadiologyReportUpdateWithoutInvoiceItemsInput, RadiologyReportUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type RadiologyReportUpdateWithoutInvoiceItemsInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRadiologyReportsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutRadiologyReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutRadiologyReportsNestedInput
  }

  export type RadiologyReportUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: UserCreateNestedOneWithoutInvoicesInput
    patientDetails: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: number
    patientId: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    patientDetails?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WardCreateWithoutBedsInput = {
    name: string
    wardType: string
    floor?: string | null
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardUncheckedCreateWithoutBedsInput = {
    id?: number
    name: string
    wardType: string
    floor?: string | null
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardCreateOrConnectWithoutBedsInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
  }

  export type BedAllocationCreateWithoutBedInput = {
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutBedAllocationsInput
    nurse?: NurseCreateNestedOneWithoutBedAllocationsInput
  }

  export type BedAllocationUncheckedCreateWithoutBedInput = {
    id?: number
    patientId: number
    nurseId?: number | null
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationCreateOrConnectWithoutBedInput = {
    where: BedAllocationWhereUniqueInput
    create: XOR<BedAllocationCreateWithoutBedInput, BedAllocationUncheckedCreateWithoutBedInput>
  }

  export type BedAllocationCreateManyBedInputEnvelope = {
    data: BedAllocationCreateManyBedInput | BedAllocationCreateManyBedInput[]
    skipDuplicates?: boolean
  }

  export type WardUpsertWithoutBedsInput = {
    update: XOR<WardUpdateWithoutBedsInput, WardUncheckedUpdateWithoutBedsInput>
    create: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    where?: WardWhereInput
  }

  export type WardUpdateToOneWithWhereWithoutBedsInput = {
    where?: WardWhereInput
    data: XOR<WardUpdateWithoutBedsInput, WardUncheckedUpdateWithoutBedsInput>
  }

  export type WardUpdateWithoutBedsInput = {
    name?: StringFieldUpdateOperationsInput | string
    wardType?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardUncheckedUpdateWithoutBedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    wardType?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUpsertWithWhereUniqueWithoutBedInput = {
    where: BedAllocationWhereUniqueInput
    update: XOR<BedAllocationUpdateWithoutBedInput, BedAllocationUncheckedUpdateWithoutBedInput>
    create: XOR<BedAllocationCreateWithoutBedInput, BedAllocationUncheckedCreateWithoutBedInput>
  }

  export type BedAllocationUpdateWithWhereUniqueWithoutBedInput = {
    where: BedAllocationWhereUniqueInput
    data: XOR<BedAllocationUpdateWithoutBedInput, BedAllocationUncheckedUpdateWithoutBedInput>
  }

  export type BedAllocationUpdateManyWithWhereWithoutBedInput = {
    where: BedAllocationScalarWhereInput
    data: XOR<BedAllocationUpdateManyMutationInput, BedAllocationUncheckedUpdateManyWithoutBedInput>
  }

  export type BedCreateWithoutWardInput = {
    bedNumber: string
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bedAllocations?: BedAllocationCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateWithoutWardInput = {
    id?: number
    bedNumber: string
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedCreateOrConnectWithoutWardInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput>
  }

  export type BedCreateManyWardInputEnvelope = {
    data: BedCreateManyWardInput | BedCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type BedUpsertWithWhereUniqueWithoutWardInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutWardInput, BedUncheckedUpdateWithoutWardInput>
    create: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput>
  }

  export type BedUpdateWithWhereUniqueWithoutWardInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutWardInput, BedUncheckedUpdateWithoutWardInput>
  }

  export type BedUpdateManyWithWhereWithoutWardInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutWardInput>
  }

  export type BedScalarWhereInput = {
    AND?: BedScalarWhereInput | BedScalarWhereInput[]
    OR?: BedScalarWhereInput[]
    NOT?: BedScalarWhereInput | BedScalarWhereInput[]
    id?: IntFilter<"Bed"> | number
    bedNumber?: StringFilter<"Bed"> | string
    wardId?: IntFilter<"Bed"> | number
    status?: StringFilter<"Bed"> | string
    price?: DecimalFilter<"Bed"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
  }

  export type BedCreateWithoutBedAllocationsInput = {
    bedNumber: string
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ward: WardCreateNestedOneWithoutBedsInput
  }

  export type BedUncheckedCreateWithoutBedAllocationsInput = {
    id?: number
    bedNumber: string
    wardId: number
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedCreateOrConnectWithoutBedAllocationsInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutBedAllocationsInput, BedUncheckedCreateWithoutBedAllocationsInput>
  }

  export type PatientCreateWithoutBedAllocationsInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBedAllocationsInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBedAllocationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBedAllocationsInput, PatientUncheckedCreateWithoutBedAllocationsInput>
  }

  export type NurseCreateWithoutBedAllocationsInput = {
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNurseInput
    vitalSigns?: VitalSignCreateNestedManyWithoutNurseInput
  }

  export type NurseUncheckedCreateWithoutBedAllocationsInput = {
    id?: number
    userId: number
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutNurseInput
  }

  export type NurseCreateOrConnectWithoutBedAllocationsInput = {
    where: NurseWhereUniqueInput
    create: XOR<NurseCreateWithoutBedAllocationsInput, NurseUncheckedCreateWithoutBedAllocationsInput>
  }

  export type BedUpsertWithoutBedAllocationsInput = {
    update: XOR<BedUpdateWithoutBedAllocationsInput, BedUncheckedUpdateWithoutBedAllocationsInput>
    create: XOR<BedCreateWithoutBedAllocationsInput, BedUncheckedCreateWithoutBedAllocationsInput>
    where?: BedWhereInput
  }

  export type BedUpdateToOneWithWhereWithoutBedAllocationsInput = {
    where?: BedWhereInput
    data: XOR<BedUpdateWithoutBedAllocationsInput, BedUncheckedUpdateWithoutBedAllocationsInput>
  }

  export type BedUpdateWithoutBedAllocationsInput = {
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
  }

  export type BedUncheckedUpdateWithoutBedAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedNumber?: StringFieldUpdateOperationsInput | string
    wardId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpsertWithoutBedAllocationsInput = {
    update: XOR<PatientUpdateWithoutBedAllocationsInput, PatientUncheckedUpdateWithoutBedAllocationsInput>
    create: XOR<PatientCreateWithoutBedAllocationsInput, PatientUncheckedCreateWithoutBedAllocationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutBedAllocationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutBedAllocationsInput, PatientUncheckedUpdateWithoutBedAllocationsInput>
  }

  export type PatientUpdateWithoutBedAllocationsInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBedAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type NurseUpsertWithoutBedAllocationsInput = {
    update: XOR<NurseUpdateWithoutBedAllocationsInput, NurseUncheckedUpdateWithoutBedAllocationsInput>
    create: XOR<NurseCreateWithoutBedAllocationsInput, NurseUncheckedCreateWithoutBedAllocationsInput>
    where?: NurseWhereInput
  }

  export type NurseUpdateToOneWithWhereWithoutBedAllocationsInput = {
    where?: NurseWhereInput
    data: XOR<NurseUpdateWithoutBedAllocationsInput, NurseUncheckedUpdateWithoutBedAllocationsInput>
  }

  export type NurseUpdateWithoutBedAllocationsInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNurseNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutNurseNestedInput
  }

  export type NurseUncheckedUpdateWithoutBedAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type PatientCreateWithoutVitalSignsInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutVitalSignsInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutVitalSignsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutVitalSignsInput, PatientUncheckedCreateWithoutVitalSignsInput>
  }

  export type NurseCreateWithoutVitalSignsInput = {
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNurseInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutNurseInput
  }

  export type NurseUncheckedCreateWithoutVitalSignsInput = {
    id?: number
    userId: number
    licenseNumber: string
    qualification: string
    experience?: number
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutNurseInput
  }

  export type NurseCreateOrConnectWithoutVitalSignsInput = {
    where: NurseWhereUniqueInput
    create: XOR<NurseCreateWithoutVitalSignsInput, NurseUncheckedCreateWithoutVitalSignsInput>
  }

  export type PatientUpsertWithoutVitalSignsInput = {
    update: XOR<PatientUpdateWithoutVitalSignsInput, PatientUncheckedUpdateWithoutVitalSignsInput>
    create: XOR<PatientCreateWithoutVitalSignsInput, PatientUncheckedCreateWithoutVitalSignsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutVitalSignsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutVitalSignsInput, PatientUncheckedUpdateWithoutVitalSignsInput>
  }

  export type PatientUpdateWithoutVitalSignsInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutVitalSignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type NurseUpsertWithoutVitalSignsInput = {
    update: XOR<NurseUpdateWithoutVitalSignsInput, NurseUncheckedUpdateWithoutVitalSignsInput>
    create: XOR<NurseCreateWithoutVitalSignsInput, NurseUncheckedCreateWithoutVitalSignsInput>
    where?: NurseWhereInput
  }

  export type NurseUpdateToOneWithWhereWithoutVitalSignsInput = {
    where?: NurseWhereInput
    data: XOR<NurseUpdateWithoutVitalSignsInput, NurseUncheckedUpdateWithoutVitalSignsInput>
  }

  export type NurseUpdateWithoutVitalSignsInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNurseNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutNurseNestedInput
  }

  export type NurseUncheckedUpdateWithoutVitalSignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type DoctorCreateWithoutOperationTheatersInput = {
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    labReports?: LabReportCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutOperationTheatersInput = {
    id?: number
    userId: number
    specialization: string
    qualification: string
    experience?: number
    licenseNumber: string
    consultationFee?: Decimal | DecimalJsLike | number | string
    availableDays?: string | null
    availableTimeStart?: string | null
    availableTimeEnd?: string | null
    department?: string | null
    bio?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutDoctorInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutOperationTheatersInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutOperationTheatersInput, DoctorUncheckedCreateWithoutOperationTheatersInput>
  }

  export type SurgeryCreateWithoutOperationTheaterInput = {
    patientId: number
    surgeryDate: Date | string
    startTime: string
    endTime: string
    surgeryType: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurgeryUncheckedCreateWithoutOperationTheaterInput = {
    id?: number
    patientId: number
    surgeryDate: Date | string
    startTime: string
    endTime: string
    surgeryType: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurgeryCreateOrConnectWithoutOperationTheaterInput = {
    where: SurgeryWhereUniqueInput
    create: XOR<SurgeryCreateWithoutOperationTheaterInput, SurgeryUncheckedCreateWithoutOperationTheaterInput>
  }

  export type SurgeryCreateManyOperationTheaterInputEnvelope = {
    data: SurgeryCreateManyOperationTheaterInput | SurgeryCreateManyOperationTheaterInput[]
    skipDuplicates?: boolean
  }

  export type OperationTheaterEquipmentCreateWithoutOperationTheaterInput = {
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    purchaseDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput = {
    id?: number
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    purchaseDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterEquipmentCreateOrConnectWithoutOperationTheaterInput = {
    where: OperationTheaterEquipmentWhereUniqueInput
    create: XOR<OperationTheaterEquipmentCreateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput>
  }

  export type OperationTheaterEquipmentCreateManyOperationTheaterInputEnvelope = {
    data: OperationTheaterEquipmentCreateManyOperationTheaterInput | OperationTheaterEquipmentCreateManyOperationTheaterInput[]
    skipDuplicates?: boolean
  }

  export type DoctorUpsertWithoutOperationTheatersInput = {
    update: XOR<DoctorUpdateWithoutOperationTheatersInput, DoctorUncheckedUpdateWithoutOperationTheatersInput>
    create: XOR<DoctorCreateWithoutOperationTheatersInput, DoctorUncheckedCreateWithoutOperationTheatersInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutOperationTheatersInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutOperationTheatersInput, DoctorUncheckedUpdateWithoutOperationTheatersInput>
  }

  export type DoctorUpdateWithoutOperationTheatersInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutOperationTheatersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    licenseNumber?: StringFieldUpdateOperationsInput | string
    consultationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableDays?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeStart?: NullableStringFieldUpdateOperationsInput | string | null
    availableTimeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutDoctorNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SurgeryUpsertWithWhereUniqueWithoutOperationTheaterInput = {
    where: SurgeryWhereUniqueInput
    update: XOR<SurgeryUpdateWithoutOperationTheaterInput, SurgeryUncheckedUpdateWithoutOperationTheaterInput>
    create: XOR<SurgeryCreateWithoutOperationTheaterInput, SurgeryUncheckedCreateWithoutOperationTheaterInput>
  }

  export type SurgeryUpdateWithWhereUniqueWithoutOperationTheaterInput = {
    where: SurgeryWhereUniqueInput
    data: XOR<SurgeryUpdateWithoutOperationTheaterInput, SurgeryUncheckedUpdateWithoutOperationTheaterInput>
  }

  export type SurgeryUpdateManyWithWhereWithoutOperationTheaterInput = {
    where: SurgeryScalarWhereInput
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyWithoutOperationTheaterInput>
  }

  export type SurgeryScalarWhereInput = {
    AND?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
    OR?: SurgeryScalarWhereInput[]
    NOT?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
    id?: IntFilter<"Surgery"> | number
    patientId?: IntFilter<"Surgery"> | number
    operationTheaterId?: IntFilter<"Surgery"> | number
    surgeryDate?: DateTimeFilter<"Surgery"> | Date | string
    startTime?: StringFilter<"Surgery"> | string
    endTime?: StringFilter<"Surgery"> | string
    surgeryType?: StringFilter<"Surgery"> | string
    notes?: StringNullableFilter<"Surgery"> | string | null
    status?: StringFilter<"Surgery"> | string
    createdAt?: DateTimeFilter<"Surgery"> | Date | string
    updatedAt?: DateTimeFilter<"Surgery"> | Date | string
  }

  export type OperationTheaterEquipmentUpsertWithWhereUniqueWithoutOperationTheaterInput = {
    where: OperationTheaterEquipmentWhereUniqueInput
    update: XOR<OperationTheaterEquipmentUpdateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedUpdateWithoutOperationTheaterInput>
    create: XOR<OperationTheaterEquipmentCreateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedCreateWithoutOperationTheaterInput>
  }

  export type OperationTheaterEquipmentUpdateWithWhereUniqueWithoutOperationTheaterInput = {
    where: OperationTheaterEquipmentWhereUniqueInput
    data: XOR<OperationTheaterEquipmentUpdateWithoutOperationTheaterInput, OperationTheaterEquipmentUncheckedUpdateWithoutOperationTheaterInput>
  }

  export type OperationTheaterEquipmentUpdateManyWithWhereWithoutOperationTheaterInput = {
    where: OperationTheaterEquipmentScalarWhereInput
    data: XOR<OperationTheaterEquipmentUpdateManyMutationInput, OperationTheaterEquipmentUncheckedUpdateManyWithoutOperationTheaterInput>
  }

  export type OperationTheaterEquipmentScalarWhereInput = {
    AND?: OperationTheaterEquipmentScalarWhereInput | OperationTheaterEquipmentScalarWhereInput[]
    OR?: OperationTheaterEquipmentScalarWhereInput[]
    NOT?: OperationTheaterEquipmentScalarWhereInput | OperationTheaterEquipmentScalarWhereInput[]
    id?: IntFilter<"OperationTheaterEquipment"> | number
    operationTheaterId?: IntFilter<"OperationTheaterEquipment"> | number
    name?: StringFilter<"OperationTheaterEquipment"> | string
    serialNumber?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    manufacturer?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    purchaseDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"OperationTheaterEquipment"> | Date | string | null
    status?: StringFilter<"OperationTheaterEquipment"> | string
    notes?: StringNullableFilter<"OperationTheaterEquipment"> | string | null
    createdAt?: DateTimeFilter<"OperationTheaterEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"OperationTheaterEquipment"> | Date | string
  }

  export type OperationTheaterCreateWithoutSurgeriesInput = {
    name: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: DoctorCreateNestedOneWithoutOperationTheatersInput
    equipments?: OperationTheaterEquipmentCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterUncheckedCreateWithoutSurgeriesInput = {
    id?: number
    name: string
    location?: string | null
    status?: string
    doctorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipments?: OperationTheaterEquipmentUncheckedCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterCreateOrConnectWithoutSurgeriesInput = {
    where: OperationTheaterWhereUniqueInput
    create: XOR<OperationTheaterCreateWithoutSurgeriesInput, OperationTheaterUncheckedCreateWithoutSurgeriesInput>
  }

  export type OperationTheaterUpsertWithoutSurgeriesInput = {
    update: XOR<OperationTheaterUpdateWithoutSurgeriesInput, OperationTheaterUncheckedUpdateWithoutSurgeriesInput>
    create: XOR<OperationTheaterCreateWithoutSurgeriesInput, OperationTheaterUncheckedCreateWithoutSurgeriesInput>
    where?: OperationTheaterWhereInput
  }

  export type OperationTheaterUpdateToOneWithWhereWithoutSurgeriesInput = {
    where?: OperationTheaterWhereInput
    data: XOR<OperationTheaterUpdateWithoutSurgeriesInput, OperationTheaterUncheckedUpdateWithoutSurgeriesInput>
  }

  export type OperationTheaterUpdateWithoutSurgeriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneWithoutOperationTheatersNestedInput
    equipments?: OperationTheaterEquipmentUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterUncheckedUpdateWithoutSurgeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipments?: OperationTheaterEquipmentUncheckedUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterCreateWithoutEquipmentsInput = {
    name: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: DoctorCreateNestedOneWithoutOperationTheatersInput
    surgeries?: SurgeryCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterUncheckedCreateWithoutEquipmentsInput = {
    id?: number
    name: string
    location?: string | null
    status?: string
    doctorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutOperationTheaterInput
  }

  export type OperationTheaterCreateOrConnectWithoutEquipmentsInput = {
    where: OperationTheaterWhereUniqueInput
    create: XOR<OperationTheaterCreateWithoutEquipmentsInput, OperationTheaterUncheckedCreateWithoutEquipmentsInput>
  }

  export type OperationTheaterUpsertWithoutEquipmentsInput = {
    update: XOR<OperationTheaterUpdateWithoutEquipmentsInput, OperationTheaterUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<OperationTheaterCreateWithoutEquipmentsInput, OperationTheaterUncheckedCreateWithoutEquipmentsInput>
    where?: OperationTheaterWhereInput
  }

  export type OperationTheaterUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: OperationTheaterWhereInput
    data: XOR<OperationTheaterUpdateWithoutEquipmentsInput, OperationTheaterUncheckedUpdateWithoutEquipmentsInput>
  }

  export type OperationTheaterUpdateWithoutEquipmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneWithoutOperationTheatersNestedInput
    surgeries?: SurgeryUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterUncheckedUpdateWithoutEquipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surgeries?: SurgeryUncheckedUpdateManyWithoutOperationTheaterNestedInput
  }

  export type AmbulanceServiceCreateWithoutAmbulanceInput = {
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date | string
    status?: string
    fare?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceServiceUncheckedCreateWithoutAmbulanceInput = {
    id?: number
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date | string
    status?: string
    fare?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceServiceCreateOrConnectWithoutAmbulanceInput = {
    where: AmbulanceServiceWhereUniqueInput
    create: XOR<AmbulanceServiceCreateWithoutAmbulanceInput, AmbulanceServiceUncheckedCreateWithoutAmbulanceInput>
  }

  export type AmbulanceServiceCreateManyAmbulanceInputEnvelope = {
    data: AmbulanceServiceCreateManyAmbulanceInput | AmbulanceServiceCreateManyAmbulanceInput[]
    skipDuplicates?: boolean
  }

  export type AmbulanceServiceUpsertWithWhereUniqueWithoutAmbulanceInput = {
    where: AmbulanceServiceWhereUniqueInput
    update: XOR<AmbulanceServiceUpdateWithoutAmbulanceInput, AmbulanceServiceUncheckedUpdateWithoutAmbulanceInput>
    create: XOR<AmbulanceServiceCreateWithoutAmbulanceInput, AmbulanceServiceUncheckedCreateWithoutAmbulanceInput>
  }

  export type AmbulanceServiceUpdateWithWhereUniqueWithoutAmbulanceInput = {
    where: AmbulanceServiceWhereUniqueInput
    data: XOR<AmbulanceServiceUpdateWithoutAmbulanceInput, AmbulanceServiceUncheckedUpdateWithoutAmbulanceInput>
  }

  export type AmbulanceServiceUpdateManyWithWhereWithoutAmbulanceInput = {
    where: AmbulanceServiceScalarWhereInput
    data: XOR<AmbulanceServiceUpdateManyMutationInput, AmbulanceServiceUncheckedUpdateManyWithoutAmbulanceInput>
  }

  export type AmbulanceServiceScalarWhereInput = {
    AND?: AmbulanceServiceScalarWhereInput | AmbulanceServiceScalarWhereInput[]
    OR?: AmbulanceServiceScalarWhereInput[]
    NOT?: AmbulanceServiceScalarWhereInput | AmbulanceServiceScalarWhereInput[]
    id?: IntFilter<"AmbulanceService"> | number
    ambulanceId?: IntFilter<"AmbulanceService"> | number
    patientName?: StringFilter<"AmbulanceService"> | string
    patientContact?: StringFilter<"AmbulanceService"> | string
    pickupLocation?: StringFilter<"AmbulanceService"> | string
    dropLocation?: StringFilter<"AmbulanceService"> | string
    serviceDate?: DateTimeFilter<"AmbulanceService"> | Date | string
    status?: StringFilter<"AmbulanceService"> | string
    fare?: DecimalFilter<"AmbulanceService"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AmbulanceService"> | string | null
    createdAt?: DateTimeFilter<"AmbulanceService"> | Date | string
    updatedAt?: DateTimeFilter<"AmbulanceService"> | Date | string
  }

  export type AmbulanceCreateWithoutAmbulanceServicesInput = {
    vehicleNumber: string
    model?: string | null
    type: string
    capacity?: number
    driverName?: string | null
    driverContact?: string | null
    status?: string
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceUncheckedCreateWithoutAmbulanceServicesInput = {
    id?: number
    vehicleNumber: string
    model?: string | null
    type: string
    capacity?: number
    driverName?: string | null
    driverContact?: string | null
    status?: string
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceCreateOrConnectWithoutAmbulanceServicesInput = {
    where: AmbulanceWhereUniqueInput
    create: XOR<AmbulanceCreateWithoutAmbulanceServicesInput, AmbulanceUncheckedCreateWithoutAmbulanceServicesInput>
  }

  export type AmbulanceUpsertWithoutAmbulanceServicesInput = {
    update: XOR<AmbulanceUpdateWithoutAmbulanceServicesInput, AmbulanceUncheckedUpdateWithoutAmbulanceServicesInput>
    create: XOR<AmbulanceCreateWithoutAmbulanceServicesInput, AmbulanceUncheckedCreateWithoutAmbulanceServicesInput>
    where?: AmbulanceWhereInput
  }

  export type AmbulanceUpdateToOneWithWhereWithoutAmbulanceServicesInput = {
    where?: AmbulanceWhereInput
    data: XOR<AmbulanceUpdateWithoutAmbulanceServicesInput, AmbulanceUncheckedUpdateWithoutAmbulanceServicesInput>
  }

  export type AmbulanceUpdateWithoutAmbulanceServicesInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceUncheckedUpdateWithoutAmbulanceServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    driverContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBiometricDataInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBiometricDataInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBiometricDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
  }

  export type UserUpsertWithoutBiometricDataInput = {
    update: XOR<UserUpdateWithoutBiometricDataInput, UserUncheckedUpdateWithoutBiometricDataInput>
    create: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBiometricDataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBiometricDataInput, UserUncheckedUpdateWithoutBiometricDataInput>
  }

  export type UserUpdateWithoutBiometricDataInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBiometricDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAttendanceLogsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceLogsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceLogsInput, UserUncheckedCreateWithoutAttendanceLogsInput>
  }

  export type UserUpsertWithoutAttendanceLogsInput = {
    update: XOR<UserUpdateWithoutAttendanceLogsInput, UserUncheckedUpdateWithoutAttendanceLogsInput>
    create: XOR<UserCreateWithoutAttendanceLogsInput, UserUncheckedCreateWithoutAttendanceLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceLogsInput, UserUncheckedUpdateWithoutAttendanceLogsInput>
  }

  export type UserUpdateWithoutAttendanceLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutDutyRostersInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDutyRostersInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDutyRostersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDutyRostersInput, UserUncheckedCreateWithoutDutyRostersInput>
  }

  export type UserUpsertWithoutDutyRostersInput = {
    update: XOR<UserUpdateWithoutDutyRostersInput, UserUncheckedUpdateWithoutDutyRostersInput>
    create: XOR<UserCreateWithoutDutyRostersInput, UserUncheckedCreateWithoutDutyRostersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDutyRostersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDutyRostersInput, UserUncheckedUpdateWithoutDutyRostersInput>
  }

  export type UserUpdateWithoutDutyRostersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDutyRostersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PatientCreateWithoutTpaInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTpaInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTpaInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTpaInput, PatientUncheckedCreateWithoutTpaInput>
  }

  export type PatientCreateManyTpaInputEnvelope = {
    data: PatientCreateManyTpaInput | PatientCreateManyTpaInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithWhereUniqueWithoutTpaInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutTpaInput, PatientUncheckedUpdateWithoutTpaInput>
    create: XOR<PatientCreateWithoutTpaInput, PatientUncheckedCreateWithoutTpaInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutTpaInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutTpaInput, PatientUncheckedUpdateWithoutTpaInput>
  }

  export type PatientUpdateManyWithWhereWithoutTpaInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutTpaInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: IntFilter<"Patient"> | number
    userId?: IntFilter<"Patient"> | number
    patientId?: StringFilter<"Patient"> | string
    bloodGroup?: StringNullableFilter<"Patient"> | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    chronicDiseases?: StringNullableFilter<"Patient"> | string | null
    emergencyContact?: StringNullableFilter<"Patient"> | string | null
    emergencyName?: StringNullableFilter<"Patient"> | string | null
    emergencyRelation?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insuranceId?: StringNullableFilter<"Patient"> | string | null
    tpaId?: IntNullableFilter<"Patient"> | number | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type UserCreateWithoutEmployeeInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    housekeepingStaff?: HousekeepingStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    housekeepingStaff?: HousekeepingStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveCreateWithoutEmployeeInput = {
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUncheckedCreateWithoutEmployeeInput = {
    id?: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveCreateManyEmployeeInputEnvelope = {
    data: LeaveCreateManyEmployeeInput | LeaveCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SalaryPaymentCreateWithoutEmployeeInput = {
    paymentDate: Date | string
    salaryMonth: string
    basicSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    taxDeducted?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentUncheckedCreateWithoutEmployeeInput = {
    id?: number
    paymentDate: Date | string
    salaryMonth: string
    basicSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    taxDeducted?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentCreateOrConnectWithoutEmployeeInput = {
    where: SalaryPaymentWhereUniqueInput
    create: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentCreateManyEmployeeInputEnvelope = {
    data: SalaryPaymentCreateManyEmployeeInput | SalaryPaymentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeDocumentCreateWithoutEmployeeInput = {
    documentType: string
    documentName: string
    documentUrl: string
    isVerified?: boolean
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentUncheckedCreateWithoutEmployeeInput = {
    id?: number
    documentType: string
    documentName: string
    documentUrl: string
    isVerified?: boolean
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeDocumentWhereUniqueInput
    create: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeDocumentCreateManyEmployeeInputEnvelope = {
    data: EmployeeDocumentCreateManyEmployeeInput | EmployeeDocumentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReviewCreateWithoutEmployeeInput = {
    reviewDate: Date | string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    reviewedBy: number
    rating: number
    strengths?: string | null
    areasOfImprovement?: string | null
    goals?: string | null
    comments?: string | null
    employeeComments?: string | null
    status?: string
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewUncheckedCreateWithoutEmployeeInput = {
    id?: number
    reviewDate: Date | string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    reviewedBy: number
    rating: number
    strengths?: string | null
    areasOfImprovement?: string | null
    goals?: string | null
    comments?: string | null
    employeeComments?: string | null
    status?: string
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewCreateOrConnectWithoutEmployeeInput = {
    where: PerformanceReviewWhereUniqueInput
    create: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput>
  }

  export type PerformanceReviewCreateManyEmployeeInputEnvelope = {
    data: PerformanceReviewCreateManyEmployeeInput | PerformanceReviewCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LeaveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: IntFilter<"Leave"> | number
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    totalDays?: IntFilter<"Leave"> | number
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    notes?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
  }

  export type SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentWhereUniqueInput
    update: XOR<SalaryPaymentUpdateWithoutEmployeeInput, SalaryPaymentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentWhereUniqueInput
    data: XOR<SalaryPaymentUpdateWithoutEmployeeInput, SalaryPaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryPaymentScalarWhereInput
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryPaymentScalarWhereInput = {
    AND?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    OR?: SalaryPaymentScalarWhereInput[]
    NOT?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    id?: IntFilter<"SalaryPayment"> | number
    employeeId?: IntFilter<"SalaryPayment"> | number
    paymentDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    salaryMonth?: StringFilter<"SalaryPayment"> | string
    basicSalary?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"SalaryPayment"> | string
    transactionId?: StringNullableFilter<"SalaryPayment"> | string | null
    status?: StringFilter<"SalaryPayment"> | string
    notes?: StringNullableFilter<"SalaryPayment"> | string | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
  }

  export type EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeDocumentWhereUniqueInput
    update: XOR<EmployeeDocumentUpdateWithoutEmployeeInput, EmployeeDocumentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeDocumentWhereUniqueInput
    data: XOR<EmployeeDocumentUpdateWithoutEmployeeInput, EmployeeDocumentUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeDocumentScalarWhereInput
    data: XOR<EmployeeDocumentUpdateManyMutationInput, EmployeeDocumentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeDocumentScalarWhereInput = {
    AND?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
    OR?: EmployeeDocumentScalarWhereInput[]
    NOT?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
    id?: IntFilter<"EmployeeDocument"> | number
    employeeId?: IntFilter<"EmployeeDocument"> | number
    documentType?: StringFilter<"EmployeeDocument"> | string
    documentName?: StringFilter<"EmployeeDocument"> | string
    documentUrl?: StringFilter<"EmployeeDocument"> | string
    isVerified?: BoolFilter<"EmployeeDocument"> | boolean
    verifiedBy?: IntNullableFilter<"EmployeeDocument"> | number | null
    verifiedAt?: DateTimeNullableFilter<"EmployeeDocument"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeDocument"> | string | null
    createdAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
  }

  export type PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PerformanceReviewWhereUniqueInput
    update: XOR<PerformanceReviewUpdateWithoutEmployeeInput, PerformanceReviewUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput>
  }

  export type PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PerformanceReviewWhereUniqueInput
    data: XOR<PerformanceReviewUpdateWithoutEmployeeInput, PerformanceReviewUncheckedUpdateWithoutEmployeeInput>
  }

  export type PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput = {
    where: PerformanceReviewScalarWhereInput
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PerformanceReviewScalarWhereInput = {
    AND?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    OR?: PerformanceReviewScalarWhereInput[]
    NOT?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    id?: IntFilter<"PerformanceReview"> | number
    employeeId?: IntFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewedBy?: IntFilter<"PerformanceReview"> | number
    rating?: IntFilter<"PerformanceReview"> | number
    strengths?: StringNullableFilter<"PerformanceReview"> | string | null
    areasOfImprovement?: StringNullableFilter<"PerformanceReview"> | string | null
    goals?: StringNullableFilter<"PerformanceReview"> | string | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    employeeComments?: StringNullableFilter<"PerformanceReview"> | string | null
    status?: StringFilter<"PerformanceReview"> | string
    acknowledgedAt?: DateTimeNullableFilter<"PerformanceReview"> | Date | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
  }

  export type EmployeeCreateWithoutLeavesInput = {
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    salaryPayments?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryPayments?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryPayments?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutSalaryPaymentsInput = {
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSalaryPaymentsInput = {
    id?: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSalaryPaymentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalaryPaymentsInput, EmployeeUncheckedCreateWithoutSalaryPaymentsInput>
  }

  export type EmployeeUpsertWithoutSalaryPaymentsInput = {
    update: XOR<EmployeeUpdateWithoutSalaryPaymentsInput, EmployeeUncheckedUpdateWithoutSalaryPaymentsInput>
    create: XOR<EmployeeCreateWithoutSalaryPaymentsInput, EmployeeUncheckedCreateWithoutSalaryPaymentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSalaryPaymentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSalaryPaymentsInput, EmployeeUncheckedUpdateWithoutSalaryPaymentsInput>
  }

  export type EmployeeUpdateWithoutSalaryPaymentsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSalaryPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutDocumentsInput = {
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDocumentsInput = {
    id?: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDocumentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type EmployeeUpsertWithoutDocumentsInput = {
    update: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeUpdateWithoutDocumentsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutPerformanceReviewsInput = {
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPerformanceReviewsInput = {
    id?: number
    userId: number
    employeeId: string
    department: string
    position: string
    joiningDate: Date | string
    contractType: string
    contractEndDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    salaryPayments?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPerformanceReviewsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
  }

  export type EmployeeUpsertWithoutPerformanceReviewsInput = {
    update: XOR<EmployeeUpdateWithoutPerformanceReviewsInput, EmployeeUncheckedUpdateWithoutPerformanceReviewsInput>
    create: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPerformanceReviewsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPerformanceReviewsInput, EmployeeUncheckedUpdateWithoutPerformanceReviewsInput>
  }

  export type EmployeeUpdateWithoutPerformanceReviewsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPerformanceReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryPayments?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PatientSubsidyCreateWithoutSchemeInput = {
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPatientSubsidiesInput
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutPatientSubsidyInput
  }

  export type PatientSubsidyUncheckedCreateWithoutSchemeInput = {
    id?: number
    patientId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutPatientSubsidyInput
  }

  export type PatientSubsidyCreateOrConnectWithoutSchemeInput = {
    where: PatientSubsidyWhereUniqueInput
    create: XOR<PatientSubsidyCreateWithoutSchemeInput, PatientSubsidyUncheckedCreateWithoutSchemeInput>
  }

  export type PatientSubsidyCreateManySchemeInputEnvelope = {
    data: PatientSubsidyCreateManySchemeInput | PatientSubsidyCreateManySchemeInput[]
    skipDuplicates?: boolean
  }

  export type SubsidyClaimCreateWithoutSchemeInput = {
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidy: PatientSubsidyCreateNestedOneWithoutSubsidyClaimsInput
    invoice?: InvoiceCreateNestedOneWithoutSubsidyClaimsInput
  }

  export type SubsidyClaimUncheckedCreateWithoutSchemeInput = {
    id?: number
    patientSubsidyId: number
    invoiceId?: number | null
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimCreateOrConnectWithoutSchemeInput = {
    where: SubsidyClaimWhereUniqueInput
    create: XOR<SubsidyClaimCreateWithoutSchemeInput, SubsidyClaimUncheckedCreateWithoutSchemeInput>
  }

  export type SubsidyClaimCreateManySchemeInputEnvelope = {
    data: SubsidyClaimCreateManySchemeInput | SubsidyClaimCreateManySchemeInput[]
    skipDuplicates?: boolean
  }

  export type PatientSubsidyUpsertWithWhereUniqueWithoutSchemeInput = {
    where: PatientSubsidyWhereUniqueInput
    update: XOR<PatientSubsidyUpdateWithoutSchemeInput, PatientSubsidyUncheckedUpdateWithoutSchemeInput>
    create: XOR<PatientSubsidyCreateWithoutSchemeInput, PatientSubsidyUncheckedCreateWithoutSchemeInput>
  }

  export type PatientSubsidyUpdateWithWhereUniqueWithoutSchemeInput = {
    where: PatientSubsidyWhereUniqueInput
    data: XOR<PatientSubsidyUpdateWithoutSchemeInput, PatientSubsidyUncheckedUpdateWithoutSchemeInput>
  }

  export type PatientSubsidyUpdateManyWithWhereWithoutSchemeInput = {
    where: PatientSubsidyScalarWhereInput
    data: XOR<PatientSubsidyUpdateManyMutationInput, PatientSubsidyUncheckedUpdateManyWithoutSchemeInput>
  }

  export type SubsidyClaimUpsertWithWhereUniqueWithoutSchemeInput = {
    where: SubsidyClaimWhereUniqueInput
    update: XOR<SubsidyClaimUpdateWithoutSchemeInput, SubsidyClaimUncheckedUpdateWithoutSchemeInput>
    create: XOR<SubsidyClaimCreateWithoutSchemeInput, SubsidyClaimUncheckedCreateWithoutSchemeInput>
  }

  export type SubsidyClaimUpdateWithWhereUniqueWithoutSchemeInput = {
    where: SubsidyClaimWhereUniqueInput
    data: XOR<SubsidyClaimUpdateWithoutSchemeInput, SubsidyClaimUncheckedUpdateWithoutSchemeInput>
  }

  export type SubsidyClaimUpdateManyWithWhereWithoutSchemeInput = {
    where: SubsidyClaimScalarWhereInput
    data: XOR<SubsidyClaimUpdateManyMutationInput, SubsidyClaimUncheckedUpdateManyWithoutSchemeInput>
  }

  export type PatientCreateWithoutPatientSubsidiesInput = {
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    tpa?: TPACreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    labReports?: LabReportCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPatientSubsidiesInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    tpaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    labReports?: LabReportUncheckedCreateNestedManyWithoutPatientInput
    radiologyReports?: RadiologyReportUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientDetailsInput
    bedAllocations?: BedAllocationUncheckedCreateNestedManyWithoutPatientInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPatientSubsidiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPatientSubsidiesInput, PatientUncheckedCreateWithoutPatientSubsidiesInput>
  }

  export type SubsidySchemeCreateWithoutPatientSubsidiesInput = {
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subsidyClaims?: SubsidyClaimCreateNestedManyWithoutSchemeInput
  }

  export type SubsidySchemeUncheckedCreateWithoutPatientSubsidiesInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subsidyClaims?: SubsidyClaimUncheckedCreateNestedManyWithoutSchemeInput
  }

  export type SubsidySchemeCreateOrConnectWithoutPatientSubsidiesInput = {
    where: SubsidySchemeWhereUniqueInput
    create: XOR<SubsidySchemeCreateWithoutPatientSubsidiesInput, SubsidySchemeUncheckedCreateWithoutPatientSubsidiesInput>
  }

  export type SubsidyClaimCreateWithoutPatientSubsidyInput = {
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scheme: SubsidySchemeCreateNestedOneWithoutSubsidyClaimsInput
    invoice?: InvoiceCreateNestedOneWithoutSubsidyClaimsInput
  }

  export type SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput = {
    id?: number
    schemeId: number
    invoiceId?: number | null
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimCreateOrConnectWithoutPatientSubsidyInput = {
    where: SubsidyClaimWhereUniqueInput
    create: XOR<SubsidyClaimCreateWithoutPatientSubsidyInput, SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput>
  }

  export type SubsidyClaimCreateManyPatientSubsidyInputEnvelope = {
    data: SubsidyClaimCreateManyPatientSubsidyInput | SubsidyClaimCreateManyPatientSubsidyInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPatientSubsidiesInput = {
    update: XOR<PatientUpdateWithoutPatientSubsidiesInput, PatientUncheckedUpdateWithoutPatientSubsidiesInput>
    create: XOR<PatientCreateWithoutPatientSubsidiesInput, PatientUncheckedCreateWithoutPatientSubsidiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPatientSubsidiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPatientSubsidiesInput, PatientUncheckedUpdateWithoutPatientSubsidiesInput>
  }

  export type PatientUpdateWithoutPatientSubsidiesInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    tpa?: TPAUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPatientSubsidiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    tpaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type SubsidySchemeUpsertWithoutPatientSubsidiesInput = {
    update: XOR<SubsidySchemeUpdateWithoutPatientSubsidiesInput, SubsidySchemeUncheckedUpdateWithoutPatientSubsidiesInput>
    create: XOR<SubsidySchemeCreateWithoutPatientSubsidiesInput, SubsidySchemeUncheckedCreateWithoutPatientSubsidiesInput>
    where?: SubsidySchemeWhereInput
  }

  export type SubsidySchemeUpdateToOneWithWhereWithoutPatientSubsidiesInput = {
    where?: SubsidySchemeWhereInput
    data: XOR<SubsidySchemeUpdateWithoutPatientSubsidiesInput, SubsidySchemeUncheckedUpdateWithoutPatientSubsidiesInput>
  }

  export type SubsidySchemeUpdateWithoutPatientSubsidiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subsidyClaims?: SubsidyClaimUpdateManyWithoutSchemeNestedInput
  }

  export type SubsidySchemeUncheckedUpdateWithoutPatientSubsidiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutSchemeNestedInput
  }

  export type SubsidyClaimUpsertWithWhereUniqueWithoutPatientSubsidyInput = {
    where: SubsidyClaimWhereUniqueInput
    update: XOR<SubsidyClaimUpdateWithoutPatientSubsidyInput, SubsidyClaimUncheckedUpdateWithoutPatientSubsidyInput>
    create: XOR<SubsidyClaimCreateWithoutPatientSubsidyInput, SubsidyClaimUncheckedCreateWithoutPatientSubsidyInput>
  }

  export type SubsidyClaimUpdateWithWhereUniqueWithoutPatientSubsidyInput = {
    where: SubsidyClaimWhereUniqueInput
    data: XOR<SubsidyClaimUpdateWithoutPatientSubsidyInput, SubsidyClaimUncheckedUpdateWithoutPatientSubsidyInput>
  }

  export type SubsidyClaimUpdateManyWithWhereWithoutPatientSubsidyInput = {
    where: SubsidyClaimScalarWhereInput
    data: XOR<SubsidyClaimUpdateManyMutationInput, SubsidyClaimUncheckedUpdateManyWithoutPatientSubsidyInput>
  }

  export type PatientSubsidyCreateWithoutSubsidyClaimsInput = {
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutPatientSubsidiesInput
    scheme: SubsidySchemeCreateNestedOneWithoutPatientSubsidiesInput
  }

  export type PatientSubsidyUncheckedCreateWithoutSubsidyClaimsInput = {
    id?: number
    patientId: number
    schemeId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientSubsidyCreateOrConnectWithoutSubsidyClaimsInput = {
    where: PatientSubsidyWhereUniqueInput
    create: XOR<PatientSubsidyCreateWithoutSubsidyClaimsInput, PatientSubsidyUncheckedCreateWithoutSubsidyClaimsInput>
  }

  export type SubsidySchemeCreateWithoutSubsidyClaimsInput = {
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidies?: PatientSubsidyCreateNestedManyWithoutSchemeInput
  }

  export type SubsidySchemeUncheckedCreateWithoutSubsidyClaimsInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    issuingAuthority: string
    startDate: Date | string
    endDate?: Date | string | null
    eligibilityCriteria?: string | null
    subsidyType: string
    percentageValue?: number | null
    fixedAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: Decimal | DecimalJsLike | number | string | null
    applicableServices?: string | null
    documentationRequired?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patientSubsidies?: PatientSubsidyUncheckedCreateNestedManyWithoutSchemeInput
  }

  export type SubsidySchemeCreateOrConnectWithoutSubsidyClaimsInput = {
    where: SubsidySchemeWhereUniqueInput
    create: XOR<SubsidySchemeCreateWithoutSubsidyClaimsInput, SubsidySchemeUncheckedCreateWithoutSubsidyClaimsInput>
  }

  export type InvoiceCreateWithoutSubsidyClaimsInput = {
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: UserCreateNestedOneWithoutInvoicesInput
    patientDetails: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSubsidyClaimsInput = {
    id?: number
    patientId: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSubsidyClaimsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubsidyClaimsInput, InvoiceUncheckedCreateWithoutSubsidyClaimsInput>
  }

  export type PatientSubsidyUpsertWithoutSubsidyClaimsInput = {
    update: XOR<PatientSubsidyUpdateWithoutSubsidyClaimsInput, PatientSubsidyUncheckedUpdateWithoutSubsidyClaimsInput>
    create: XOR<PatientSubsidyCreateWithoutSubsidyClaimsInput, PatientSubsidyUncheckedCreateWithoutSubsidyClaimsInput>
    where?: PatientSubsidyWhereInput
  }

  export type PatientSubsidyUpdateToOneWithWhereWithoutSubsidyClaimsInput = {
    where?: PatientSubsidyWhereInput
    data: XOR<PatientSubsidyUpdateWithoutSubsidyClaimsInput, PatientSubsidyUncheckedUpdateWithoutSubsidyClaimsInput>
  }

  export type PatientSubsidyUpdateWithoutSubsidyClaimsInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPatientSubsidiesNestedInput
    scheme?: SubsidySchemeUpdateOneRequiredWithoutPatientSubsidiesNestedInput
  }

  export type PatientSubsidyUncheckedUpdateWithoutSubsidyClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidySchemeUpsertWithoutSubsidyClaimsInput = {
    update: XOR<SubsidySchemeUpdateWithoutSubsidyClaimsInput, SubsidySchemeUncheckedUpdateWithoutSubsidyClaimsInput>
    create: XOR<SubsidySchemeCreateWithoutSubsidyClaimsInput, SubsidySchemeUncheckedCreateWithoutSubsidyClaimsInput>
    where?: SubsidySchemeWhereInput
  }

  export type SubsidySchemeUpdateToOneWithWhereWithoutSubsidyClaimsInput = {
    where?: SubsidySchemeWhereInput
    data: XOR<SubsidySchemeUpdateWithoutSubsidyClaimsInput, SubsidySchemeUncheckedUpdateWithoutSubsidyClaimsInput>
  }

  export type SubsidySchemeUpdateWithoutSubsidyClaimsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidies?: PatientSubsidyUpdateManyWithoutSchemeNestedInput
  }

  export type SubsidySchemeUncheckedUpdateWithoutSubsidyClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    subsidyType?: StringFieldUpdateOperationsInput | string
    percentageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoverageAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxCoveragePerTreatment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    applicableServices?: NullableStringFieldUpdateOperationsInput | string | null
    documentationRequired?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutSchemeNestedInput
  }

  export type InvoiceUpsertWithoutSubsidyClaimsInput = {
    update: XOR<InvoiceUpdateWithoutSubsidyClaimsInput, InvoiceUncheckedUpdateWithoutSubsidyClaimsInput>
    create: XOR<InvoiceCreateWithoutSubsidyClaimsInput, InvoiceUncheckedCreateWithoutSubsidyClaimsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutSubsidyClaimsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutSubsidyClaimsInput, InvoiceUncheckedUpdateWithoutSubsidyClaimsInput>
  }

  export type InvoiceUpdateWithoutSubsidyClaimsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    patientDetails?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSubsidyClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CleaningTaskCreateWithoutAreaInput = {
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: HousekeepingStaffCreateNestedOneWithoutCleaningTasksInput
    verifications?: CleaningVerificationCreateNestedManyWithoutTaskInput
  }

  export type CleaningTaskUncheckedCreateWithoutAreaInput = {
    id?: number
    assignedToId?: number | null
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifications?: CleaningVerificationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type CleaningTaskCreateOrConnectWithoutAreaInput = {
    where: CleaningTaskWhereUniqueInput
    create: XOR<CleaningTaskCreateWithoutAreaInput, CleaningTaskUncheckedCreateWithoutAreaInput>
  }

  export type CleaningTaskCreateManyAreaInputEnvelope = {
    data: CleaningTaskCreateManyAreaInput | CleaningTaskCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type CleaningTaskUpsertWithWhereUniqueWithoutAreaInput = {
    where: CleaningTaskWhereUniqueInput
    update: XOR<CleaningTaskUpdateWithoutAreaInput, CleaningTaskUncheckedUpdateWithoutAreaInput>
    create: XOR<CleaningTaskCreateWithoutAreaInput, CleaningTaskUncheckedCreateWithoutAreaInput>
  }

  export type CleaningTaskUpdateWithWhereUniqueWithoutAreaInput = {
    where: CleaningTaskWhereUniqueInput
    data: XOR<CleaningTaskUpdateWithoutAreaInput, CleaningTaskUncheckedUpdateWithoutAreaInput>
  }

  export type CleaningTaskUpdateManyWithWhereWithoutAreaInput = {
    where: CleaningTaskScalarWhereInput
    data: XOR<CleaningTaskUpdateManyMutationInput, CleaningTaskUncheckedUpdateManyWithoutAreaInput>
  }

  export type CleaningTaskScalarWhereInput = {
    AND?: CleaningTaskScalarWhereInput | CleaningTaskScalarWhereInput[]
    OR?: CleaningTaskScalarWhereInput[]
    NOT?: CleaningTaskScalarWhereInput | CleaningTaskScalarWhereInput[]
    id?: IntFilter<"CleaningTask"> | number
    areaId?: IntFilter<"CleaningTask"> | number
    assignedToId?: IntNullableFilter<"CleaningTask"> | number | null
    scheduledDate?: DateTimeFilter<"CleaningTask"> | Date | string
    scheduledTime?: StringFilter<"CleaningTask"> | string
    estimatedDuration?: IntFilter<"CleaningTask"> | number
    priority?: StringFilter<"CleaningTask"> | string
    status?: StringFilter<"CleaningTask"> | string
    startedAt?: DateTimeNullableFilter<"CleaningTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CleaningTask"> | Date | string | null
    notes?: StringNullableFilter<"CleaningTask"> | string | null
    createdAt?: DateTimeFilter<"CleaningTask"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningTask"> | Date | string
  }

  export type UserCreateWithoutHousekeepingStaffInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    doctor?: DoctorCreateNestedOneWithoutUserInput
    patient?: PatientCreateNestedOneWithoutUserInput
    nurse?: NurseCreateNestedOneWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHousekeepingStaffInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    roleId?: number | null
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    nurse?: NurseUncheckedCreateNestedOneWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    biometricData?: BiometricDataUncheckedCreateNestedOneWithoutUserInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutUserInput
    dutyRosters?: DutyRosterUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHousekeepingStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHousekeepingStaffInput, UserUncheckedCreateWithoutHousekeepingStaffInput>
  }

  export type CleaningTaskCreateWithoutAssignedToInput = {
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    area: HousekeepingAreaCreateNestedOneWithoutCleaningTasksInput
    verifications?: CleaningVerificationCreateNestedManyWithoutTaskInput
  }

  export type CleaningTaskUncheckedCreateWithoutAssignedToInput = {
    id?: number
    areaId: number
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifications?: CleaningVerificationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type CleaningTaskCreateOrConnectWithoutAssignedToInput = {
    where: CleaningTaskWhereUniqueInput
    create: XOR<CleaningTaskCreateWithoutAssignedToInput, CleaningTaskUncheckedCreateWithoutAssignedToInput>
  }

  export type CleaningTaskCreateManyAssignedToInputEnvelope = {
    data: CleaningTaskCreateManyAssignedToInput | CleaningTaskCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type CleaningVerificationCreateWithoutVerifiedByInput = {
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task: CleaningTaskCreateNestedOneWithoutVerificationsInput
  }

  export type CleaningVerificationUncheckedCreateWithoutVerifiedByInput = {
    id?: number
    taskId: number
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningVerificationCreateOrConnectWithoutVerifiedByInput = {
    where: CleaningVerificationWhereUniqueInput
    create: XOR<CleaningVerificationCreateWithoutVerifiedByInput, CleaningVerificationUncheckedCreateWithoutVerifiedByInput>
  }

  export type CleaningVerificationCreateManyVerifiedByInputEnvelope = {
    data: CleaningVerificationCreateManyVerifiedByInput | CleaningVerificationCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type CleaningSupplyRequestCreateWithoutRequestedByInput = {
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestItems?: CleaningSupplyRequestItemCreateNestedManyWithoutRequestInput
  }

  export type CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput = {
    id?: number
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestItems?: CleaningSupplyRequestItemUncheckedCreateNestedManyWithoutRequestInput
  }

  export type CleaningSupplyRequestCreateOrConnectWithoutRequestedByInput = {
    where: CleaningSupplyRequestWhereUniqueInput
    create: XOR<CleaningSupplyRequestCreateWithoutRequestedByInput, CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type CleaningSupplyRequestCreateManyRequestedByInputEnvelope = {
    data: CleaningSupplyRequestCreateManyRequestedByInput | CleaningSupplyRequestCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHousekeepingStaffInput = {
    update: XOR<UserUpdateWithoutHousekeepingStaffInput, UserUncheckedUpdateWithoutHousekeepingStaffInput>
    create: XOR<UserCreateWithoutHousekeepingStaffInput, UserUncheckedCreateWithoutHousekeepingStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHousekeepingStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHousekeepingStaffInput, UserUncheckedUpdateWithoutHousekeepingStaffInput>
  }

  export type UserUpdateWithoutHousekeepingStaffInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHousekeepingStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CleaningTaskUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: CleaningTaskWhereUniqueInput
    update: XOR<CleaningTaskUpdateWithoutAssignedToInput, CleaningTaskUncheckedUpdateWithoutAssignedToInput>
    create: XOR<CleaningTaskCreateWithoutAssignedToInput, CleaningTaskUncheckedCreateWithoutAssignedToInput>
  }

  export type CleaningTaskUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: CleaningTaskWhereUniqueInput
    data: XOR<CleaningTaskUpdateWithoutAssignedToInput, CleaningTaskUncheckedUpdateWithoutAssignedToInput>
  }

  export type CleaningTaskUpdateManyWithWhereWithoutAssignedToInput = {
    where: CleaningTaskScalarWhereInput
    data: XOR<CleaningTaskUpdateManyMutationInput, CleaningTaskUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type CleaningVerificationUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: CleaningVerificationWhereUniqueInput
    update: XOR<CleaningVerificationUpdateWithoutVerifiedByInput, CleaningVerificationUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<CleaningVerificationCreateWithoutVerifiedByInput, CleaningVerificationUncheckedCreateWithoutVerifiedByInput>
  }

  export type CleaningVerificationUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: CleaningVerificationWhereUniqueInput
    data: XOR<CleaningVerificationUpdateWithoutVerifiedByInput, CleaningVerificationUncheckedUpdateWithoutVerifiedByInput>
  }

  export type CleaningVerificationUpdateManyWithWhereWithoutVerifiedByInput = {
    where: CleaningVerificationScalarWhereInput
    data: XOR<CleaningVerificationUpdateManyMutationInput, CleaningVerificationUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type CleaningVerificationScalarWhereInput = {
    AND?: CleaningVerificationScalarWhereInput | CleaningVerificationScalarWhereInput[]
    OR?: CleaningVerificationScalarWhereInput[]
    NOT?: CleaningVerificationScalarWhereInput | CleaningVerificationScalarWhereInput[]
    id?: IntFilter<"CleaningVerification"> | number
    taskId?: IntFilter<"CleaningVerification"> | number
    verifiedById?: IntFilter<"CleaningVerification"> | number
    verificationDate?: DateTimeFilter<"CleaningVerification"> | Date | string
    rating?: IntFilter<"CleaningVerification"> | number
    cleanliness?: IntFilter<"CleaningVerification"> | number
    comments?: StringNullableFilter<"CleaningVerification"> | string | null
    photosUrl?: StringNullableFilter<"CleaningVerification"> | string | null
    status?: StringFilter<"CleaningVerification"> | string
    followUpRequired?: BoolFilter<"CleaningVerification"> | boolean
    followUpNotes?: StringNullableFilter<"CleaningVerification"> | string | null
    createdAt?: DateTimeFilter<"CleaningVerification"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningVerification"> | Date | string
  }

  export type CleaningSupplyRequestUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: CleaningSupplyRequestWhereUniqueInput
    update: XOR<CleaningSupplyRequestUpdateWithoutRequestedByInput, CleaningSupplyRequestUncheckedUpdateWithoutRequestedByInput>
    create: XOR<CleaningSupplyRequestCreateWithoutRequestedByInput, CleaningSupplyRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type CleaningSupplyRequestUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: CleaningSupplyRequestWhereUniqueInput
    data: XOR<CleaningSupplyRequestUpdateWithoutRequestedByInput, CleaningSupplyRequestUncheckedUpdateWithoutRequestedByInput>
  }

  export type CleaningSupplyRequestUpdateManyWithWhereWithoutRequestedByInput = {
    where: CleaningSupplyRequestScalarWhereInput
    data: XOR<CleaningSupplyRequestUpdateManyMutationInput, CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type CleaningSupplyRequestScalarWhereInput = {
    AND?: CleaningSupplyRequestScalarWhereInput | CleaningSupplyRequestScalarWhereInput[]
    OR?: CleaningSupplyRequestScalarWhereInput[]
    NOT?: CleaningSupplyRequestScalarWhereInput | CleaningSupplyRequestScalarWhereInput[]
    id?: IntFilter<"CleaningSupplyRequest"> | number
    requestedById?: IntFilter<"CleaningSupplyRequest"> | number
    requestDate?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    requiredBy?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    status?: StringFilter<"CleaningSupplyRequest"> | string
    approvedById?: IntNullableFilter<"CleaningSupplyRequest"> | number | null
    approvedAt?: DateTimeNullableFilter<"CleaningSupplyRequest"> | Date | string | null
    fulfilledAt?: DateTimeNullableFilter<"CleaningSupplyRequest"> | Date | string | null
    notes?: StringNullableFilter<"CleaningSupplyRequest"> | string | null
    createdAt?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupplyRequest"> | Date | string
  }

  export type HousekeepingAreaCreateWithoutCleaningTasksInput = {
    name: string
    description?: string | null
    floor?: string | null
    buildingSection?: string | null
    priority?: string
    cleaningFrequency: string
    specialInstructions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingAreaUncheckedCreateWithoutCleaningTasksInput = {
    id?: number
    name: string
    description?: string | null
    floor?: string | null
    buildingSection?: string | null
    priority?: string
    cleaningFrequency: string
    specialInstructions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingAreaCreateOrConnectWithoutCleaningTasksInput = {
    where: HousekeepingAreaWhereUniqueInput
    create: XOR<HousekeepingAreaCreateWithoutCleaningTasksInput, HousekeepingAreaUncheckedCreateWithoutCleaningTasksInput>
  }

  export type HousekeepingStaffCreateWithoutCleaningTasksInput = {
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHousekeepingStaffInput
    cleaningVerifications?: CleaningVerificationCreateNestedManyWithoutVerifiedByInput
    supplyRequests?: CleaningSupplyRequestCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffUncheckedCreateWithoutCleaningTasksInput = {
    id?: number
    userId: number
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningVerifications?: CleaningVerificationUncheckedCreateNestedManyWithoutVerifiedByInput
    supplyRequests?: CleaningSupplyRequestUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffCreateOrConnectWithoutCleaningTasksInput = {
    where: HousekeepingStaffWhereUniqueInput
    create: XOR<HousekeepingStaffCreateWithoutCleaningTasksInput, HousekeepingStaffUncheckedCreateWithoutCleaningTasksInput>
  }

  export type CleaningVerificationCreateWithoutTaskInput = {
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifiedBy: HousekeepingStaffCreateNestedOneWithoutCleaningVerificationsInput
  }

  export type CleaningVerificationUncheckedCreateWithoutTaskInput = {
    id?: number
    verifiedById: number
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningVerificationCreateOrConnectWithoutTaskInput = {
    where: CleaningVerificationWhereUniqueInput
    create: XOR<CleaningVerificationCreateWithoutTaskInput, CleaningVerificationUncheckedCreateWithoutTaskInput>
  }

  export type CleaningVerificationCreateManyTaskInputEnvelope = {
    data: CleaningVerificationCreateManyTaskInput | CleaningVerificationCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type HousekeepingAreaUpsertWithoutCleaningTasksInput = {
    update: XOR<HousekeepingAreaUpdateWithoutCleaningTasksInput, HousekeepingAreaUncheckedUpdateWithoutCleaningTasksInput>
    create: XOR<HousekeepingAreaCreateWithoutCleaningTasksInput, HousekeepingAreaUncheckedCreateWithoutCleaningTasksInput>
    where?: HousekeepingAreaWhereInput
  }

  export type HousekeepingAreaUpdateToOneWithWhereWithoutCleaningTasksInput = {
    where?: HousekeepingAreaWhereInput
    data: XOR<HousekeepingAreaUpdateWithoutCleaningTasksInput, HousekeepingAreaUncheckedUpdateWithoutCleaningTasksInput>
  }

  export type HousekeepingAreaUpdateWithoutCleaningTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    buildingSection?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    cleaningFrequency?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingAreaUncheckedUpdateWithoutCleaningTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    buildingSection?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    cleaningFrequency?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingStaffUpsertWithoutCleaningTasksInput = {
    update: XOR<HousekeepingStaffUpdateWithoutCleaningTasksInput, HousekeepingStaffUncheckedUpdateWithoutCleaningTasksInput>
    create: XOR<HousekeepingStaffCreateWithoutCleaningTasksInput, HousekeepingStaffUncheckedCreateWithoutCleaningTasksInput>
    where?: HousekeepingStaffWhereInput
  }

  export type HousekeepingStaffUpdateToOneWithWhereWithoutCleaningTasksInput = {
    where?: HousekeepingStaffWhereInput
    data: XOR<HousekeepingStaffUpdateWithoutCleaningTasksInput, HousekeepingStaffUncheckedUpdateWithoutCleaningTasksInput>
  }

  export type HousekeepingStaffUpdateWithoutCleaningTasksInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHousekeepingStaffNestedInput
    cleaningVerifications?: CleaningVerificationUpdateManyWithoutVerifiedByNestedInput
    supplyRequests?: CleaningSupplyRequestUpdateManyWithoutRequestedByNestedInput
  }

  export type HousekeepingStaffUncheckedUpdateWithoutCleaningTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningVerifications?: CleaningVerificationUncheckedUpdateManyWithoutVerifiedByNestedInput
    supplyRequests?: CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type CleaningVerificationUpsertWithWhereUniqueWithoutTaskInput = {
    where: CleaningVerificationWhereUniqueInput
    update: XOR<CleaningVerificationUpdateWithoutTaskInput, CleaningVerificationUncheckedUpdateWithoutTaskInput>
    create: XOR<CleaningVerificationCreateWithoutTaskInput, CleaningVerificationUncheckedCreateWithoutTaskInput>
  }

  export type CleaningVerificationUpdateWithWhereUniqueWithoutTaskInput = {
    where: CleaningVerificationWhereUniqueInput
    data: XOR<CleaningVerificationUpdateWithoutTaskInput, CleaningVerificationUncheckedUpdateWithoutTaskInput>
  }

  export type CleaningVerificationUpdateManyWithWhereWithoutTaskInput = {
    where: CleaningVerificationScalarWhereInput
    data: XOR<CleaningVerificationUpdateManyMutationInput, CleaningVerificationUncheckedUpdateManyWithoutTaskInput>
  }

  export type CleaningTaskCreateWithoutVerificationsInput = {
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    area: HousekeepingAreaCreateNestedOneWithoutCleaningTasksInput
    assignedTo?: HousekeepingStaffCreateNestedOneWithoutCleaningTasksInput
  }

  export type CleaningTaskUncheckedCreateWithoutVerificationsInput = {
    id?: number
    areaId: number
    assignedToId?: number | null
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningTaskCreateOrConnectWithoutVerificationsInput = {
    where: CleaningTaskWhereUniqueInput
    create: XOR<CleaningTaskCreateWithoutVerificationsInput, CleaningTaskUncheckedCreateWithoutVerificationsInput>
  }

  export type HousekeepingStaffCreateWithoutCleaningVerificationsInput = {
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHousekeepingStaffInput
    cleaningTasks?: CleaningTaskCreateNestedManyWithoutAssignedToInput
    supplyRequests?: CleaningSupplyRequestCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffUncheckedCreateWithoutCleaningVerificationsInput = {
    id?: number
    userId: number
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskUncheckedCreateNestedManyWithoutAssignedToInput
    supplyRequests?: CleaningSupplyRequestUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type HousekeepingStaffCreateOrConnectWithoutCleaningVerificationsInput = {
    where: HousekeepingStaffWhereUniqueInput
    create: XOR<HousekeepingStaffCreateWithoutCleaningVerificationsInput, HousekeepingStaffUncheckedCreateWithoutCleaningVerificationsInput>
  }

  export type CleaningTaskUpsertWithoutVerificationsInput = {
    update: XOR<CleaningTaskUpdateWithoutVerificationsInput, CleaningTaskUncheckedUpdateWithoutVerificationsInput>
    create: XOR<CleaningTaskCreateWithoutVerificationsInput, CleaningTaskUncheckedCreateWithoutVerificationsInput>
    where?: CleaningTaskWhereInput
  }

  export type CleaningTaskUpdateToOneWithWhereWithoutVerificationsInput = {
    where?: CleaningTaskWhereInput
    data: XOR<CleaningTaskUpdateWithoutVerificationsInput, CleaningTaskUncheckedUpdateWithoutVerificationsInput>
  }

  export type CleaningTaskUpdateWithoutVerificationsInput = {
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: HousekeepingAreaUpdateOneRequiredWithoutCleaningTasksNestedInput
    assignedTo?: HousekeepingStaffUpdateOneWithoutCleaningTasksNestedInput
  }

  export type CleaningTaskUncheckedUpdateWithoutVerificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingStaffUpsertWithoutCleaningVerificationsInput = {
    update: XOR<HousekeepingStaffUpdateWithoutCleaningVerificationsInput, HousekeepingStaffUncheckedUpdateWithoutCleaningVerificationsInput>
    create: XOR<HousekeepingStaffCreateWithoutCleaningVerificationsInput, HousekeepingStaffUncheckedCreateWithoutCleaningVerificationsInput>
    where?: HousekeepingStaffWhereInput
  }

  export type HousekeepingStaffUpdateToOneWithWhereWithoutCleaningVerificationsInput = {
    where?: HousekeepingStaffWhereInput
    data: XOR<HousekeepingStaffUpdateWithoutCleaningVerificationsInput, HousekeepingStaffUncheckedUpdateWithoutCleaningVerificationsInput>
  }

  export type HousekeepingStaffUpdateWithoutCleaningVerificationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHousekeepingStaffNestedInput
    cleaningTasks?: CleaningTaskUpdateManyWithoutAssignedToNestedInput
    supplyRequests?: CleaningSupplyRequestUpdateManyWithoutRequestedByNestedInput
  }

  export type HousekeepingStaffUncheckedUpdateWithoutCleaningVerificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    supplyRequests?: CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type CleaningSupplyRequestItemCreateWithoutSupplyInput = {
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    request: CleaningSupplyRequestCreateNestedOneWithoutRequestItemsInput
  }

  export type CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput = {
    id?: number
    requestId: number
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestItemCreateOrConnectWithoutSupplyInput = {
    where: CleaningSupplyRequestItemWhereUniqueInput
    create: XOR<CleaningSupplyRequestItemCreateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput>
  }

  export type CleaningSupplyRequestItemCreateManySupplyInputEnvelope = {
    data: CleaningSupplyRequestItemCreateManySupplyInput | CleaningSupplyRequestItemCreateManySupplyInput[]
    skipDuplicates?: boolean
  }

  export type CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutSupplyInput = {
    where: CleaningSupplyRequestItemWhereUniqueInput
    update: XOR<CleaningSupplyRequestItemUpdateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedUpdateWithoutSupplyInput>
    create: XOR<CleaningSupplyRequestItemCreateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedCreateWithoutSupplyInput>
  }

  export type CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutSupplyInput = {
    where: CleaningSupplyRequestItemWhereUniqueInput
    data: XOR<CleaningSupplyRequestItemUpdateWithoutSupplyInput, CleaningSupplyRequestItemUncheckedUpdateWithoutSupplyInput>
  }

  export type CleaningSupplyRequestItemUpdateManyWithWhereWithoutSupplyInput = {
    where: CleaningSupplyRequestItemScalarWhereInput
    data: XOR<CleaningSupplyRequestItemUpdateManyMutationInput, CleaningSupplyRequestItemUncheckedUpdateManyWithoutSupplyInput>
  }

  export type CleaningSupplyRequestItemScalarWhereInput = {
    AND?: CleaningSupplyRequestItemScalarWhereInput | CleaningSupplyRequestItemScalarWhereInput[]
    OR?: CleaningSupplyRequestItemScalarWhereInput[]
    NOT?: CleaningSupplyRequestItemScalarWhereInput | CleaningSupplyRequestItemScalarWhereInput[]
    id?: IntFilter<"CleaningSupplyRequestItem"> | number
    requestId?: IntFilter<"CleaningSupplyRequestItem"> | number
    supplyId?: IntFilter<"CleaningSupplyRequestItem"> | number
    quantityRequested?: IntFilter<"CleaningSupplyRequestItem"> | number
    quantityApproved?: IntNullableFilter<"CleaningSupplyRequestItem"> | number | null
    quantityFulfilled?: IntNullableFilter<"CleaningSupplyRequestItem"> | number | null
    notes?: StringNullableFilter<"CleaningSupplyRequestItem"> | string | null
    createdAt?: DateTimeFilter<"CleaningSupplyRequestItem"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSupplyRequestItem"> | Date | string
  }

  export type HousekeepingStaffCreateWithoutSupplyRequestsInput = {
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHousekeepingStaffInput
    cleaningTasks?: CleaningTaskCreateNestedManyWithoutAssignedToInput
    cleaningVerifications?: CleaningVerificationCreateNestedManyWithoutVerifiedByInput
  }

  export type HousekeepingStaffUncheckedCreateWithoutSupplyRequestsInput = {
    id?: number
    userId: number
    staffId: string
    supervisor?: boolean
    specializedAreas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cleaningTasks?: CleaningTaskUncheckedCreateNestedManyWithoutAssignedToInput
    cleaningVerifications?: CleaningVerificationUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type HousekeepingStaffCreateOrConnectWithoutSupplyRequestsInput = {
    where: HousekeepingStaffWhereUniqueInput
    create: XOR<HousekeepingStaffCreateWithoutSupplyRequestsInput, HousekeepingStaffUncheckedCreateWithoutSupplyRequestsInput>
  }

  export type CleaningSupplyRequestItemCreateWithoutRequestInput = {
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supply: CleaningSupplyCreateNestedOneWithoutSupplyRequestsInput
  }

  export type CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput = {
    id?: number
    supplyId: number
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestItemCreateOrConnectWithoutRequestInput = {
    where: CleaningSupplyRequestItemWhereUniqueInput
    create: XOR<CleaningSupplyRequestItemCreateWithoutRequestInput, CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput>
  }

  export type CleaningSupplyRequestItemCreateManyRequestInputEnvelope = {
    data: CleaningSupplyRequestItemCreateManyRequestInput | CleaningSupplyRequestItemCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type HousekeepingStaffUpsertWithoutSupplyRequestsInput = {
    update: XOR<HousekeepingStaffUpdateWithoutSupplyRequestsInput, HousekeepingStaffUncheckedUpdateWithoutSupplyRequestsInput>
    create: XOR<HousekeepingStaffCreateWithoutSupplyRequestsInput, HousekeepingStaffUncheckedCreateWithoutSupplyRequestsInput>
    where?: HousekeepingStaffWhereInput
  }

  export type HousekeepingStaffUpdateToOneWithWhereWithoutSupplyRequestsInput = {
    where?: HousekeepingStaffWhereInput
    data: XOR<HousekeepingStaffUpdateWithoutSupplyRequestsInput, HousekeepingStaffUncheckedUpdateWithoutSupplyRequestsInput>
  }

  export type HousekeepingStaffUpdateWithoutSupplyRequestsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHousekeepingStaffNestedInput
    cleaningTasks?: CleaningTaskUpdateManyWithoutAssignedToNestedInput
    cleaningVerifications?: CleaningVerificationUpdateManyWithoutVerifiedByNestedInput
  }

  export type HousekeepingStaffUncheckedUpdateWithoutSupplyRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    staffId?: StringFieldUpdateOperationsInput | string
    supervisor?: BoolFieldUpdateOperationsInput | boolean
    specializedAreas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningTasks?: CleaningTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    cleaningVerifications?: CleaningVerificationUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type CleaningSupplyRequestItemUpsertWithWhereUniqueWithoutRequestInput = {
    where: CleaningSupplyRequestItemWhereUniqueInput
    update: XOR<CleaningSupplyRequestItemUpdateWithoutRequestInput, CleaningSupplyRequestItemUncheckedUpdateWithoutRequestInput>
    create: XOR<CleaningSupplyRequestItemCreateWithoutRequestInput, CleaningSupplyRequestItemUncheckedCreateWithoutRequestInput>
  }

  export type CleaningSupplyRequestItemUpdateWithWhereUniqueWithoutRequestInput = {
    where: CleaningSupplyRequestItemWhereUniqueInput
    data: XOR<CleaningSupplyRequestItemUpdateWithoutRequestInput, CleaningSupplyRequestItemUncheckedUpdateWithoutRequestInput>
  }

  export type CleaningSupplyRequestItemUpdateManyWithWhereWithoutRequestInput = {
    where: CleaningSupplyRequestItemScalarWhereInput
    data: XOR<CleaningSupplyRequestItemUpdateManyMutationInput, CleaningSupplyRequestItemUncheckedUpdateManyWithoutRequestInput>
  }

  export type CleaningSupplyRequestCreateWithoutRequestItemsInput = {
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy: HousekeepingStaffCreateNestedOneWithoutSupplyRequestsInput
  }

  export type CleaningSupplyRequestUncheckedCreateWithoutRequestItemsInput = {
    id?: number
    requestedById: number
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestCreateOrConnectWithoutRequestItemsInput = {
    where: CleaningSupplyRequestWhereUniqueInput
    create: XOR<CleaningSupplyRequestCreateWithoutRequestItemsInput, CleaningSupplyRequestUncheckedCreateWithoutRequestItemsInput>
  }

  export type CleaningSupplyCreateWithoutSupplyRequestsInput = {
    name: string
    description?: string | null
    unit: string
    currentStock?: number
    reorderLevel?: number
    location?: string | null
    supplier?: string | null
    lastPurchaseDate?: Date | string | null
    lastPurchasePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyUncheckedCreateWithoutSupplyRequestsInput = {
    id?: number
    name: string
    description?: string | null
    unit: string
    currentStock?: number
    reorderLevel?: number
    location?: string | null
    supplier?: string | null
    lastPurchaseDate?: Date | string | null
    lastPurchasePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyCreateOrConnectWithoutSupplyRequestsInput = {
    where: CleaningSupplyWhereUniqueInput
    create: XOR<CleaningSupplyCreateWithoutSupplyRequestsInput, CleaningSupplyUncheckedCreateWithoutSupplyRequestsInput>
  }

  export type CleaningSupplyRequestUpsertWithoutRequestItemsInput = {
    update: XOR<CleaningSupplyRequestUpdateWithoutRequestItemsInput, CleaningSupplyRequestUncheckedUpdateWithoutRequestItemsInput>
    create: XOR<CleaningSupplyRequestCreateWithoutRequestItemsInput, CleaningSupplyRequestUncheckedCreateWithoutRequestItemsInput>
    where?: CleaningSupplyRequestWhereInput
  }

  export type CleaningSupplyRequestUpdateToOneWithWhereWithoutRequestItemsInput = {
    where?: CleaningSupplyRequestWhereInput
    data: XOR<CleaningSupplyRequestUpdateWithoutRequestItemsInput, CleaningSupplyRequestUncheckedUpdateWithoutRequestItemsInput>
  }

  export type CleaningSupplyRequestUpdateWithoutRequestItemsInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: HousekeepingStaffUpdateOneRequiredWithoutSupplyRequestsNestedInput
  }

  export type CleaningSupplyRequestUncheckedUpdateWithoutRequestItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyUpsertWithoutSupplyRequestsInput = {
    update: XOR<CleaningSupplyUpdateWithoutSupplyRequestsInput, CleaningSupplyUncheckedUpdateWithoutSupplyRequestsInput>
    create: XOR<CleaningSupplyCreateWithoutSupplyRequestsInput, CleaningSupplyUncheckedCreateWithoutSupplyRequestsInput>
    where?: CleaningSupplyWhereInput
  }

  export type CleaningSupplyUpdateToOneWithWhereWithoutSupplyRequestsInput = {
    where?: CleaningSupplyWhereInput
    data: XOR<CleaningSupplyUpdateWithoutSupplyRequestsInput, CleaningSupplyUncheckedUpdateWithoutSupplyRequestsInput>
  }

  export type CleaningSupplyUpdateWithoutSupplyRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPurchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPurchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyUncheckedUpdateWithoutSupplyRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPurchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPurchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    status?: string
    phoneNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    profileImage?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    provider?: string | null
    providerId?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: number
    permissionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    doctor?: DoctorUpdateOneWithoutUserNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    nurse?: NurseUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    nurse?: NurseUncheckedUpdateOneWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    biometricData?: BiometricDataUncheckedUpdateOneWithoutUserNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutUserNestedInput
    dutyRosters?: DutyRosterUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    housekeepingStaff?: HousekeepingStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyPatientInput = {
    id?: number
    invoiceId: number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogCreateManyUserInput = {
    id?: number
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status: string
    deviceId?: string | null
    verificationMode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyRosterCreateManyUserInput = {
    id?: number
    startDate: Date | string
    endDate: Date | string
    shiftStart: string
    shiftEnd: string
    department?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientDetails?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPatientInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUpdateWithoutUserInput = {
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRosterUpdateWithoutUserInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRosterUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyRosterUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftStart?: StringFieldUpdateOperationsInput | string
    shiftEnd?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: number
    patientId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionCreateManyDoctorInput = {
    id?: number
    patientId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabReportCreateManyDoctorInput = {
    id?: number
    patientId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyReportCreateManyDoctorInput = {
    id?: number
    patientId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterCreateManyDoctorInput = {
    id?: number
    name: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutDoctorInput = {
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    appointment?: AppointmentUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportUpdateWithoutDoctorInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutLabReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutLabReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyReportUpdateWithoutDoctorInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRadiologyReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutRadiologyReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterUpdateWithoutDoctorInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surgeries?: SurgeryUpdateManyWithoutOperationTheaterNestedInput
    equipments?: OperationTheaterEquipmentUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surgeries?: SurgeryUncheckedUpdateManyWithoutOperationTheaterNestedInput
    equipments?: OperationTheaterEquipmentUncheckedUpdateManyWithoutOperationTheaterNestedInput
  }

  export type OperationTheaterUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: number
    doctorId: number
    appointmentDate: Date | string
    startTime: string
    endTime: string
    status?: string
    reason?: string | null
    notes?: string | null
    followUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: number
    doctorId: number
    appointmentId?: number | null
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabReportCreateManyPatientInput = {
    id?: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyReportCreateManyPatientInput = {
    id?: number
    doctorId: number
    appointmentId?: number | null
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPatientDetailsInput = {
    id?: number
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationCreateManyPatientInput = {
    id?: number
    bedId: number
    nurseId?: number | null
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateManyPatientInput = {
    id?: number
    recordedBy: number
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientSubsidyCreateManyPatientInput = {
    id?: number
    schemeId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAppointmentNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutAppointmentNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
    appointment?: AppointmentUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportUpdateWithoutPatientInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutLabReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutLabReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyReportUpdateWithoutPatientInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutRadiologyReportsNestedInput
    appointment?: AppointmentUpdateOneWithoutRadiologyReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPatientDetailsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUpdateWithoutPatientInput = {
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bed?: BedUpdateOneRequiredWithoutBedAllocationsNestedInput
    nurse?: NurseUpdateOneWithoutBedAllocationsNestedInput
  }

  export type BedAllocationUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedId?: IntFieldUpdateOperationsInput | number
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedId?: IntFieldUpdateOperationsInput | number
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUpdateWithoutPatientInput = {
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nurse?: NurseUpdateOneRequiredWithoutVitalSignsNestedInput
  }

  export type VitalSignUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    recordedBy?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    recordedBy?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSubsidyUpdateWithoutPatientInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheme?: SubsidySchemeUpdateOneRequiredWithoutPatientSubsidiesNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutPatientSubsidyNestedInput
  }

  export type PatientSubsidyUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutPatientSubsidyNestedInput
  }

  export type PatientSubsidyUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignCreateManyNurseInput = {
    id?: number
    patientId: number
    temperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respiratoryRate?: number | null
    oxygenSaturation?: number | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationCreateManyNurseInput = {
    id?: number
    bedId: number
    patientId: number
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignUpdateWithoutNurseInput = {
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutVitalSignsNestedInput
  }

  export type VitalSignUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUpdateWithoutNurseInput = {
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bed?: BedUpdateOneRequiredWithoutBedAllocationsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBedAllocationsNestedInput
  }

  export type BedAllocationUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateManyAppointmentInput = {
    id?: number
    patientId: number
    doctorId: number
    prescriptionDate?: Date | string
    diagnosis: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabReportCreateManyAppointmentInput = {
    id?: number
    patientId: number
    doctorId: number
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    testResult?: string | null
    normalRange?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyReportCreateManyAppointmentInput = {
    id?: number
    patientId: number
    doctorId: number
    testDate?: Date | string
    reportDate?: Date | string | null
    testType: string
    findings?: string | null
    impression?: string | null
    notes?: string | null
    attachmentUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionUpdateWithoutAppointmentInput = {
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    prescriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportUpdateWithoutAppointmentInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutLabReportsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutLabReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutLabReportNestedInput
  }

  export type LabReportUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    testResult?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyReportUpdateWithoutAppointmentInput = {
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRadiologyReportsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutRadiologyReportsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutRadiologyReportNestedInput
  }

  export type RadiologyReportUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineCreateManyPrescriptionInput = {
    id?: number
    medicineId: number
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionMedicineUpdateWithoutPrescriptionInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicine?: MedicineUpdateOneRequiredWithoutPrescriptionMedicinesNestedInput
  }

  export type PrescriptionMedicineUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineCreateManyMedicineInput = {
    id?: number
    prescriptionId: number
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryLogCreateManyMedicineInput = {
    id?: number
    quantity: number
    type: string
    reason?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionMedicineUpdateWithoutMedicineInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescription?: PrescriptionUpdateOneRequiredWithoutMedicinesNestedInput
  }

  export type PrescriptionMedicineUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionMedicineUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLogUpdateWithoutMedicineInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLogUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLogUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyLabReportInput = {
    id?: number
    invoiceId: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    radiologyReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutLabReportInput = {
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
    radiologyReport?: RadiologyReportUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutLabReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    radiologyReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutLabReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    radiologyReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyRadiologyReportInput = {
    id?: number
    invoiceId: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    labReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutRadiologyReportInput = {
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
    labReport?: LabReportUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutRadiologyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    labReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutRadiologyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    labReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: number
    itemType: string
    itemId?: number | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    labReportId?: number | null
    radiologyReportId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: number
    patientId: number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimCreateManyInvoiceInput = {
    id?: number
    patientSubsidyId: number
    schemeId: number
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labReport?: LabReportUpdateOneWithoutInvoiceItemsNestedInput
    radiologyReport?: RadiologyReportUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    labReportId?: NullableIntFieldUpdateOperationsInput | number | null
    radiologyReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    labReportId?: NullableIntFieldUpdateOperationsInput | number | null
    radiologyReportId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimUpdateWithoutInvoiceInput = {
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidy?: PatientSubsidyUpdateOneRequiredWithoutSubsidyClaimsNestedInput
    scheme?: SubsidySchemeUpdateOneRequiredWithoutSubsidyClaimsNestedInput
  }

  export type SubsidyClaimUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientSubsidyId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientSubsidyId?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationCreateManyBedInput = {
    id?: number
    patientId: number
    nurseId?: number | null
    allocatedAt?: Date | string
    dischargedAt?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedAllocationUpdateWithoutBedInput = {
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutBedAllocationsNestedInput
    nurse?: NurseUpdateOneWithoutBedAllocationsNestedInput
  }

  export type BedAllocationUncheckedUpdateWithoutBedInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedAllocationUncheckedUpdateManyWithoutBedInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedCreateManyWardInput = {
    id?: number
    bedNumber: string
    status?: string
    price?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedUpdateWithoutWardInput = {
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bedAllocations?: BedAllocationUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateWithoutWardInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateManyWithoutWardInput = {
    id?: IntFieldUpdateOperationsInput | number
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgeryCreateManyOperationTheaterInput = {
    id?: number
    patientId: number
    surgeryDate: Date | string
    startTime: string
    endTime: string
    surgeryType: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationTheaterEquipmentCreateManyOperationTheaterInput = {
    id?: number
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    purchaseDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurgeryUpdateWithoutOperationTheaterInput = {
    patientId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgeryUncheckedUpdateWithoutOperationTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgeryUncheckedUpdateManyWithoutOperationTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    surgeryType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterEquipmentUpdateWithoutOperationTheaterInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterEquipmentUncheckedUpdateWithoutOperationTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationTheaterEquipmentUncheckedUpdateManyWithoutOperationTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceServiceCreateManyAmbulanceInput = {
    id?: number
    patientName: string
    patientContact: string
    pickupLocation: string
    dropLocation: string
    serviceDate: Date | string
    status?: string
    fare?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmbulanceServiceUpdateWithoutAmbulanceInput = {
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceServiceUncheckedUpdateWithoutAmbulanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmbulanceServiceUncheckedUpdateManyWithoutAmbulanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientName?: StringFieldUpdateOperationsInput | string
    patientContact?: StringFieldUpdateOperationsInput | string
    pickupLocation?: StringFieldUpdateOperationsInput | string
    dropLocation?: StringFieldUpdateOperationsInput | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    fare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateManyTpaInput = {
    id?: number
    userId: number
    patientId: string
    bloodGroup?: string | null
    height?: number | null
    weight?: number | null
    allergies?: string | null
    chronicDiseases?: string | null
    emergencyContact?: string | null
    emergencyName?: string | null
    emergencyRelation?: string | null
    insuranceProvider?: string | null
    insuranceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateWithoutTpaInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTpaInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    labReports?: LabReportUncheckedUpdateManyWithoutPatientNestedInput
    radiologyReports?: RadiologyReportUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientDetailsNestedInput
    bedAllocations?: BedAllocationUncheckedUpdateManyWithoutPatientNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    patientSubsidies?: PatientSubsidyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutTpaInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicDiseases?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyRelation?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateManyEmployeeInput = {
    id?: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentCreateManyEmployeeInput = {
    id?: number
    paymentDate: Date | string
    salaryMonth: string
    basicSalary: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    taxDeducted?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    transactionId?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentCreateManyEmployeeInput = {
    id?: number
    documentType: string
    documentName: string
    documentUrl: string
    isVerified?: boolean
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewCreateManyEmployeeInput = {
    id?: number
    reviewDate: Date | string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    reviewedBy: number
    rating: number
    strengths?: string | null
    areasOfImprovement?: string | null
    goals?: string | null
    comments?: string | null
    employeeComments?: string | null
    status?: string
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateWithoutEmployeeInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUpdateWithoutEmployeeInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeducted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUpdateWithoutEmployeeInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUpdateWithoutEmployeeInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    areasOfImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    employeeComments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSubsidyCreateManySchemeInput = {
    id?: number
    patientId: number
    enrollmentDate: Date | string
    enrollmentNumber: string
    cardNumber?: string | null
    validFrom: Date | string
    validUntil?: Date | string | null
    remainingBalance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    verificationStatus?: string
    verifiedBy?: number | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimCreateManySchemeInput = {
    id?: number
    patientSubsidyId: number
    invoiceId?: number | null
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientSubsidyUpdateWithoutSchemeInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPatientSubsidiesNestedInput
    subsidyClaims?: SubsidyClaimUpdateManyWithoutPatientSubsidyNestedInput
  }

  export type PatientSubsidyUncheckedUpdateWithoutSchemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subsidyClaims?: SubsidyClaimUncheckedUpdateManyWithoutPatientSubsidyNestedInput
  }

  export type PatientSubsidyUncheckedUpdateManyWithoutSchemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentNumber?: StringFieldUpdateOperationsInput | string
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimUpdateWithoutSchemeInput = {
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientSubsidy?: PatientSubsidyUpdateOneRequiredWithoutSubsidyClaimsNestedInput
    invoice?: InvoiceUpdateOneWithoutSubsidyClaimsNestedInput
  }

  export type SubsidyClaimUncheckedUpdateWithoutSchemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientSubsidyId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimUncheckedUpdateManyWithoutSchemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientSubsidyId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimCreateManyPatientSubsidyInput = {
    id?: number
    schemeId: number
    invoiceId?: number | null
    claimDate?: Date | string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    rejectionReason?: string | null
    claimStatus?: string
    processedBy?: number | null
    processedAt?: Date | string | null
    reimbursementDate?: Date | string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubsidyClaimUpdateWithoutPatientSubsidyInput = {
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheme?: SubsidySchemeUpdateOneRequiredWithoutSubsidyClaimsNestedInput
    invoice?: InvoiceUpdateOneWithoutSubsidyClaimsNestedInput
  }

  export type SubsidyClaimUncheckedUpdateWithoutPatientSubsidyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubsidyClaimUncheckedUpdateManyWithoutPatientSubsidyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemeId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    claimStatus?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningTaskCreateManyAreaInput = {
    id?: number
    assignedToId?: number | null
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningTaskUpdateWithoutAreaInput = {
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: HousekeepingStaffUpdateOneWithoutCleaningTasksNestedInput
    verifications?: CleaningVerificationUpdateManyWithoutTaskNestedInput
  }

  export type CleaningTaskUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifications?: CleaningVerificationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type CleaningTaskUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningTaskCreateManyAssignedToInput = {
    id?: number
    areaId: number
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration: number
    priority?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningVerificationCreateManyVerifiedByInput = {
    id?: number
    taskId: number
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestCreateManyRequestedByInput = {
    id?: number
    requestDate?: Date | string
    requiredBy: Date | string
    status?: string
    approvedById?: number | null
    approvedAt?: Date | string | null
    fulfilledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningTaskUpdateWithoutAssignedToInput = {
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: HousekeepingAreaUpdateOneRequiredWithoutCleaningTasksNestedInput
    verifications?: CleaningVerificationUpdateManyWithoutTaskNestedInput
  }

  export type CleaningTaskUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifications?: CleaningVerificationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type CleaningTaskUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationUpdateWithoutVerifiedByInput = {
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: CleaningTaskUpdateOneRequiredWithoutVerificationsNestedInput
  }

  export type CleaningVerificationUncheckedUpdateWithoutVerifiedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestUpdateWithoutRequestedByInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestItems?: CleaningSupplyRequestItemUpdateManyWithoutRequestNestedInput
  }

  export type CleaningSupplyRequestUncheckedUpdateWithoutRequestedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestItems?: CleaningSupplyRequestItemUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CleaningSupplyRequestUncheckedUpdateManyWithoutRequestedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredBy?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationCreateManyTaskInput = {
    id?: number
    verifiedById: number
    verificationDate?: Date | string
    rating: number
    cleanliness: number
    comments?: string | null
    photosUrl?: string | null
    status?: string
    followUpRequired?: boolean
    followUpNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningVerificationUpdateWithoutTaskInput = {
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: HousekeepingStaffUpdateOneRequiredWithoutCleaningVerificationsNestedInput
  }

  export type CleaningVerificationUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    verifiedById?: IntFieldUpdateOperationsInput | number
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningVerificationUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    verifiedById?: IntFieldUpdateOperationsInput | number
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanliness?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    photosUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemCreateManySupplyInput = {
    id?: number
    requestId: number
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestItemUpdateWithoutSupplyInput = {
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: CleaningSupplyRequestUpdateOneRequiredWithoutRequestItemsNestedInput
  }

  export type CleaningSupplyRequestItemUncheckedUpdateWithoutSupplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemUncheckedUpdateManyWithoutSupplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemCreateManyRequestInput = {
    id?: number
    supplyId: number
    quantityRequested: number
    quantityApproved?: number | null
    quantityFulfilled?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSupplyRequestItemUpdateWithoutRequestInput = {
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supply?: CleaningSupplyUpdateOneRequiredWithoutSupplyRequestsNestedInput
  }

  export type CleaningSupplyRequestItemUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplyId?: IntFieldUpdateOperationsInput | number
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSupplyRequestItemUncheckedUpdateManyWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplyId?: IntFieldUpdateOperationsInput | number
    quantityRequested?: IntFieldUpdateOperationsInput | number
    quantityApproved?: NullableIntFieldUpdateOperationsInput | number | null
    quantityFulfilled?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}